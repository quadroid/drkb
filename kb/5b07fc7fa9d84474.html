<!DOCTYPE html>
<html>
<head>
  <title>Программирование Sound Blaster</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Программирование Sound Blaster</h1>
<div id="date">01.01.2010</div>

<p>Статья взята с " target=_blankhttp://www.programmist.info[/i]</p>
<p>Программирование Sound Blaster</p>
<p>Sound Blaster воспроизводит как синтезированный звук так и оцифровые звуки.</p>
<p>В этом файле будет расмотрено программирование воспроизведения цифровых</p>
<p>выборок через Sound Blaster DSP.</p>
<p>+-------------------------------------+-------------------------------------</p>
<p>| Порты ввода/вывода SoundBlaster DSP |</p>
<p>+=====================================+</p>
<p>Чип DSP ( Цифровой Звуковой Процессор ) программируется через пять портов,</p>
<p>которые определяются через базовый адрес Sound Blaster:</p>
<p>2x6h - DSP Сброс</p>
<p>2xAh - DSP Чтение</p>
<p>2xCh - DSP Запись (команды/данные) ,</p>
<p>состояние буфера записи DSP( Бит 7 )</p>
<p>2xEh - Состояние буфер чтения DSP ( Бит 7 ),</p>
<p>подтверждение прерывания DSP</p>
<p>Пятый порт только для Sound Blaster 16</p>
<p>2xFh - подтверждение прерывания DSP с 16 битами</p>
<p>Где x = 1 для базового адреса 210h.</p>
<p>x = 2 для базового адреса 220h.</p>
<p>.</p>
<p>.</p>
<p>x = 6 для базового адреса 260h.</p>
<p>+-----------+----------------------------------------------------------------</p>
<p>| Сброс DSP |</p>
<p>+===========+ </p>
<p>Необходимо сбросить DSP прежде, чем начать работу с ним. Сброс осуществляется</p>
<p>по следующему алгоритму:</p>
<p>1) Запишите 1 в порт сброса (2x6)</p>
<p>2) Ждите 3 микросекунды</p>
<p>3) Запишите 0 в порт сброса (2x6)</p>
<p>4) Читайте порт состояния буфера чтения (2xE) пока бит 7 = 1</p>
<p>5) Опрашивайте порт данных чтения (2xA) пока вы не получите AAh.</p>
<p>Для сброса DSP требуется около 100 мкс. Если после этого вы не получили</p>
<p>AAh. Значит, либо нет звуковой платы, или задан был неверный базовый</p>
<p>адрес.</p>
<p>Пример:</p>
<p>#define MAX_BASE_SB 5</p>
<p>int bases[MAX_BASE_SB]={ 0x220, 0x230, 0x240, 0x250, 0x260 };</p>
<p>int baseAddrSB=0x220;</p>
<p>// Прочитать</p>
<p>unsigned char pascal ReadSB</p>
<p>(void)</p>
<p>{</p>
<p>unsigned int value;</p>
<p>while (!(inp((baseAddrSB+0xE)) &amp; 0x80));</p>
<p>value = inp((baseAddrSB+0xA));</p>
<p>return value;</p>
<p>}</p>
<p>// Проверить наличие</p>
<p>char pascal CheckSB</p>
<p>( void )</p>
<p>{</p>
<p>int i, j;</p>
<p>for ( j=0; j 23 KHz. Затем младший</p>
<p>байт длины, потом старший.</p>
<p>WriteSB(DMA_8_BIT_DAC);</p>
<p>WriteSB(lo(len));</p>
<p>WriteSB(hi(len));</p>
<p>24h - Включение записи с ADC 8 Бит 4KHz - &gt; 23 KHz</p>
<p>74h - Включение вывода на DAC 4 Бит ADPCM 4KHz - &gt; 12 KHz</p>
<p>75h - Включение вывода на DAC 4 Бит ADPCM с 4KHz - &gt; 12 KHz с байтом ссылки</p>
<p>76h - Включение вывода на DAC 2.6 Бит ADPCM 4KHz - &gt; 13 KHz</p>
<p>77h - Включение вывода на DAC 2.6 Бит ADPCM с 4KHz - &gt; 13 KHz с байтом ссылки</p>
<p>16h - Включение вывода на DAC 2 Бит ADPCM 4KHz - &gt; 11 KHz</p>
<p>17h - Включение вывода на DAC 2 Бит ADPCM с 4KHz - &gt; 11 KHz с байтом ссылки</p>
<p>ADPCM ( Адаптивная Импульсно-кодовая Модуляция) - это звуковая методика</p>
<p>сжатия, где различие между последовательными выборками сохраняется скорее</p>
<p>чем их фактические значения. В режимах с байтами ссылки, первый байт -</p>
<p>фактическое начальное значение. Наличие режимов с и без байтов ссылки значит</p>
<p>что вы можете выводить последовательные блоки без наличия байта ссылки.</p>
<p>Bxh - программмирование режима DMA с 16 битным цифровым звуком.</p>
<p>( Только для SB16 )</p>
<p>Командная последовательность:</p>
<p>Команда, Режим, Lo(Length-1), Hi(Length-1):</p>
<p>Первый байт команды состоит:</p>
<p>D7 D6 D5 D4 D3 D2 D1 D0</p>
<p>--+--+--+--+---+----+-----+--</p>
<p>1 0 1 1 A/D A/I FIFO 0</p>
<p>---------------+----+-----+--</p>
<p>0=D/A 0=SC 0=off </p>
<p>1=A/D 1=AI 1=on </p>
<p>Общие команды:</p>
<p>B8 - одиночный цикл с 16-битной записи звука</p>
<p>B0 - одиночного цикла с 16-битным воспроизведением</p>
<p>BE - автоинициализируемая 16-битная запись</p>
<p>B6 - автоинициализируемое 16-битной воспроизведение</p>
<p>Режим:</p>
<p>D7 D6 D5 D4 D3 D2 D1 D0</p>
<p>---+--+-------+-----+--+--+--+--</p>
<p>0 0 Стерео Знак 0 0 0 0</p>
<p>0-Моно 0-без</p>
<p>1-Стерео 1-со знаком</p>
<p>Cxh - программирование режим DMA с 8-битным цифровым звуком.</p>
<p>( Только для SB16 )</p>
<p>Те же самые команды, что для 16-бит.</p>
<p>C8 - одиночный цикл с 8-битной записи звука</p>
<p>C0 - одиночного цикла с 8-битным воспроизведением</p>
<p>CE - автоинициализируемая 8-битная запись</p>
<p>C6 - автоинициализируемое 8-битной воспроизведение</p>
<p>FIFO используется чтобы удалять несогласованности в тот период выборки,</p>
<p>когда звуковая плата не способна получить DMA, когда это требуется.</p>
<p>Без FIFO плата делает попытку захвата DMA в точно тот момент, когда</p>
<p>требуется выборка. Если другое устройство с более высоким приоритетом</p>
<p>обращается к DMA, звуковая плата ожидает и скорость выборки может</p>
<p>уменьшаться. FIFO позволяет во время выборки с DMA быть более гибким DSP</p>
<p>без потери звукового качества. FIFO очищается всякий раз, когда команда</p>
<p>посылается DSP. В режиме одиночного цикла, DSP постоянно перепрограммируется.</p>
<p>С FIFO DSP может еще содержать данные, который не были выданы, когда</p>
<p>команда очистила DAC. Чтобы избежать этого, FIFO должен быть переключен</p>
<p>в режим с одиночным циклом. Затем, снова переведен в автоинициализируемый</p>
<p>режим, когда DSP не перепрограммируется.</p>
<p>1Ch - Включение вывода на DAC 8 Бит 4KHz - &gt; 23 KHz с автоинциализацией</p>
<p>90h - Включение вывода на DAC 8 бит 4kHz - &gt; 44 KHz с автоинициализацией</p>
<p>48h - Установить длину блока на пересылку перед посылкой 91h, 99h</p>
<p>сначала младший байт затем старший длину.</p>
<p>91h - Включение вывода на DAC 8 бит 4kHz - &gt; 44 KHz стерео</p>
<p>99h - Включение записи с ADC 8 бит 4kHz - &gt; 44 KHz стерео</p>
<p>WriteSB(SET_LEN_DMA_8_BIT);</p>
<p>WriteSB(lo(len));</p>
<p>WriteSB(hi(len));</p>
<p>WriteSB(DMA_8_BIT_DAC_HI);</p>
<p>D0h - остановить 8-битный DMA</p>
<p>D4h - возобновить 8-битный DMA</p>
<p>D5h - остановить 16-битный DMA</p>
<p>D6h - возобновить 16-битный DMA</p>
<p>Эти команды пригодны как и для автоинциализированного режима,</p>
<p>так и для одиночных циклов.</p>
<p>D9h - Выход из авто инициализируемого режима DMA с 16 битами</p>
<p>после окончания текущего блока.</p>
<p>DAh - Выход из авто инициализируемого режима DMA с 8 битами</p>
<p>после окончания текущего блока.</p>
<p>E1h - Получить номер версии DSP. После посылки этой команды, прочитайте</p>
<p>из DSP два байта. Первый байт - главный номер версии и второй</p>
<p>байт - малый номер версии. Версия 4.00 - это SB16.</p>
<p>Версия | Стерео | Частота | FIFO | 16 бит</p>
<p>--------+--------+----------+------+--------</p>
<p>&lt; 2.00 | - | до 21379 | - | -</p>
<p>&gt;= 2.00 | - | до 21379 | + | -</p>
<p>&gt;= 2.01 | - | до 43478 | + | -</p>
<p>&gt;= 3.00 | + | до 43478 | + | -</p>
<p>&gt;= 3.01 | + | до 43478 | + | +</p>
<p>Пример определения версии:</p>
<p>int pascal VersionSB</p>
<p>( void )</p>
<p>{</p>
<p>char ch, ch1;</p>
<p>WriteSB(0xE1);</p>
<p>ch=ReadSB();</p>
<p>ch1=ReadSB();</p>
<p>verSB=ch&lt;&lt;8 | ch1;</p>
<p>if ( verSB&gt;=0x200 )</p>
<p>Fifo=1;</p>
<p>if ( verSB&gt;=0x201 )</p>
<p>MaxFrequency=1;</p>
<p>if ( verSB&gt;=0x300 )</p>
<p>Stereo=1;</p>
<p>if ( verSB&gt;=0x301 )</p>
<p>SixteenBit=1;</p>
<p>return verSB;</p>
<p>}</p>
<p>+----------------------+----------------------------------------------------</p>
<p>| Программирование DMA |</p>
<p>+======================+</p>
<p>Контроллер DMA (Прямого Доступа В память) управляет пересылками данных</p>
<p>между устройствами ввода/вывода и памятью без использования центрального</p>
<p>процессора. IBM совместимая ЭВМ имеет два контроллера DMA один для</p>
<p>пересылок с 8 битами и другой для пересылок с 16 битами. Контроллер DMA,</p>
<p>вместе с внешним регистром страницы, способен на перемещение блоков по 64 КБ.</p>
<p>Ниже приведена информация по программированию DMA.</p>
<p>Адреса портов для адреса DMA и регистров счета.</p>
<p>Контроллер | Адрес | Функция</p>
<p>---------------+---------+-----------------</p>
<p>DMA 1 | 00 | Канал 0 адреса</p>
<p>c 8 битами | 01 | Канал 0 счета</p>
<p>Подчиненный | 02 | Канал 1 адрес</p>
<p>| 03 | Канал 1 счета</p>
<p>| 04 | Канал 2 адреса</p>
<p>| 05 | Канал 2 счета</p>
<p>| 06 | Канал 3 адреса</p>
<p>| 07 | Канал 3 счета</p>
<p>--------------+---------+------------------</p>
<p>DMA 2 | C0 | Канал 4 адреса</p>
<p>с 16 битами | C2 | Канал 4 счета</p>
<p>Ведущий | C4 | Канал 5 адреса</p>
<p>| C6 | Канал 5 счета</p>
<p>| C8 | Канал 6 адреса</p>
<p>| CA | Канал 6 счета</p>
<p>| CC | Канал 7 адреса</p>
<p>| CE | Канал 7 счета</p>
<p>Адреса портов для регистров управления</p>
<p>Адрес | Операция| Функция</p>
<p>DMAC1 DMAC2 | |</p>
<p>------------+---------+-----------------------------------</p>
<p>0A D4 | Запись | регистр маски</p>
<p>0B D6 | Запись | регистр режима</p>
<p>0C D8 | Запись | регистр сброс байта flip-flop</p>
<p>Адреса портов для младших регистров страницы</p>
<p>Адрес | Функция</p>
<p>--------+-----------------------------------</p>
<p>81 | 2 Канал DMA с 8 битами</p>
<p>82 | 3 Канал DMA с 8 битами</p>
<p>83 | 1 Канал DMA с 8 битами</p>
<p>87 | 0 Канал DMA с 8 битами</p>
<p>89 | 6 Канал DMA с 16 битами</p>
<p>8A | 7 Канал DMA с 16 битами</p>
<p>8B | 5 Канал DMA с 16 битами</p>
<p>Бита регистра режима</p>
<p>БИТ | Функция</p>
<p>---------+----------------------------------</p>
<p>Биты 7:6 | Биты выбора Режима</p>
<p>00 | Выбранный Режим запроса</p>
<p>01 | Одиночный выбранный режим</p>
<p>10 | Выбранный блочный режим</p>
<p>11 | Каскадный выбранный режим</p>
<p>---------+----------------------------------</p>
<p>Бит 5 | Бит приращения / декремента Адреса</p>
<p>1 | Выбранный Декремент адреса</p>
<p>0 | Выбранное Приращение адреса</p>
<p>---------+----------------------------------</p>
<p>Бит 4 | Авто инициализация</p>
<p>1 | Автоинициализация включена</p>
<p>0 | Одиночный </p>
<p>---------+----------------------------------</p>
<p>Биты 3:2 | Биты Пересылки</p>
<p>00 | Проверите пересылку</p>
<p>01 | Запишите пересылку ( К памяти )</p>
<p>10 | Читайте пересылку ( Из памяти )</p>
<p>11 | Запрещенный</p>
<p>** | Игнорируется если биты 7:6 = 11</p>
<p>---------+----------------------------------</p>
<p>Биты 1:0 | Биты выбора Канала</p>
<p>00 | Выберите канал 0 (4)</p>
<p>01 | Выберите канал 1 (5)</p>
<p>10 | Выберите канал 2 (6)</p>
<p>11 | Выберите канал 3 (7)</p>
<p>Биты маски записи</p>
<p>БИТ | Функция</p>
<p>----------+-----------------------------------</p>
<p>Биты 7:3 | Неиспользуемый ( Набор к 0 )</p>
<p>|</p>
<p>Бит 2 | Установить/сбросить бит маски</p>
<p>1 | Установить бит маски ( Отключите канал )</p>
<p>0 | Сбросить бит маски ( Доступен канал )</p>
<p>----------+------------------------------------</p>
<p>Биты 1:0 | Биты выбора Канала</p>
<p>00 | канал 0 (4)</p>
<p>01 | канал 1 (5)</p>
<p>10 | канал 2 (6)</p>
<p>11 | канал 3 (7)</p>
<p>DMAC2 используется для работы с 16 битами и DMAC1 используется для</p>
<p>работы с 8 битами. Вот пример программирования DMA:</p>
<p>1) Вычислите абсолютный линейный адрес вашего буфера</p>
<p>LinearAddr = MK_SEG( Buf ) * 16L + MK_OFF ( Buf );</p>
<p>2) Отключите канал DMA звуковой платы установкой бита маски</p>
<p>outp(MaskPort, 1 + ( DMAChannel % 4 ));</p>
<p>3) Очистите указатель байта flip-flop</p>
<p>outp(ClrPort, DMAChannel );</p>
<p>4) Запишите режим DMA для пересылки</p>
<p>Биты выбора режима должны устанавливаться в 00h для режима запроса.</p>
<p>Адрес бита +/- должен устанавливаться в 0 для приращения адреса.</p>
<p>Бит автоинициализации должен устанавливаться соответственно.</p>
<p>Биты пересылки должны устанавливаться в 10h для воспроизведения и</p>
<p>01h для записи. Выбор канала должен устанавливаться так же как и на</p>
<p>канал DMA звуковой платы.</p>
<p>outp(ModePort, Mode + ( DMAChannel % 4 ));</p>
<p>Некоторые часто используемые режимы:</p>
<p>48h + Канал - одиночный цикл воспроизведение</p>
<p>58h + Канал - автоинициализируемое воспроизведение</p>
<p>44h + Канал - запись одиночного цикла</p>
<p>54h + Канал - автоинициализируемая запись</p>
<p>5) Запишите смещение буфера, младший байт затем старший байт. Для</p>
<p>шестнадцати разрядных данных, смещение должно быть в словах от начала</p>
<p>128k-байтной страницы, для 8-битных от 64K. Самый простой метод для</p>
<p>вычисления смещения с 16 битами - это разделить линейный адрес на</p>
<p>два перед вычислением смещения.</p>
<p>#define lo(value) (unsigned char)((value) &amp; 0x00FF)</p>
<p>#define hi(value) (unsigned char)((value) &gt;&gt; 8)</p>
<p>if ( SixteenBit==1 )</p>
<p>BufOffset= ( LinearAddr / 2 ) % 65536;</p>
<p>else BufOffset= LinearAddr % 65536;</p>
<p>outp(BaseAddrPort, lo(BufOffset));</p>
<p>outp(BaseAddrPort, hi(BufOffset));</p>
<p>6) Запишите длину пересылки в соответствующий порт счета, младший</p>
<p>байт затем старший байт. Для пересылки с 8 битами, запишите</p>
<p>длину в байтах минус единица. Для пересылки с 16 битами, запишите</p>
<p>номер длину в словах минус единица.</p>
<p>if ( SixteenBit==1 )</p>
<p>TransferLength/=2;</p>
<p>outp(CountPort, lo(TransferLength-1));</p>
<p>outp(CountPort, hi(TransferLength-1));</p>
<p>7) Запишите страницу буфера в регистр страницы DMA.</p>
<p>outp(PagePort, ( LinearAddr / 65536));</p>
<p>8) Включите DMA звуковой платы очистив соответствующий бит маски</p>
<p>outp(MaskPort, DMAChannel % 4);</p>
<p>Пример :</p>
<p>int MaskPort, ClrPort, ModePort, ModeDMA, CountPort, PagePort,</p>
<p>BaseAddrPort;</p>
<p>int pageports[4]={ 0x87, 0x83, 0x81, 0x82 };</p>
<p>MaskPort=0x0A; ClrPort=0xC; ModePort=0xB;</p>
<p>ModeDMA=0x48+DMAChannel;</p>
<p>CountPort=1+DMAChannel*2;</p>
<p>BaseAddrPort=DMAChannel*2;</p>
<p>PagePort=pageports[DMAChannel];</p>
<p>outportb(MaskPort, 4 + DMAChannel);</p>
<p>outportb(ClrPort, DMAChannel );</p>
<p>outportb(ModePort, ModeDMA );</p>
<p>outportb(BaseAddrPort,lo(aligned_physical));</p>
<p>outportb(BaseAddrPort,hi(aligned_physical));</p>
<p>outportb(PagePort,(unsigned char)((aligned_physical&gt;&gt;16)&amp;0xFF));</p>
<p>outportb(CountPort,lo(len-1));</p>
<p>outportb(CountPort,hi(len-1));</p>
<p>outportb(MaskPort, DMAChannel );</p>
<p>+---------------------------+------------------------------------------------</p>
<p>| Установка частоты выборки |</p>
<p>+===========================+</p>
<p>Для версии Sound Blaster ниже 4.00 установка частоты выборки выполняется</p>
<p>посылкой DSP команды 40h. При этом частота преобразуется к константе времени</p>
<p>по формуле:</p>
<p>4KHz - &gt; 23 KHz:</p>
<p>Time Constant = 256 - (1,000,000 / sampling rate)</p>
<p>= 256 - (1,000,000 / 8,000 )</p>
<p>= 131</p>
<p>4KHz - &gt; 44 KHz:</p>
<p>Time Constant = (MSByte of) 65536 - (256,000,000 / sampling rate)</p>
<p>= (MSByte of) 65536 - (256,000,000 / 44,100)</p>
<p>= (MSByte of) 59731</p>
<p>= (MSByte of) 0E953h</p>
<p>= 0E9h</p>
<p>void pascal RateSB</p>
<p>( unsigned int rate )</p>
<p>{</p>
<p>unsigned char tc;</p>
<p>if ( MaxFrequency==0 )</p>
<p>{</p>
<p>if ( rate&lt;5000 ) rate=5000;</p>
<p>if ( rate&gt;22528 ) rate=22528;</p>
<p>tc = (unsigned char)(256 - (1000000/rate));</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>if ( rate&lt;5000 ) rate=5000;</p>
<p>if ( rate&gt;45056 ) rate=45056;</p>
<p>tc = (unsigned char)(hi((unsigned int)(65536-(256000000L/rate))));</p>
<p>}</p>
<p>WriteSB(TIME_CONSTANT);</p>
<p>WriteSB(tc);</p>
<p>}</p>
<p>В отличие от этого SB16 программируется фактической частотой выборки.</p>
<p>Команда 41h используется для воспроизведения, а 42h используется для записи.</p>
<p>if ( Play==1 )</p>
<p>WriteSB ( 0x41 );</p>
<p>else WriteSB ( 0x42 );</p>
<p>WriteSB ( hi( frequency ) );</p>
<p>WriteSB ( lo( frequency ) );</p>
<p>+---------------------------------------+------------------------------------</p>
<p>| Алгоритм цифрового ввода/вывода звука |</p>
<p>+=======================================+</p>
<p>Чтобы записывать или воспроизводить звук, вы должны использовать следующую</p>
<p>последовательность:</p>
<p>1) Распределите буфер который не пересекает границу 64 Kb</p>
<p>2) Установите программу обработки прерывания.</p>
<p>3) Запрограммируйте контроллер DMA для фоновой пересылки</p>
<p>4) Установите частоту выборки</p>
<p>5) Запишите команду I/O в DSP</p>
<p>6) Запишите режим пересылки I/O в DSP</p>
<p>7) Запишите размер блока в DSP ( Младший байт/Старший байт )</p>
<p>После этого сразу начнется запись или воспроизведение звука.</p>
<p>Выделение памяти под буфер DMA:</p>
<p>data=(char far *)farmalloc(131000L);</p>
<p>if ( data==NULL )</p>
<p>{</p>
<p>printf("Нет места под буфер DMA\n");</p>
<p>return 0;</p>
<p>}</p>
<p>physical=((unsigned long)FP_OFF(data))+(((unsigned long)FP_SEG(data))&lt;&lt;4);</p>
<p>aligned_physical=physical+0x0FFFFL;</p>
<p>aligned_physical&amp;=0xF0000L;</p>
<p>aligned=MK_FP((unsigned )((aligned_physical &gt;&gt; 4) &amp; 0xFFFF),0);</p>
<p>Ниже приведены примеры последовательностей для программирования SB</p>
<p>с помощью DMA.</p>
<p>Нормальная частота, воспроизведение:</p>
<p>1) Записать D1h в 2xCh</p>
<p>2) Установить обработчик прерывания</p>
<p>3) Записать 40h в 2xCh</p>
<p>4) Записать константы времени в 2xCh</p>
<p>5) Запрограммировать DMA</p>
<p>6) Записать 14h в 2xCh</p>
<p>7) Записать длину выборки</p>
<p>8) Обслуживать прерывания, до окончания выборки</p>
<p>9) Восстановить старый обработчик</p>
<p>10) Записать D3h в 2xCh</p>
<p>При этом можно записывать любые команды в DSP, пока идет воспроизведение.</p>
<p>Повышенная частота, воспроизведение:</p>
<p>1) Записать D1h в 2xCh</p>
<p>2) Установить обработчик прерывания</p>
<p>3) Записать 40h в 2xCh</p>
<p>4) Записать константы времени в 2xCh</p>
<p>5) Запрограммировать DMA</p>
<p>6) Записать 48h в 2xCh</p>
<p>7) Записать длину выборки</p>
<p>8) Записать 91h в 2xCh</p>
<p>9) Обслуживать прерывания, до окончания выборки</p>
<p>10) Восстановить старый обработчик</p>
<p>11) Записать D3h в 2xCh</p>
<p>Нормальная частота, запись звука:</p>
<p>1) Установить обработчик прерывания</p>
<p>2) Записать 40h в 2xCh</p>
<p>3) Записать константы времени в 2xCh</p>
<p>4) Запрограммировать DMA</p>
<p>5) Записать 24h в 2xCh</p>
<p>6) Записать длину выборки</p>
<p>7) Обслуживать прерывания, до окончания выборки</p>
<p>8) Восстановить старый обработчик</p>
<p>При этом можно посылать любые команды в DSP, пока идет запись.</p>
<p>Повышенная частота, запись:</p>
<p>1) Установить обработчик прерывания</p>
<p>2) Записать 40h в 2xCh</p>
<p>3) Записать константы времени в 2xCh</p>
<p>4) Запрограммировать DMA</p>
<p>5) Записать 48h в 2xCh</p>
<p>6) Записать длину выборки</p>
<p>7) Записать 99h в 2xCh</p>
<p>8) Обслуживать прерывания, до окончания выборки</p>
<p>9) Восстановить старый обработчик</p>
<p>+------------------------------------+--------------------------------------</p>
<p>| Конец цифрового ввода/вывода звука |</p>
<p>+====================================+</p>
<p>Когда пересылка закончена генерируется прерывание. Фактический номер</p>
<p>прерывания зависит от установки IRQ на плате Sound Blaster:</p>
<p>IRQ | Прерывание</p>
<p>-----+------------</p>
<p>2 | 0Ah</p>
<p>3 | 0Bh</p>
<p>5 | 0Dh</p>
<p>7 | 0Fh</p>
<p>Для обслуживания прерывания необходимо выполнить:</p>
<p>1) подтвердите прием прерывания от DSP прочитав порт (2xEh) один раз для</p>
<p>8-битного звука, или порт 2xF для 16-битного звука.</p>
<p>2) Вывод следующего буфера, если есть.</p>
<p>3) Выведите значение 20h ( EOI ) в порт контроллера прерывания 20h,</p>
<p>а если IRQ8-15(прерывания 70h-77h), то записать 20h в A0h.</p>
<p>Установка прерывания :</p>
<p>DMA_complete = 0;</p>
<p>disable();</p>
<p>OldIRQ = getvect(0x08 + SbIRQ);</p>
<p>setvect(0x08 + SbIRQ,SBHandler);</p>
<p>enable();</p>
<p>Обработчик прерывания :</p>
<p>static void far interrupt SBHandler( void )</p>
<p>{</p>
<p>enable();</p>
<p>DMA_complete = 1;</p>
<p>// подтведить</p>
<p>inportb(baseAddrSB+0xE);</p>
<p>outportb(0x20,0x20);</p>
<p>}</p>
<p>Инициализация обработчика :</p>
<p>DMA_complete = 0;</p>
<p>im = inportb(0x21);</p>
<p>tm = ~(1 &lt;&lt; SbIRQ);</p>
<p>outportb(0x21,im &amp; tm);</p>
<p>enable();</p>
<p>Сброс обработчика :</p>
<p>disable();</p>
<p>setvect(0x08 + SbIRQ,OldIRQ);</p>
<p>i = inportb(0x21);</p>
<p>outportb(0x21, i | (1 &lt;&lt; SbIRQ));</p>
<p>enable();</p>
<p>Воспроизведение файла выборки:</p>
<p>f = fopen(argv[1],"rb");</p>
<p>raw = ( char far * ) farmalloc(32000L);</p>
<p>if ( f == 0 || raw==0 )</p>
<p>{</p>
<p>printf("Не могу открыть файл выборки - %s\n",argv[1]);</p>
<p>printf("Нет памяти\n",argv[1]);</p>
<p>ResetSB();</p>
<p>return;</p>
<p>}</p>
<p>printf("Воспроизведение выборки ...\n");</p>
<p>WriteSB(ON_SOUND_SB);</p>
<p>RateSB(22222);</p>
<p>len=fread(raw,1,32000,f);</p>
<p>while ( 1 )</p>
<p>{</p>
<p>if ( len==0 ) break;</p>
<p>PlaySB(raw,len);</p>
<p>len=fread(raw,1,32000,f);</p>
<p>while ( StatePlaySB()==0 )</p>
<p>if ( kbhit() ) { getch(); goto Fin; }</p>
<p>}</p>
<p>Fin:</p>
<p>if ( f!=0 ) fclose(f);</p>
<p>if ( raw!=0 ) farfree(raw);</p>
<p>ResetSB();</p>
<p>+-------------+-------------------------------------------------------------</p>
<p>| Стерео звук |</p>
<p>+=============+</p>
<p>При воспроизведении стерео звуков необходимо посылать 2 байта DSP, первый</p>
<p>для левого канала, второй для правого. Необходимо так же указать SB,</p>
<p>что вы воспроизводите стерео звук, через регистры миксера.</p>
<p>+----------------------+----------------------------------------------------</p>
<p>| Миксер Sound Blaster |</p>
<p>+======================+</p>
<p>Ниже приведена информация для SbPro.</p>
<p>Порт 2x4h - индексный порт миксера, 2x5h - порт данных (чтения/записи).</p>
<p>void pascal WriteMixerSB</p>
<p>( char index, char val )</p>
<p>{</p>
<p>outportb(baseAddrSB+4,index);</p>
<p>outportb(baseAddrSB+5,val);</p>
<p>}</p>
<p>char pascal ReadMixerSB</p>
<p>( char index )</p>
<p>{</p>
<p>outportb(baseAddrSB+4,index);</p>
<p>return inportb(baseAddrSB+5);</p>
<p>}</p>
<p>Регистр Сброса Данных используется для инициализации миксера. Установите</p>
<p>этот регистр в 0 перед изменением любого из других регистров миксера.</p>
<p>void pascal ResetMixerSB</p>
<p>( void )</p>
<p>{</p>
<p>WriteMixerSB(0,0); // RESET</p>
<p>}</p>
<p>Регистр записи определяет источник звука и тип фильтра.</p>
<p>Индекс = 0Ch</p>
<p>7 6 5 4 3 2 1 0</p>
<p>--------+-------+---+---+----</p>
<p>+---+---+ +-+-+</p>
<p>+---+ |</p>
<p>| |</p>
<p>В Фильтре ADC Источник</p>
<p>000 - Низкие 00 - Микрофон 1</p>
<p>001 - Высокие 01 - CD</p>
<p>010 - Нет Фильтра 10 - Микрофон 2</p>
<p>11 - Линейный вход</p>
<p>#define SOURCE_MIC1 0</p>
<p>#define SOURCE_CD 1</p>
<p>#define SOURCE_MIC2 2</p>
<p>#define SOURCE_LINE 3</p>
<p>void pascal InputMixerSB</p>
<p>( char sou, char filtr )</p>
<p>{</p>
<p>char val;</p>
<p>val=(sou&lt;&lt;1)&amp;0x6;</p>
<p>val|=(filtr&lt;&lt;3)&amp;0x38;</p>
<p>WriteMixerSB(0xC,val);</p>
<p>}</p>
<p>Регистр воспроизведения служит для установки фильтра и стерео звука.</p>
<p>Индекс = 0Eh</p>
<p>7 6 5 4 3 2 1 0</p>
<p>--------+---------------+----</p>
<p>| |</p>
<p>| |</p>
<p>0 - Использовать фильтр 0 - моно</p>
<p>1 - Без фильтра 1 - Stereo</p>
<p>#define MONO 0</p>
<p>#define STEREO 1</p>
<p>#define USE_FILTER 0</p>
<p>#define BYPASS_FILTER 1</p>
<p>void pascal OutputMixerSB</p>
<p>( char st, char filtr )</p>
<p>{</p>
<p>char val;</p>
<p>val=(st==1)?2:0;</p>
<p>val|=(filtr==1)?0x20:0;</p>
<p>WriteMixerSB(0xE,val);</p>
<p>}</p>
<p>Регистр общей громкости:</p>
<p>Индекс = 22h</p>
<p>7 6 5 4 3 2 1 0</p>
<p>+-----------+---+-----------+</p>
<p>+-----+-----+ +-----+-----+</p>
<p>| |</p>
<p>Громкость Громкость</p>
<p>Лево Право</p>
<p>void pascal MasterVolumeSB</p>
<p>( char left, char right )</p>
<p>{</p>
<p>char val;</p>
<p>val=right&amp;0xf;</p>
<p>val|=(left&lt;&lt;4)&amp;0xf0;</p>
<p>WriteMixerSB(0x22,val);</p>
<p>}</p>
<p>Регистр громкости DSP:</p>
<p>Индекс = 04h</p>
<p>7 6 5 4 3 2 1 0</p>
<p>+-----------+---+-----------+</p>
<p>+-----+-----+ +-----+-----+</p>
<p>| |</p>
<p>Громкость Громкость</p>
<p>Лево Право</p>
<p>void pascal VoiceVolumeSB</p>
<p>( char left, char right )</p>
<p>{</p>
<p>char val;</p>
<p>val=right&amp;0xf;</p>
<p>val|=(left&lt;&lt;4)&amp;0xf0;</p>
<p>WriteMixerSB(0x04,val);</p>
<p>}</p>
<p>Регистр громкости FM синтезатора:</p>
<p>Индекс= 26h</p>
<p>7 6 5 4 3 2 1 0</p>
<p>+-----------+---+-----------+</p>
<p>+-----+-----+ +-----+-----+</p>
<p>| |</p>
<p>Громкость Громкость</p>
<p>Лево Право</p>
<p>void pascal FMVolumeSB</p>
<p>( char left, char right )</p>
<p>{</p>
<p>char val;</p>
<p>val=right&amp;0xf;</p>
<p>val|=(left&lt;&lt;4)&amp;0xf0;</p>
<p>WriteMixerSB(0x26,val);</p>
<p>}</p>
<p>Регистр громкости CD:</p>
<p>Индекс = 28h</p>
<p>7 6 5 4 3 2 1 0</p>
<p>+-----------+---+-----------+</p>
<p>+-----+-----+ +-----+-----+</p>
<p>| |</p>
<p>Громкость Громкость</p>
<p>Лево Право</p>
<p>void pascal CDVolumeSB</p>
<p>( char left, char right )</p>
<p>{</p>
<p>char val;</p>
<p>val=right&amp;0xf;</p>
<p>val|=(left&lt;&lt;4)&amp;0xf0;</p>
<p>WriteMixerSB(0x28,val);</p>
<p>}</p>
<p>Регистр громкости линейного входа:</p>
<p>Индекс = 2Eh</p>
<p>7 6 5 4 3 2 1 0</p>
<p>+-----------+---+-----------+</p>
<p>+-----+-----+ +-----+-----+</p>
<p>| |</p>
<p>Громкость Громкость</p>
<p>Лево Право</p>
<p>void pascal LineVolumeSB</p>
<p>( char left, char right )</p>
<p>{</p>
<p>char val;</p>
<p>val=right&amp;0xf;</p>
<p>val|=(left&lt;&lt;4)&amp;0xf0;</p>
<p>WriteMixerSB(0x2E,val);</p>
<p>}</p>
<p>Регистр громкости микрофона:</p>
<p>Индекс = 0Ah</p>
<p>7 6 5 4 3 2 1 0</p>
<p>--------------------+-------+</p>
<p>+---+---+</p>
<p>|</p>
<p>Громкость микрофона.</p>
<p>void pascal MicVolumeSB</p>
<p>( char vol )</p>
<p>{</p>
<p>char val;</p>
<p>val=vol&amp;0x7;</p>
<p>WriteMixerSB(0xA,val);</p>
<p>}</p>
<p>+------------+--------------------------------------------------------------</p>
<p>| Примечание:|</p>
<p>+============+</p>
<p>Данный документ составлен Анисимовым С.Ю. 08/1995. г. К-Чепецк,</p>
<p>Кировской обл. Россия. v1.( и последняя )</p>
<p>Данными для составления этого документа послужила информация</p>
<p>из различных источников. Поэтому автор не несет ответственность</p>
<p>за неверную информацию, и за повреждения техники и тел при</p>
<p>использовании этого документа.</p>
<p>С наилучшими пожеланиями, для всех любителей программировать Sound Blaster !</p>
<p>Vale ! </p>
<p>Взято с Vingrad.ru <a href="http://forum.vingrad.ru" target="_blank">http://forum.vingrad.ru</a></p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
