<!DOCTYPE html>
<html>
<head>
  <title>Справочник по MySQL</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Справочник по MySQL</h1>
<div id="date">01.01.2010</div>

<p>Справочник по SQL</p>
<p>MySQL SQL</p>
<p>ALTER/MODIFY</p>
<pre name="code" class="sql">
ALTER [IGNORE] TABLE table ADD [COLUMN] create_clause
ALTER [IGNORE] TABLE table ADD INDEX [name] (column, . . .)
ALTER [IGNORE] TABLE table ADD UNIQUE [name] (column, . . .)
ALTER [IGNORE] TABLE table ALTER [COLUMN] column SET DEFAULT value
ALTER [IGNORE] TABLE table ALTER [COLUMN] column DROP DEFAULT
ALTER [IGNORE] TABLE table CHANGE [COLUMN] column create..clause
ALTER [IGNORE] TABLE table DROP [COLUMN] column
ALTER [IGNORE] TABLE table DROP FOREIGN KEY key
ALTER [IGNORE] TABLE table DROP INDEX key
ALTER [IGNORE] TABLE table DROP PRIMARY KEY
ALTER [IGNORE] TABLE table MODIFY [COLUMN] create_clause
ALTER [IGNORE] TABLE table RENAME [AS] new_name
</pre>
<p>Оператор ALTER охватывает широкий набор действий, которые изменяют структуру таблицы. Этот оператор используется для добавления, изменения или удаления столбцов существующей таблицы, а также для удаления индексов. Несколько операторов ALTER могут быть объединены в одно предложение с помощью запятых:</p>
<pre name="code" class="sql">ALTER TABLE mytable DROP myoldcolumn, ADD mynewcolumn INT
</pre>
<p>Для модификации таблицы MySQL создает копию таблицы и изменяет ее, выполняя все модифицирующие запросы. Когда все изменения сделаны, старая таблица удаляется, а ее место занимает новая таблица. В этой точке выполняются все поставленные в очередь запросы. В целях безопасности, если какой-либо из запросов создает дублирующие ключи, которые должны быть уникальными, предложение ALTER откатывается и отменяется. Если в предложении присутствует ключевое слово IGNORE, дублированные уникальные ключи игнорируются, и запрос ALTER исполняется как обычно. Имейте в виду, что использование IGNORE для активной таблицы с уникальными ключами может привести к искажению и порче таблицы.</p>
<p>Как указывалось выше, есть несколько разных, зачастую противоположных действий, выполняемых ALTER:</p>
<pre name="code" class="sql">
ADD [COLUMN] create,clause
</pre>
<p>Добавляет новый столбец в таблицу. Выражение create_clause имеет тот же вид, что и используемое в операторе CREATE (см. ниже). Таблица должна существовать и не иметь столбца с тем же именем, что у добавляемого столбца. (Ключевое слово COLUMN необязательно и не имеет эффекта.)</p>
<pre name="code" class="sql">
ADD INDEX [ name] (column , ...)
</pre>

<p>Создает индекс из указанных столбцов. В индексе могут быть скомбинированы до 15 столбцов. Указывать имя для индекса необязательно. Если не задано имя, индекс будет назван по имени первого столбца в списке (с числовым суффиксом _2, _3 и т. д., если это необходимо для уникальности).</p>
<pre name="code" class="sql">
ADD UNIQUE [name] (column, ...)
</pre>

<p>Идентично ADD INDEX за исключением того, что индексированные поля гарантированно уникальны. То есть, если пользователь попытается добавить значение, уже существующее в уникальном индексе, будет выдано сообщение об ошибке.</p>
<pre name="code" class="sql">
ALTER [COLUMN] column SET DEFAULT value
ALTER [COLUMN] column DROP DEFAULT
</pre>

<p>Создает, изменяет или удаляет значение по умолчанию для столбца. Если используется фраза SET DEFAULT , значение по умолчанию для указанного столбца изменяется на новое (даже если до этого не существовало значений по умолчанию). При использовании DROP DEFAULT, существующее значение по умолчанию удаляется. При этом любые существующие записи, созданные с помощью этого значения, остаются неизмененными. (Ключевое слово COLUMN необязательно и не имеет эффекта.)</p>
<pre name="code" class="sql">
CHANGE [COLUMN] new_column_name create_clause 
MODIFY [COLUMN] create__clause
</pre>

<p>Изменяет определение столбца. Предложение используется для изменения типа данных столбца с минимально возможным воздействием на данные. Выражение create_clause то же, что и в операторе CREATE. Оно включает имя столбца и поэтому, используя это предложение, вы изменяете имя столбца. (Например, ALTER TABLE mytable CHANGE name newname CHAR(30) .) Предложение MODIFY аналогично CHANGE, но новый столбец имеет то же имя, что и старый. Ключевое слово COLUMN необязательно и не имеет эффекта. Следующие преобразования типов данных выполняются автоматически:</p>
<p>Целых чисел к числам с плавающей запятой, и наоборот (например, BIGINT к DOUBLE).</p>
<p>Меньших числовых значений к большим (например, INTEGER к BIGINT).</p>
<p>Больших числовых значений к меньшим (например, DOUBLE к FLOAT). Если значение выходит за пределы нового типа, используется максимально возможное значение нового типа данных (или наименьшее из отрицательных).</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Числовых к текстовым (например, SMALLINT к CHAR(5)).</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Текстовых к числовым (например, VARCHAR к MEDIUMINT). Текст преобразуется либо в целое число, либо в число с плавающей запятой. (Что более подходит для нового типа.)</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Меньших символьных типов к большим (например, BLOB к LONG-TEXT).</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Больших символьных типов к меньшим (например, TEXT к VARCHAR (255) ). Если значение больше, чем позволяет новый тип данных, текст усекается для соответствия этому типу.</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Даже для преобразований, которые здесь не упомянуты (например, TIMESTAMP к YEAR), MySQL попытается сделать все возможное, чтобы совершить разумное преобразование. При использовании CHANGE преобразование будет выполнено в любом случае, ни при каких обстоятельствах MySQL не сдастся и не выдаст сообщения об ошибке. Помня об этом, вы должны (1) сделать резервную копию данных перед преобразованием и (2) немедленно проверить новые значения на &#171;разумность&#187;.</td></tr></table></div><pre name="code" class="sql">DROP [COLUMN] column
</pre>

<p>Удаляет столбец из таблицы. Это предложение удалит из таблицы столбец и все его содержимое. Единственный способ восстановить данные, уничтоженные таким способом, - использовать резервную копию. Все ссылки в индексах на этот столбец будут удалены. Все индексы, где этот столбец был единственным, будут также уничтожены. (Ключевое слово COLUMN необязательно и не имеет эффекта.)</p>
<pre name="code" class="sql">
DROP INDEX key
</pre>

<p>Удаляет индекс из таблицы. Это предложение полностью сотрет индеке из таблицы. Предложение не затронет данные самой таблицы, только данные индекса. Поэтому индекс, удаленный таким способом, может быть воссоздан с помощью оператора ALTER TABLE ... ADD INDEX.</p>
<pre name="code" class="sql">DROP PRIMARY KEY
</pre>

<p>Аналог DROP INDEX . Ищет специальный индекс, называемый первичным ключом (Primary Key). Если в таблице первичный ключ не найден, будет удален первый уникальный индекс.</p>
<pre name="code" class="sql">RENAME [AS] new_table
</pre>

<p>Изменяет имя таблицы. Эта операция не влияет на данные или индексы внутри таблицы. Если предложение применяется одно, без других ALTER TABLE операторов, MySQL не создает временную таблицу, как в случае других операторов, а просто выполняет быстрое переименование табличных файлов на уровне Unix.</p>
<p>Операция FOREIGN KEY (внешний ключ) в настоящий момент не поддерживается в MySQL. Хотя синтаксис команды описан, никаких действий с внешним ключом произвести не удастся.</p>
<p>Чтобы применить любое из действий ALTER TABLE , у вас должны быть права SELECT, INSERT, DELETE, UPDATE, CREATE и DROP на изменяемую табли-ЦУ.</p>
<p>Примеры</p>
<p>Добавить поле 'address2' к таблице 'people' и. задать ему тип данных 'VARCHAR' с максимальной длиной 200 символов.</p>
<pre name="code" class="sql">ALTER TABLE people ADD COLUMN address2 VARCHAR(100)
</pre>
<p>Добавить два новых индекса к таблице 'hr', обычный индекс для поля'salary' и уникальный индекс для поля 'id'. Также продолжить выполнение, если найдены дублируемые значения при создании индекса 'id_idx' (очень опасно!).</p>
<pre name="code" class="sql">
ALTER TABLE hr ADD INDEX salary_idx ( salary )
ALTER IGNORE TABLE hr ADD UNIQUE id_idx ( id )
</pre>

<p>Изменить значение по умолчанию для поля 'price' в таблице'sprockets' на $19.95.</p>
<pre name="code" class="sql">
ALTER TABLE sprockets ALTER price SET DEFAULT '$19.95'
</pre>

<p>Удалить значение по умолчанию для поля 'middle_name' в таблице 'names'.</p>
<pre name="code" class="sql">
ALTER TABLE names ALTER middle_name DROP DEFAULT
</pre>

<p>Изменить тип данных для поля 'profits' с начального значения (которым, возможно, было INTEGER) на BIGINT.</p>
<pre name="code" class="sql">
ALTER TABLE finanaces CHANGE COLUMN profits profits BIGINT
</pre>

<p>Удалить поле 'secret_stuff' из таблицы 'not_private_anymore' </p>
<pre name="code" class="sql">
ALTER TABLE not_private_anymore DROP secret_stuff 
</pre>
<p>удалить индекс с именем 'id_index' также как и первичный ключ из таблицы 'cars'.</p>
<pre name="code" class="sql">ALTER TABLE cars DROP INDEX id_index, DROP PRIMARY KEY 
</pre>

<p>Переименовать таблицу 'rates_current' на 'rates_1997'</p>
<pre name="code" class="sql">
ALTER TABLE rates_current RENAME AS rates_1997
</pre>

<p>CREATE</p>
<pre name="code" class="sql">
CREATE DATABASE dbname
CREATE TABLE name ( field_name field__type, ... )
CREATE INDEX name ON table ( column, ...)
CREATE FUNCTION name RETURNS values SONAME library
</pre>
<p>Создает новые элементы базы данных (или полностью новую базу). Предложение используется для создания баз данных, таблиц и функций, определяемых пользователем (UDFs).</p>
<p>Команда CREATE INDEX поддерживается для совместимости с другими реализациями SQL. В старых версиях SQL эта команда ничего не выполняла. В версии 3.22 это предложение эквивалентно ALTER TABLE ADD INDEX. Чтобы выполнить CREATE INDEX , вы должны иметь право INDEX для этой таблицы.</p>
<p>CREATE DATABASE создает полностью пустую базу данных. Это эквивалент утилите mysqladmin . Так же как и при запуске mysqladmin, вы должны иметь права администратора MySQL (обычно root или mysql) для выполнения этой команды.</p>
<p>CREATE FUNCTION позволяет предложениям MySQL получать доступ к прекомпилированным выполняемым функциям. Эти функции могут выполнять практически любые операции, так как они проектируются пользователем. Возвращаемое значение может быть STRING для символьных данных; REAL для чисел с плавающей запятой или INTEGER для целых чисел. MySQL преобразует возвращаемое значение С-функций к указанному типу. Библиотека, содержащая функцию, должна быть стандартной разделяемой библиотекой, которую MySQL может динамически присоединить к серверу.</p>
<p>CREATE TABLE определяет структуру таблицы в базе данных. Этим оператором создаются все таблицы MySQL. Предложение состоит из имени таблицы, за которым идет любое количество определений полей. Синтаксис определения полей включает в себя имя поля, за ним его тип, за ним любой модификатор (например: name char(30) not null ). MySQL поддерживает следующие типы данных, представленные в таблице 15-1.</p>
<p>Таблица 15-1. Типы данных<br>
<p>&nbsp;</p>
<table>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>Тип</p>
</td>
<td><p>Размер (в байтах)</p>
</td>
<td><p>Комментарии</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>TINYIN'I ( length)/ INT1( length)</p>
</td>
<td><p>1</p>
</td>
<td><p>Целое с диапазоном значений от 0 до 255 без знака и от -128 до 127 со знаком.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>SMALLINT ( length)/</p>
</td>
<td><p>2</p>
</td>
<td><p>Целое с диапазоном значений от</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>INT2( length)</p>
</td>
<td>
</td>
<td><p>0 до 65535 без знака и от -32768 до 32767 со знаком.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>MEDIUMINT ( length)/</p>
</td>
<td><p>3</p>
</td>
<td><p>Целое с диапазоном значений от</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>INT3( length)/</p>
</td>
<td>
</td>
<td><p>0 до 16777215 без знака и от</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>MIDDLEINT ( length)</p>
</td>
<td>
</td>
<td><p>-8388608 до 8388607 со знаком.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>INT (length)/</p>
</td>
<td><p>4</p>
</td>
<td><p>Целое с диапазоном значений от</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>INTEGER ( length)/</p>
</td>
<td>
</td>
<td><p>0 до 4294967295 без знака и от</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>INT4( length)</p>
</td>
<td>
</td>
<td><p>-2147483648 до 8388607 со знаком.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>BIGINT (length)/</p>
</td>
<td><p>8</p>
</td>
<td><p>Целое с диапазоном значений от</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>INT8( length)</p>
</td>
<td>
</td>
<td><p>0 до 184467447370955165 без зна-</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td><p>ка и от -9223372036854775808</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td><p>до 9223372036854775807 со зна-</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td><p>ком.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>FLOAT/FLOAT (4)/ FLOAT</p>
</td>
<td><p>4</p>
</td>
<td><p>Число с плавающей запятой</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>(length, decimal )/ FLO-</p>
</td>
<td>
</td>
<td><p>с максимальным значением</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>AT4( length, decimal )</p>
</td>
<td>
</td>
<td><p>+/-3.402823466Е38 и минималь-</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td><p>ным (не нулевым) значением</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td><p>+/-1.175494351Е-38.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>DOUBLEPRECISION</p>
</td>
<td><p>8</p>
</td>
<td><p>Число с плавающей запятой</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>(length, decimal )/</p>
</td>
<td>
</td>
<td><p>с максимальным значением</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>DOUBLE ( length, decimal )/</p>
</td>
<td>
</td>
<td><p>+/-1.7976931348623157Е308 и</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>REAL (length, decimal )/</p>
</td>
<td>
</td>
<td><p>минимальным (не нулевым) значе-</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>FLOAT8( length, decimal )/</p>
</td>
<td>
</td>
<td><p>нием +/-2.2250738585072014Е-308.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>FLOAT (8)</p>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>DECIMAL ( length, decimal )/</p>
</td>
<td><p>length</p>
</td>
<td><p>Число с плавающей запятой с ди-</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>NUMERIC ( length, decimal )</p>
</td>
<td>
</td>
<td><p>апазоном значений как у типа DOUBLE, которое хранится как поле CHAR . DECIMAL и NUMERIC всегда расцениваются как поля CHAR , которые содержат цифровое значение.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>TIMESTAMP (length)</p>
</td>
<td><p>4</p>
</td>
<td><p>Значение timestamp, которое обновляется каждый раз, когда изменяется запись. Также можно приписать значение вручную. При приписывании значения NULL в поле запишется текущее время. Поле длины (необязательное) определяет внешний формат записи. Длина 14 (значение по умолчанию) выводит строку типа ' YYYYMMDDHHMMSS' , 12 flacT'YYMMDDHHMMSS',' 8- 'YYYYMMDD', и 6 выдаст 'YYMMDD'.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</table>

<table>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>DATE</p>
</td>
<td><p>3</p>
</td>
<td><p>Значение даты, которое хранит год, месяц и день. Значения всегда выводятся в формате 'YYYY-MM-DD', но могут быть введены в любом из следующих форматов: 'YY-MM-DD', 'YYYY-MM-DD', 'YYMMDD' или 'YYYYMMDDHHMMSS' (часть, хранящая время, игнорируется).</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>TIME</p>
</td>
<td><p>3</p>
</td>
<td><p>Значение времени, хранящее часы, минуты и секунды. Значения всегда выводятся в формате 'НН: MM: SS', но могут быть введены в любом из следующих форматов: 'НН: MM: SS', 'HHMMSS', 'ННММ' (секунды равны '00'), или 'НН' (минуты и секунды обнуляются).</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>DATETIME</p>
</td>
<td><p>8</p>
</td>
<td><p>Сохраняет и дату и время. Значения вводятся и выводятся в формате 'YYYY-MM-DD HH: MM: SS'.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>YEAR</p>
</td>
<td><p>1</p>
</td>
<td><p>Значение, сохраняющее год. Может быть введено либо в формате 'YYYY', либо 'YY', будет выведено либо как двухзначный, либо как четырехзначный год, в зависимости от формата ввода. Двухзначный год может находиться в диапазоне между 1970 и 2069 включительно. Этот тип данных в настоящее время поддерживает года с 1901 по 2155.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>CHAR (length) /ШЬЮ (length-)</p>
</td>
<td><p>length</p>
</td>
<td><p>Строка фиксированной длины. Любой текст меньшей длины будет дополнен пробелами в конце строки. Все конечные пробелы, вставленные либо MySQL, либо пользователем, удаляются при выводе значения. MySQL по умолчанию считает текст не чувствительным к регистру (см. модификатор BINARY ниже). Тип BINARY эквивалентен CHAR с модификатором BINARY .</p>
</td>
<td></td>
</tr>
</table>

<table>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>CHAR (length) VARYING/ VARCHAR (length)/ VARBINARY ( length)</p>
</td>
<td><p>length</p>
</td>
<td><p>Текстовая строка переменной длины (нечувствительная к регистру) с установленной максимальной длиной. Максимальная длина должна лежать в диапазоне между 1 и 255 символами. Все концевые пробелы удаляются при сохранении данных этого типа. Тип VARBINARY эквивалентен VARCHAR с BINARY модификатором.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>TINYTEXT</p>
</td>
<td><p>length+1</p>
</td>
<td><p>Текстовое поле (нечувствительно к регистру) с максимальной длиной в 255 символов.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>TINYBLOB</p>
</td>
<td><p>length+1</p>
</td>
<td><p>Двоичное поле (чувствительно к регистру) с максимальной длиной в 255 символов. Двоичные данные чувствительны к регистру.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>TEXT/LONG VARCHAR</p>
</td>
<td><p>length+2</p>
</td>
<td><p>Текстовое поле с максимальной длиной в 64 Кбайт текста.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>BLOB/LONG VARBINARY</p>
</td>
<td><p>length+2</p>
</td>
<td><p>Двоичное поле с максимальным размером в 64 Кбайт данных.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>MEDIUMTEXT</p>
</td>
<td><p>length+3</p>
</td>
<td><p>Текстовое поле с максимальной длиной в 16 Мбайт текста.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>MEDIUMBLOB</p>
</td>
<td><p>length+3</p>
</td>
<td><p>Двоичное поле с максимальным размером в 16 Мбайт данных.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>LONGTEXT</p>
</td>
<td><p>length+4</p>
</td>
<td><p>Текстовое поле с максимальной длиной в 4 Гбайт текста.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>LONGBLOB</p>
</td>
<td><p>length+4</p>
</td>
<td><p>Двоичное поле с максимальным размером в 4 Гбайт данных.</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td><p>ENUM</p>
</td>
<td><p>1,2</p>
</td>
<td><p>Поле, которое может содержать одно значение из предварительно заданного набора (например ENUM ("apples", "oranges", "bananas")). Данные могут быть введены как одно из текстовых значений набора либо как число, соответствующее одному из элементов набора (номер первого элемента 1). В поле всегда может быть внесено значение NULL. Набор (коллекция) может содержать до 65535 разных элементов. Если в наборе меньше 256 элементов, поле займет только один байт (иначе его размер равен двум байтам).</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td></td>
</tr>
</table>

<table>
<tr>
<td>
</td>
<td><p>SET</p>
</td>
<td><p>1&#8212;8</p>
</td>
<td><p>Поле может содержать любое количество предварительно заданных значений (например SET ("rock," "pop," "country," "western")). Данные могут быть заданы как список разделенных запятыми значений либо как двоичное битовое представление значений (например 12, т. е. 1100 в двоичном виде, относится к "country, western" в предыдущем примере). В одном наборе может быть до 64 элементов.</p>
</td>
<td></td>
</tr>
</table>
<p>В дополнение к основным типам могут использоваться некоторые модификаторы.</p>
<p>decimal</p>
<p>Максимальное количество цифр справа от запятой в числе с плавающей запятой. Любое значение с более длинной дробной частью будет округлено. Например, для поля price FLOAT(5,2) значение 4.34 будет показано как 4.34, значение 234.27 будет показано как 234.3 (для соответствия общей максимальной длине), значение 3.331 будет выглядеть как 3.33 (для соответствия максимальной длине дробной части).</p>
<p>length</p>
<p>Количество символов для числовых значений, показываемое пользователю. Включает десятичные запятые, знаки и индикаторы экспонент. Например, поле peanuts INT(4) имеет допустимый диапазон от -999 до 9999. MySQL сохранит значение, выходящие за пределы заданного диапазона, пока оно не выйдет за пределы максимального размера для своего типа. Если вы сохраните значение вне заданного диапазона, MySQL выдаст предупреждение, но будет функционировать нормально.</p>
<p>При использовании с типом TIMESTAMP модификатор length определяет формат, используемый для timestamp.</p>
<p>При использовании с символьными (текстовыми) типами length определяет количество символов. Для символьных типов с фиксированной длиной length это точное число символов, используемое для хранения данных. Для текстовых типов с переменной длиной length это максимально возможная длина строки.</p>
<p>Атрибут length является необязательным для всех типов, кроме DECIMAL/NUMERIC , CHAR и VARCHAR .</p>
<p><img src="pic/embim1728.png" width="36" height="35" vspace="1" hspace="1" border="0" alt=""></p>
<p>Поскольку тип DECIMAL/NUMERIC хранится как символьная строка, он ограничен максимальной длиной точно так же, как и поле CHAR. Поэтому ввод чисел больше указанного диапазона вызовет такую же ошибку, что и при вводе слишком длинной строки в поле CHAR.</p>
<p>precision</p>
<p>Этот атрибут доступен для типа FLOAT в целях совместимости с системой ODBC. Значение этого атрибута, равное 4, указывает на обычное вещественное число (то же, что и FLOAT без атрибута точности), а значение 8 определяет число с плавающей запятой двойной точности (то же, что поле DOUBLE).</p>
<p>AUTO_INCREMENT</p>
<p>Атрибут позволяет автоматически обновлять числовое поле. Это удобно для создания уникальных идентификаторов для записей в таблице. Данные могут быть записаны и прочитаны из такого поля, как из обычного, но при вводе значения NULL или 0 существующее значение автоматически увеличивается на единицу. Текущее значение поля AUTO_INCREMENT может быть получено с помощью функции LAST_INSERT_ID (см. SELECT ниже).</p>
<p>BINARY</p>
<p>Атрибут используется с типами CHAR и VARCHAR- для указания на двоичные данные в текстовой строке. Единственным эффектом этого атрибута будет чувствительность к регистру при сортировке данных. По умолчанию MySQL игнорирует регистр при сортировке текста.</p>
<p>DEFAULT value</p>
<p>Атрибут приписывает полю значение по умолчанию. Это значение будет присвоено полю в случае, если во вводимой в таблицу записи это поле пустое. Если значение по умолчанию не определено и нет ограничения NOT NULL , то будет записано значение NULL. В случае NOT NULL MySQL запишет значение на основе типа поля.</p>
<p>NOT NULL</p>
<p>Этот атрибут гарантирует, что каждая запись в столбце будет иметь какое-либо, отличное от NULL, значение. Попытка вставить в такое поле значение NULL вызовет ошибку.</p>
<p>NULL</p>
<p>Атрибут указывает на допустимость значения NULL. Это атрибут по умолчанию в случае, если никакой атрибут не указан. Поля, входящие в состав индекса, не могут иметь атрибут NULL. (Он будет проигнорирован, даже если он указан.)</p>
<p>PRIMARY KEY</p>
<p>Атрибут автоматически делает поле первичным ключом таблицы. Таблица может иметь только один первичный ключ (см. ниже). Любое поле, являющееся первичным ключом, должно иметь атрибут NOT NULL.</p>
<pre name="code" class="sql">
REFERENCES table [(column, . . . )] [MATCH FULL | MATCH PARTIAL] [ON 
DELETE option] [ON UPDATE option]
</pre>

<p>Атрибут в настоящее время не имеет эффекта. MySQL понимает полный синтаксис команды, но не обрабатывает ее. Этот модификатор поля поддерживается для облегчения импорта SQL из разных источников. Возможно также, что следующая версия MySQL будет полностью поддерживать эту функцию.</p>
<p>UNSIGNED</p>
<p>Этот атрибут используется с целочисленными типами для указания на беззнаковое целое. Максимальное значение беззнакового целого вдвое превосходит свой аналог со знаком, но не может хранить отрицательные числа. Без модификатора все типы считаются знаковыми.</p>
<p>ZEROFILL</p>
<p>Атрибут используется с целочисленными типами для добавления нулей перед числом, пока не будет достигнута длина, максимальная для типа. Например, поле counter INT(5) ZEROFILL покажет число 132 как 00132.</p>
<p>Indexes</p>
<p>MySQL поддерживает концепцию индексирования таблиц, как описано в главе 2, &#171;Проектирование баз данных&#187;. Индексы создаются посредством особых &#171;типов&#187;, включенных в определение таблицы.</p>
<pre name="code" class="sql">KEY/INDEX [name] (column, [column2, . . . ])
</pre>

<p>Создает обычный индекс для всех столбцов с именами. (KEY и INDEX в этом контексте будут синонимами.) Индексу может быть дано имя (не обязательно). Если имя не указано, будет приписано имя, основанное на имени первого столбца, и, если это необходимо для поддержания уникальности, к имени будет добавлена цифра. Если в индекс входит более одного столбца, то все столбцы слева будут объединены в подгруппы и проиндексированы. Обратите внимание на следующее определение индекса: INDEX idxl ( name, rank, serial );</p>
<p>При создании этого индекса будут проиндексированы следующие группы столбцов:</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>name, rank, serial</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>name, rank name</td></tr></table></div><p>PRIMARY KEY</p>
<p>Создает первичный ключ. Первичный ключ &#8212; это особый ключ, который может быть только один для каждой таблицы. По сути, первичный ключ- это уникальный (UNIQUE) ключ с именем &#171;PRIMARY&#187;. Несмотря на привилегированный статус, он функционирует как любой другой уникальный ключ.</p>
<pre name="code" class="sql">
UNIQUE [nаmе] (column, [column2, . , . ])
</pre>
<p>Создает особый индекс, все входящие значения которого должны быть уникальными (и соответственно они уникальны в индексированных полях). Попытка ввести существующее значение в уникальный индекс вызовет ошибку. Следующая команда создает уникальный индекс поля &#171;nicknames&#187;:</p>
<pre name="code" class="sql">
UNIQUE (nicknames);
</pre>

<p><img src="pic/embim1729.png" width="36" height="35" vspace="1" hspace="1" border="0" alt=""></p>
<p>В существующей реализации индексирования в MySQL значение NULL не допускается ни в одном из полей, входящих в индекс.</p>
<p>При индексировании текстовых полей (CHAR, VARCHAR и их синонимы) возможно индексирование только первой части всего поля. Например, следующая команда создаст индекс числового поля 'id' вместе с первыми 20 символами текстового поля 'address':</p>
<pre name="code" class="sql">
INDEX adds ( id, address(20) );
</pre>

<p>При выполнении любого поиска в поле 'address' для сравнения будут использованы только первые 20 символов до тех пор, пока не встретится более одного совпадения. Поэтому можно получить большой выигрыш в производительности, если использовать для индексирования только некоторое количество символов текстового поля, которые, по вашему мнению, дадут уникальные значения.</p>
<p>Поля, входящие в индекс, должны быть определены с атрибутом NOT NULL (см. выше). При создании индекса отдельной командой MySQL сгенерирует ошибку, если NOT NULL не указан. Однако при определении первичного ключа добавлением атрибута PRIMARY KEY к описанию таблицы, атрибут NOT NULL будет добавлен автоматически (без предупреждения), если он не указан явно.</p>
<p>В добавление к описанным выше MySQL содержит следующие специальные &#171;типы&#187;:</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>FOREIGN KEY ( name (column, [column2, . . . ])</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>CHECK</td></tr></table></div><p>Эти ключевые слова не выполняют никаких действий. Они существуют для более легкого чтения SQL-кода, экспортированного из других баз данных. Также некоторая отсутствующая пока функциональность может быть добавлена в следующие версии MySQL.</p>
<p>У вас должны быть право CREATE для базы данных, где используется предложение CREATE TABLE .</p>
<p>Примеры<br>
<p>&nbsp;</p>
<p>Создать новую пустую базу данных 'employees'</p>
<pre name="code" class="sql">CREATE DATABASE employees;
</pre>

<p>Создать простую таблицу</p>
<pre name="code" class="sql">
CREATE TABLE empjata ( id INT, name CHAR(50) );
</pre>

<p>Создать функцию make_coffee (которая хранится в библиотеке myfuncs.so и возвращает строковое значение).</p>
<pre name="code" class="sql">
CREATE FUNCTION make_coffee RETURNS string SONAME "myfuncs.so";
</pre>

<p>DELETE</p>
<pre name="code" class="sql">
DELETE FROM table [WHERE clause]
</pre>

<p>Удаляет запись из таблицы. При использовании без предложения WHERE будет полностью удалена вся таблица, а затем будет создана новая пустая таблица. С использованием WHERE будут удалены записи, отвечающие условиям выражения. Предложение DELETE возвращает пользователю количество удаленных записей.</p>
<p>Как сказано выше, при использовании без выражения WHERE, будет удалена вся таблица. Этот эффективный метод значительно быстрее, чем удаление каждой записи по отдельности. При использовании этого метода MySQL вернет пользователю значение 0, так как нет способа узнать количество удаленных записей. В существующей реализации этот метод просто удаляет все файлы, относящиеся к таблице, кроме файла с ее определением. Поэтому этот метод удобен для обнуления таблиц с серьезно поврежденными данными (которые невозможно восстановить). Вы потеряете данные, но структура таблицы будет сохранена.</p>
<p>Для использования следующего выражения у вас должно быть право DELETE для БД.</p>
<p>Примеры<br>
<p>&nbsp;</p>
<p>Удалить все данные из таблицы 'olddata1 (но не саму таблицу). </p>
<pre name="code" class="sql">
DELETE FROM olddata
</pre>

<p>Удалить все записи из таблицы 'sales', где поле 'year' равно '1995'.</p>
<pre name="code" class="sql">DELETE FROM sales WHERE year=1995
</pre>

<p>DESCRIBE </p>
<p>DESC</p>
<pre name="code" class="sql">
DESCRIBE table [column] DESC table [column]
</pre>

<p>Выдает информацию о таблице или столбце. Хотя операция работает как описано, ее функциональные возможности (и многие другие) доступны в операторе SHOW. Оператор DESC поддерживается исключительно для совместимости с Oracle SQL. Имя столбца (не обязательное) может содержать знаки подстановки SQL, в этом случае будет выдана информация о всех подходящих столбцах.</p>
<p>Пример<br>
<p>&nbsp;</p>
<p>Описать таблицу 'messy'</p>
<pre name="code" class="sql">DESCRIBE messy
</pre>
<p>Показать информацию о всех столбцах таблицы 'big1 начинающихся с 'mу_'. Помните что ' ' является также знаком подстановки и следует избегать, его буквального употребления.</p>
<pre name="code" class="sql">
DESC big my\_%
</pre>

<p>DROP</p>
<pre name="code" class="sql">
DROP DATABASE name
DROP INDEX name
DROP TABLE [IF EXISTS] name[, name2, ...]
DROP ФУНКЦИЯ name
</pre>

<p>Удаляет базу данных, таблицу, индекс или функцию из системы MySQL. .</p>
<p>DROP DATABASE</p>
<p>Удаляет всю базу и все файлы, связанные с ней. Пользователю возвращается количество удаленных файлов. Так как большинство таблиц представлено тремя файлами, обычно возвращаемое значение равно числу таблиц, умноженному на три. Эквивалент выполнению утилиты mysqladmin drop. Для выполнения команды, так же как и при запуске утилиты mysqladmin, у вас должны быть права администратора MySQL (обычно root или mysql).</p>
<p>DROP INDEX</p>
<p>Команда поддерживается для совместимости с другими реализациями SQL. В старых версиях SQL эта команда ничего не выполняет. В версии 3.22 это предложение эквивалентно ALTER TABLE . . DROP INDEX. Для выполнения DROP INDEX вы должны иметь право SELECT, INSERT, DELETE, UPDATE, CREATE и DROP для этой таблицы.</p>
<p>DROP TABLE</p>
<p>Полностью стирает таблицу. В текущей реализации MySQL просто удаляет связанные с таблицей файлы. В версии 3.22, вы можете указать IF EXISTS , чтобы MySQL не возвращала ошибку при попытке удалить несуществующую таблицу. Для выполнения этой операции необходимо право DELETE на таблицу.</p>
<p>DROP FUNCTION</p>
<p>Удалит пользовательскую процедуру из выполняемого процесса MySQL. При этом файл библиотеки, содержащий процедуру, не удаляется. Вы всегда можете добавить эту функцию снова с помощью CREATE FUNCTION . В текущей реализации DROP FUNCTION просто удаляет пользовательскую функцию из таблицы функций БД MySQL, следящей за всеми активированными функциями.</p>
<p>Для выполнения этой операции необходимо право DROP на таблицу.</p>
<p><img src="pic/embim1730.png" width="48" height="44" vspace="1" hspace="1" border="0" alt=""></p>
<p>DROP - это, возможно, самое опасное из выражений SQL. Если вы имеете право на выполнение команд DROP, вы можете полностью стереть таблицу или даже целую базу данных. Это произойдет без предупреждения или запроса на подтверждение. Единственный способ отменить DROP - восстановление базы из резервной копии. Мораль отсюда такова: (1) всегда сохраняйте резервную копию базы (backup); (2) если в чем-то не уверены, - не используйте DROP; и (3) всегда сохраняйте резервную копию базы данных.</p>
<p>Примеры<br>
<p>&nbsp;</p>
<p># Полностью стереть с лица Земли БД 'important_data'.</p>
<pre name="code" class="sql">
DROP DATABASE important_data
</pre>

<p># Удалить таблицы 'oh_no', 'help_me' и 'dont_do_it'</p>
<pre name="code" class="sql">DROP TABLE oh_no, help_me, dont_do_it
</pre>

<p>#Удалить индекс с именем 'my_index' DROP INDEX my_index</p>
<p># Удалить из работающего сервера БД функцию 'myfunc'. Она может быть </p>
<p># добавлена обратно в любой момент с помощью CREATE FUNCTION.</p>
<pre name="code" class="sql">
DROP ФУНКЦИЯ myfunc
</pre>

<p>EXPLAIN</p>
<p>EXPLAIN SELECT statement</p>
<p>Выводит информацию о структуре и порядке выполнения запроса SELECT. Это может быть полезно для определения эффективности использования ключей.</p>
<p>Пример</p>
<pre name="code" class="sql">
EXPLAIN SELECT customer.name, product.name FROM customer, product,
purchases
WHERE purchases.customer=customer.id AND purchases.product=product.id
</pre>

<p>FLUSH</p>
<p>FLUSH option[, option...]</p>
<p>Перезапускает различные внутренние процессы или сбрасывает данные на диск, в зависимости от указанного параметра. Для выполнения этой операции необходимо иметь право reload . Допустимы следующие параметры:</p>
<p>HOSTS</p>
<p>Обнуляет таблицу в кэше, хранящую информацию об именах клиентских хостов. Этот параметр следует использовать, если клиент поменял IP-адрес или есть ошибки, касающиеся установки связи с хостом.</p>
<p>LOGS</p>
<p>Закрывает все обычные файлы журналов и открывает их заново. Используется при смене номера индексного дескриптора. Если обновленному журналу не дано особое расширение, новый файл будет иметь расширение, увеличенное на единицу.</p>
<p>PRIVILEGES</p>
<p>Перезагружает все внутренние таблицы разрешений MySQL. Это делается для вступления в силу любых изменений, сделанных в этих таблицах.</p>
<p>STATUS</p>
<p>Обнуляет все переменные, которые следят за состоянием сервера.</p>
<p>TABLES</p>
<p>Закрывает все открытые таблицы и сбрасывает все кэшированные данные на диск.</p>
<p>GRANT</p>
<pre name="code" class="sql">
GRANT privilege [ (column, ...) ] [, privilege [( column, ...) ] ...]
ON {table} TO user [IDENTIFIED BY 'password']
[, user [IDENTIFIED BY 'password'] ...] [WITH GRANT OPTION]
</pre>

<p>До версии MySQL 3.22.11 оператор GRANT распознавался, но не выполнялся. В текущих версиях функциональность присутствует. Этот оператор дает пользователю (или пользователям) права доступа. Возможно предоставление прав доступа на базу данных, таблицу или на отдельный столбец. Параметр table может быть указан как имя таблицы в текущей базе; как '*', и тогда будут предоставлены права на все таблицы текущей базы; как '*. *' - права на все таблицы во всех имеющихся базах; или как 'database. *', что будет иметь эффект для всех таблиц указанной базы данных.</p>
<p>В настоящий момент поддерживаются следующие права:</p>
<p>ALL PRIVILEDGES/ALL </p>
<p>Все права доступа.</p>
<p>ALTER</p>
<p>Изменение структуры таблиц. </p>
<p>CREATE</p>
<p>Создание новых таблиц. </p>
<p>DELETE</p>
<p>Удаление записей из таблиц.</p>
<p>DROP</p>
<p>Удаление таблиц целиком.</p>
<p>FILE</p>
<p>Создание и удаление целых БД, а также управление файлами журналов.</p>
<p>INDEX</p>
<p>Создание и удаление индексов в таблицах. </p>
<p>INSERT</p>
<p>Ввод данных в таблицы.</p>
<p>PROCESS</p>
<p>Завершение потоков. </p>
<p>REFERENCES (Справочник)</p>
<p>Пока не реализовано. </p>
<p>RELOAD</p>
<p>Обновление различных внутренних таблиц (см. оператор FLUSH). </p>
<p>SELECT</p>
<p>Чтение данных из таблицы.</p>
<p>SHUTDOWN</p>
<p>Выключение (Shut down) сервера базы данных.</p>
<p>UPDATE</p>
<p>Модификация записей внутри таблиц.</p>
<p>USAGE</p>
<p>Нет никаких прав.</p>
<p>Переменная user имеет вид user@hostname (пользователь@имя хоста). И user, и hostname могут включать в себя знаки подстановки SQL. При их использовании должно быть заключено в кавычки либо полностью имя, либо только часть с подстановочными знаками (например, joe@"%. com" и &#171;joe@%.com&#187; одинаково правильны). Использование user без hostname равносильно использованию user@&#171;%&#187;.</p>
<p>Если у вас есть право GRANT, вы можете указать необязательный параметр INDENTIFIED BY . Если описываемого пользователя не существует, он будет создан вместе с указанным паролем. Иначе будет изменен пароль существующего пользователя.</p>
<p>Право GRANT задается с помощью спецификатора WITH GRANT OPTION . После его выполнения пользователь сможет предоставить любое из имеющихся у него прав другому пользователю.</p>
<p>INSERT</p>
<pre name="code" class="sql">
INSERT [DELAYED | LOW_PRIORITY ] [INTO] table [ (column, ...) ] VALUES ( values )
[, ( values )... ]
INSERT [LOW_PRIORITY] [INTO] table [ (column, ...) ] SELECT ...
INSERT [LOW_PRIORITY] [INTO] table SET column=value, column=value,...
</pre>

<p>Записывает данные в таблицу. Первый вариант оператора просто вставит указанные значения в указанные столбцы. Поля, значения которых не определены, получат значение по умолчанию либо NULL. Второй вариант вставляет в таблицу результат запроса SELECT. Третий вариант является альтернативной формой первого, с более явным указанием того, каким полям какое, значение придать. Если INSERT первого вида написан со спецификатором DELAYED, все входящие запросы SELECT имеют приоритет перед оператором INSERT, он будет ждать окончания их действия перед добавлением данных. Таким же образом использование спецификатора LOW_PRIORITY с любой из форм INSERT приведет к тому, что добавление записей будет отложено до окончания всех других операций клиента.</p>
<p>Невозможно применить выражение ORDER BY вместе с запросом SELECT, используемым внутри оператора INSERT. Также вы не можете добавлять данные в таблицы, из которых осуществляется выборка. Начиная с версии 3.22.5 MySQL позволяет вставлять более одной записи в таблицу за один раз. Это делается путем добавления дополнительного списка значений, разделенных запятыми.</p>
<p>У вас должно быть право INSERT для использования этого оператора.</p>
<p>Примеры<br>
<p>&nbsp;</p>
<p># Вставить запись в таблицу 'people'</p>
<pre name="code" class="sql">
INSERT INTO people ( name, rank, serial_number )
VALUES ( 'Bob Smith', 'Captain', 12345 );
</pre>

<p># Скопировать все записи, которые старше определенной даты, из таблицы 'data' в таблицу 'old_data'. Обычно за этим следует удаление старых записей из 'data'.</p>
<pre name="code" class="sql">
INSERT INTO old_data ( id, date, field ) SELECT ( id, date, field) 
FROM data WHERE date &lt; 87459300;
</pre>

<p># Вставить З новые записи в таблицу 'people'.</p>
<pre name="code" class="sql">
INSERT INTO people (name, rank, serial_number ) 
VALUES ( 'Tim OVReilly', 'General', 1), 
       ('Andy Oram', 'Major', 4342), 
       ('Randy Yarger', 'Private', 9943);
</pre>

<p>KILL</p>
<p>KILL thread_id</p>
<p>Завершает указанный поток. ID потоков можно выяснить с помощью оператора SHOW PROCESSES . Завершение потоков, которые принадлежат не вам, а другим пользователям, требует права process .</p>
<p>Пример<br>
<p>&nbsp;</p>
<p># Завершить поток 3 </p>
<pre name="code" class="sql">KILL 3
</pre>

<p>LOAD</p>
<p>LOAD DATA [LOCAL] INFILE file [REPLACE|IGNORE] INTO TABLE table [delimiters] [(columns)]</p>
<p>Читает текстовый файл и вставляет данные в таблицу. Такой метод ввода данных гораздо быстрее, чем использование многих операторов INSERT. Хотя эта команда может быть вызвана с любого клиента, как и все остальные операторы SQL, считается, что указанный в предложении файл находится на сервере. Если путь к файлу полностью не указан, MySQL ищет его в том же каталоге, где расположена база данных. В версии MySQL3.22, при наличии спецификатора LOCAL, файл будет прочитан из локальной файловой системы клиентской машины.</p>
<p>Без указанных разделителей (delimiters) оператор LOAD DATA INFILE будет считать, что текстовые поля в файле разделены символом табуляции, особые символы набраны через обратную косую черту (так называемый бэкслэш - &#171;\&#187;), и строки заканчиваются символом конца строки.</p>
<p>Также можно указать собственные разделители с помощью следующих ключевых слов:</p>
<p>FIELDS TERMINATED BY 'с'</p>
<p>Определяет символ, используемый для разделения полей. Чтобы указать специальные символы, можно использовать стандартные управляющие коды языка С. Значение может содержать более одного символа. Например, FIELDS TERMINATED BY ', ' означает файл, разделенный запятыми, a FIELDS TERMINATED BY '\t' обозначает разделения табуляцией. Разделение табуляцией является значением по умолчанию.</p>
<p>FIELDS ENCLOSED BY 'с'</p>
<p>Определяет символ для объединения символьной строки. Например, FIELD ENCLOSED BY '' будет означать, что строка, содержащая "this, value", "this", "value" , будет записана в базу как три поля: "this,value", "this", и "value". По умолчанию считается, что в файле не используются кавычки.</p>
<p>FIELDS ESCAPED BY 'с'</p>
<p>Определяет символ, указывающий на то, что символ, следующий за ним, является простым, даже если обычно он считался бы управляющим. Например, FIELDS ESCAPED BY ' приведет к тому, что строка "First, Second",Third, Fourth" будет прочитана как три поля: "First", "Second,Third" и "Fourth" . Исключением являются символы нуля. Например, если FIELDS ESCAPED BY имеет значение обратной косой черты, то \0 указывает на ASCII NULL (символ с номером 0), и \N указывает на значение null в MySQL. Символ обратной косой черты является значением по умолчанию для этого параметра. Обратите внимание, что MySQL рассматривает его как спецсимвол. И если вам необходимо использовать его в этом выражении, следует отделить его еще одной обратной косой чертой: FIELDS ESCAPED BY '\\' .</p>
<p>LINES TERMINATED BY 'C'</p>
<p>Определяет символ для указания на начало новой строки. Значением могут быть несколько символов. Например, при LINES TERMINATED BY '.', файл, состоящий из а, b, с, d, e, f, g, h, k. , будет прочитан как три отдельные записи, с тремя полями в каждой. По умолчанию используется символ новой строки. Это означает, что по умолчанию MySQL считает каждую строку отдельной записью.</p>
<p>Ключевое слово FIELDS следует использовать только для всего выражения. Например:</p>
<p>LOAD DATA INFILE data.txt FIELDS TERMINATED BY ','ESCAPED BY '\\'.</p>
<p>По умолчанию, если прочитанное из файла значение совпадает с уже имеющимся и является при этом частью уникального ключа, будет выдана ошибка. Если в выражении есть ключевое слово REPLACE, значение из файла заменит имеющееся в таблице. Ключевое слово IGNORE приведет к игнорированию нового значения и сохранению старого.</p>
<p>Найденное в файле слово NULL считается указанием на пустое значение, если только оно не выделено символами, указанными в команде<br>
<p>&nbsp;</p>
<p>FIELDS ENCLOSED BY .</p>
<p>Использование одного символа для разных разделителей может смутить MySQL. Например, FIELDS TERMINATED BY ',' ENCLOSED BY ', ' приведет к непредсказуемому поведению.</p>
<p>Если задан список столбцов, данные будут записаны именно в эти поля. Если столбцы не указаны, число полей в файле с данными должно совпадать с числом полей в таблице, и они должны идти в том же порядке, что и поля в таблице.</p>
<p>Для выполнения этого оператора вы должны обладать правами SELECT и INSERT.</p>
<p>Пример<br>
<p>&nbsp;</p>
<p># Загрузить данные из файла 'mydata.txt' в таблицу 'mydata'. Считается, что поля отделены табуляцией и не заключены в кавычки.</p>
<pre name="code" class="sql">
LOAD DATA INFILE 'mydata.txf INTO TABLE mydata
</pre>

<p>#Загрузить данные из 'newdata.txt'. Найти два поля выделенных запятыми и вставить их значения в поля 'field"!' и 'field2' в таблице 'newtable'.</p>
<pre name="code" class="sql">
LOAD DATA INFILE 'newdata.txt' INTO TABLE newtable FIELDS TERMINATED BY
( field"!, -field2 )
</pre>

<p>LOCK</p>
<p>LOCK TABLES name [AS alias] READ|WRITE [, name2 [AS alias] READ|WRITE, ...]</p>
<p>Блокирует таблицу для ее использования отдельным потоком. В основном эта команда используется для эмуляции транзакций, как это описано в главе 7 &#171;Другие СУБД среднего масштаба&#187;. Если поток создал блокировку READ, все остальные потоки могут читать из таблицы, но записывать в таблицу может только один, контролирующий поток. При создании блокировки WRITE ни один из остальных потоков не может ни читать, ни изменять таблицу.</p>
<p><img src="pic/embim1731.png" width="48" height="44" vspace="1" hspace="1" border="0" alt=""></p>
<p>Одновременное использование заблокированных и незаблокированных таблиц может привести к зависанию потока. Вы должны заблокировать все таблицы, к которым осуществляется доступ во время блокировки. Этого не требуют таблицы, доступ к которым происходит только до или после блокирования. Последние версии MySQL выдадут ошибку при попытке доступа к незаблокированной таблице, если в это время имеются другие, блокированные таблицы.</p>
<p>Пример<br>
<p>&nbsp;</p>
<p># Заблокировать на запись таблицы 'table1' и 'table3'. Заблокировать любой доступ к таблице 'table2'. Также для таблицы 'table3'создать псевдоним 't3' для текущего потока.</p>
<pre name="code" class="sql">
LOCK TABLES table1 READ, table2 WRITE, tables AS t3 READ
</pre>

<p>OPTIMIZE</p>
<p>OPTIMIZE TABLE name</p>
<p>Обновляет таблицу, удаляя любое неиспользуемое пространство. Оптимизируемая таблица создается заново как отдельная временная таблица, а затем помещается на место текущей таблицы. Все табличные операции в это время происходят как обычно (вносимые изменения записываются во временную таблицу).</p>
<p>Пример</p>
<pre name="code" class="sql">
OPTIMIZE TABLE mytable
</pre>

<p>REPLACE</p>
<p>REPLACE INTO table [(column, ...)] VALUES (value, ....) </p>
<p>REPLACE INTO table [(column, ...)] SELECT select_clause</p>
<p>Вводит данные в таблицу, заменяя при этом все записи, вызывающие конфликт. Этот оператор аналогичен INSERT за исключением того, что при конфликте нового значения с существующим уникальным ключом новое значение будет записано вместо старого. Первый вариант оператора просто вставит указанные значения в указанные поля. Поля, значения которых не определены, получат значение по умолчанию либо NULL. Второй вариант вставляет в таблицу данные, полученные в результате запроса SELECT.</p>
<p>Примеры<br>
<p>&nbsp;</p>
<p># Вставить запись в таблицу 'people'.</p>
<pre name="code" class="sql">
REPLACE INTO people ( name, rank, senal_number ) 
VALUES ( 'Bob Smith', 'Captain', 12345 )
</pre>

<p># Скопировать все записи, которые старше определенной даты, из таблицы 'data' в таблицу 'old_data'. Обычно за этим следует удаление старых записей из 'data'</p>
<pre name="code" class="sql">
REPLACE INTO old_data ( id, date, field ) 
SELECT ( id, date, field) FROM data WHERE date &lt; 87459300
</pre>

<p>REVOKE</p>
<p>REVOKE privilege [(column, ...)] [, privilege [(column, ...) ,..] ON table FROM user</p>
<p>Отзывает права у пользователя. Значения privilege, table и user те же, что в операторе GRANT. У вас должно быть право GRANT для выполнения этого оператора.</p>
<p>SELECT</p>
<p>SELECT [STRAIGHTJOIN] [DISTINCT|ALL] value[, value2...]</p>
<p>[INTO OUTFILE 'filename' delimiters] FROM table[, table2...] [clause]</p>
<p>Выбирает данные из таблицы. Оператор SELECT является основным методом чтения данных из таблиц баз данных.</p>
<p>Если вы укажете несколько таблиц, MySQL автоматически объединит таблицы таким образом, что вы сможете сравнить значения в них. В случае если MySQL недостаточно эффективно выполняет соединение, вы можете указать предикат (ключевое слово) STRAIGHT_JOIN и заставить сервер объединить таблицы в порядке, заданном в запросе. Если указано ключевое слово DISTINCT, будет показана только одна запись из каждой группы одинаковых записей возвращаемого набора. Ключевое слово ALL, напротив, выдаст все возвращенные записи. По умолчанию действует ALL.</p>
<p>Возвращаемые значения могут быть следующего вида: </p>
<p>Aliases</p>
<p>Любые сложные имена столбцов или функций можно упростить, создав для них псевдонимы (alias). Внутри оператора SELECT к значению можно всегда обратиться по его псевдониму с любого места. (Например, SELECT DATE_FORMAT(date, "%W, %M %d %Y") as nice_date FROM calendar .)</p>
<p>Column names</p>
<p>Имена столбцов могут быть определены как column, table.column или database, table.column . Длинные формы необходимы только для того, чтобы отличать столбцы с одинаковыми именами, но их можно использовать в любое время (например, SELECT name FROM people; SELECT mydata.people.name FROM people ).</p>
<p>Functions</p>
<p>MySQL предлагает богатый выбор встроенных функций (см. ниже). Также всегда можно с помощью команды CREATE FUNCTION добавить пользовательские функции (например, SELECT COS(angle) FROM triangle).</p>
<p>По умолчанию MySQL возвращает все результаты запроса пользователю, сделавшему этот запрос. Однако возможно и перенаправление результатов запроса в файл. Таким образом, можно сбросить содержимое таблицы (или выбранную из нее часть) в файл, который будет прочитан человеком либо отформатирован для легкой загрузки в другую СУБД.</p>
<p>Спецификатор INTO OUTFILE 'filename' delimiters выполняет перенаправление. При его наличии результат запроса SELECT будет помещен в файл, указанный в filename. Формат этого файла определяется аргументами delimiters , которые практически те же, что у оператора LOAD DATA INFILE , но со следующими дополнениями:</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>К спецификатору FIELDS ENCLOSED BY можно добавить ключевое слово OPTIONALLY . MySQL будет в этом случае считать, что данные, заключенные в кавычки (или другие указанные символы), являются строками, а прочие данные примет за числовые.</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Удаление всех разделителей полей (т. е. FIELDS TERMINATED BY ENCLOSED BY ' ' ) приведет к использованию формата с фиксированной шириной. Данные будут экспортированы в соответствии с экранными размерами каждого поля. Этот формат понимают многие настольные СУБД и электронные таблицы.</td></tr></table></div><p>По умолчанию при экспорте данных без разделителей будет внесено по одной записи на каждую строку, использовано разделение табуляцией и символ обратной косой черты (\) в качестве экранирующего символа.</p>
<p>Список используемых таблиц может быть указан следующими способами:</p>
<p>Table1, Таblе2, Таblе3, . . .</p>
<p>Это самый простой метод. Таблицы соединяются так, как MySQL сочтет наиболее эффективным. Этот способ может быть также записан в виде: Table1 JOIN Table2 JOIN Таblе3..... , можно использовать ключевое слово CROSS, но оно не имеет эффекта (например, Table1 CROSS JOIN Table2 ). В объединенную таблицу войдут только те записи, которые отвечают условиям обоих столбцов. Например, запрос SELECT * FROM people, homes WHERE people. id=homes. owner создавал бы объединенную таблицу, содержащую записи из таблицы people , у которых значение поля id совпадает с полем owner в таблице homes.</p>
<p><img src="pic/embim1732.png" width="36" height="35" vspace="1" hspace="1" border="0" alt=""></p>
<p>Как и значениям, именам таблиц тоже можно дать псевдонимы (например, SELECT tl.name, t2. address FROM long_table_name t1, longer_table_name t2).</p>
<p>Tablel STRAIGHT_JOIN Table2</p>
<p>Идентично первому методу, за исключением того, что таблица слева всегда читается раньше таблицы справа. Этот метод следует ис-</p>
<p>пользовать в случае, если MySQL выполняет сортировку неэффективно, соединяя таблицы в неправильном порядке.</p>
<p>Table 1 LEFT [OUTER] JOIN Table2 ОN clause</p>
<p>Сравнивает правую таблицу с выражением. Для каждой не соответствующей ему записи при соединении с левой таблицей будет использована запись, состоящая из значений NULL. В предыдущем примере SELECT * FROM people, homes LEFT JOIN people, homes ON people. id=homes. owner объединенная таблица содержала бы все записи, совпадающие в обеих таблицах, а также все записи таблицы people, которым нет соответствия в таблице homes; для соответствующих полей таблицы homes использовались бы значения NULL. Ключевое слово OUTER необязательно и не имеет эффекта.</p>
<p>Tablel LEFT [OUTER] JOIN Table2 USING (column[, column2. . . ])</p>
<p>Объединяет указанные столбцы, только если они есть в обеих таблицах (например, SELECT * FROM old LEFT OUTER JOIN new USING (id) ).</p>
<p>Tablel NATURAL LEFT [OUTER] JOIN Table2</p>
<p>Объединяет только те столбцы, которые существуют в обеих таблицах. Тот же эффект дает использование предыдущего способа с указанием всех столбцов, имеющихся в той и другой таблице. (Например, SELECT rich_people.salary, poor_people.salary FROM rich_people NATURAL LEFT JOIN poorjeople .)</p>
<p>{oj Tablel LEFT OUTER JOIN Table2 ON clause }</p>
<p>Это аналог выражения Table 1 LEFT JOIN Table2 ON clause, и поддерживается только для совместимости с ODBC (&#171;oj&#187;заменяет &#171;Outer Join&#187;).</p>
<p>Если выражение не задано, SELECT вернет все данные из выбранных таблиц (таблицы).</p>
<p>Предложение отбора может содержать любые из следующих подфраз:</p>
<p>WHERE statement</p>
<p>Команда WHERE - это самый обычный способ выборки данных в SQL. Обычно фраза является сравнением какого-либо типа, но также может содержать любые из указанных ниже функций, кроме агрегатных. Также могут быть использованы имена, такие как имена столбцов и псевдонимы, числовые константы и строки. Поддерживаются следующие операторы:</p>
<p>()</p>
<p>Скобки используются для группировки операторов, чтобы указать старшинство.</p>
<p>+</p>
<p>Сложение двух числовых значений.</p>
<p>-</p>
<p>Вычитание двух числовых значений. *</p>
<p>Умножение двух числовых значений.</p>
<p>/</p>
<p>Деление двух числовых значений.</p>
<p>%</p>
<p>Выдает модуль двух числовых значений (определение остатка).</p>
<p>Осуществляет побитовое ИЛИ (OR) двух целочисленных значений.</p>
<p>&amp;</p>
<p>Осуществляет побитовое И (AND) двух целочисленных значений. </p>
<p>&lt;&lt;</p>
<p>Осуществляет побитовый левый сдвиг целочисленного значения.</p>
<p>&gt;&gt;</p>
<p>Осуществляет побитовый правый сдвиг целочисленного значения.</p>
<p>NOT или !</p>
<p>Выполняет логическое НЕ (возвращает 1, если значение было 0, и наоборот).</p>
<p>OR или ||</p>
<p>Выполняет логическое ИЛИ (возвращает 1, если любой из аргу-мещов не равен 0, иначе возвращает 1).</p>
<p>AND или &amp;&amp;<br>
<p>&nbsp;</p>
<p>Выполняет логическое И (вернет 0, если хоть один из аргументов равен 0, иначе вернет 1).</p>
<p>=</p>
<p>Выбирает запись, если значения совпадают. При сравнении MySQL автоматически производит преобразование типов.</p>
<p>&lt;&gt; или !=</p>
<p>Выбирает запись, если значения не совпадают.</p>
<p>&lt;=</p>
<p>Выбирает записи, в которых значение слева от операнда меньше или равно правому.</p>
<p>&lt;</p>
<p>Выбирает запись, если левое значение меньше правого.</p>
<p>&gt;=</p>
<p>Выбирает записи, где значение слева от операнда больше или равно правому.</p>
<p>&gt;</p>
<p>Выбирает записи, в которых значение слева от операнда больше правого.</p>
<p>value BETWEEN value1 AND value2</p>
<p>Выбирает записи, если value находится в диапазоне между valuel и value2 или равно одному из них.</p>
<p>value IN (valuel,value2,... )</p>
<p>Выбирает записи, если value находится среди указанных значений.</p>
<p>value NOT IN (value1, value2,.., )</p>
<p>Выбирает записи, если value не находится среди указанных значений.</p>
<p>valuel LIKE value2</p>
<p>Сравнивает value1и value2 и выбирает записи, где они совпадают. Значение справа может содержать знак подстановки ' %', которому удовлетворяет любое число символов (включая 0) и знак '_', заменяющий ровно один символ. Это, возможно, самое употребительное в SQL сравнение. Чаще всего используется сравнение поля с некоторым символом и знаком подстановки (например, SELECT name FROM people WHERE name LIKE 'B%' ).</p>
<p>valuel NOT LIKE value2</p>
<p>Сравнивает valuel и value2 и выбирает записи, где они не совпадают. Команда идентична NOT (valuel LIKE value2).</p>
<p>valuel REGEXP/RLIKE value2</p>
<p>Сравнивает valuel и value2, используя расширенный синтаксис регулярных выражений, и выбирает записи, если они совпадают. Значение справа может содержать полные подстановочные выражения и конструкции Unix (например, SELECT name FROM people WHERE name RLIKE '^B. *').</p>
<p>valuel NOT REGEXP value2</p>
<p>Сравнивает valuel и value2, используя расширенный синтаксис регулярных выражений, и выбирает записи, если они не совпадают. Команда идентична NOT (valuel REXEXP value2).</p>
<p>Предложение WHERE вернет все полученные в выражении значения, которые отличаются от 0 или NULL (т. е. все, что не является логически ложным). Поэтому SELECT age FROM people WHERE age&gt;10 вернет только те записи, где возраст больше 10.</p>
<p>GROUP BY column[, column2,...]</p>
<p>Группирует вместе записи по значению данных в определенных столбцах, что позволяет выполнять агрегатные функции над столбцами columns (например, SELECT name, MAX(age) FROM people GROUP BY name ).</p>
<p>HAVING clause</p>
<p>Аналог выражения WHERE, но выполняется над уже полученными из базы данными. С помощью HAVING хорошо выполняются агрегатные функции над относительно небольшими наборами данных, -уже выбранными из больших таблиц. В этом случае будет идти работа не с целой таблицей, а только с выбранными данными (например, SELECT name, MAX(age) FROM people GROUP BY name HAVING MAX(age)&gt;80 ).</p>
<p>ORDER BY column [ASC |DESC][, column2 [ASC |DESC], . . . ]</p>
<p>Сортирует возвращаемые данные по заданному столбцу (или столбцам). Если указать DESC, данные будут отсортированы по убыванию, иначе применяется сортировка по возрастанию. Сортировку по возрастанию можно задать и явным образом, указав ASC (например,</p>
<p>SELECT name, age FROM people ORDER BY age DESC ).</p>
<p>LIMIT [ start, ] rows</p>
<p>Возвращает только указанное количество записей. Значение start (необязательное) определяет на количество записей, которые надо пропустить перед выборкой данных. Нумерация записей начинается с нуля. (Например, SELECT url FROM links LIMIT 5,10 возвращает адреса URL с 5 по 14.)</p>
<p>PROCEDURE name</p>
<p>В mSQL и ранних версиях MySQL команда ничего не выполняет. Она поддерживалась для облегчения импорта данных из других SQL-серверов. Начиная с версии MySQL 3.22 эта фраза позволяет указать процедуру, модифицирующую результаты запроса перед их возвратом клиенту.</p>
<p>SELECT поддерживает концепцию функций. MySQL имеет ряд встроенных функций, способных оперировать с данными из таблиц, возвращая пользователю вычисляемое значение. Некоторые из функций могут вернуть значение как число или как строку, в зависимости от того, какой формат необходим пользователю. Эта возможность называется &#171;контекстом&#187; функции. Когда выбранные значения выводятся на дисплей, используется только текстовой контекст, но при вводе выбранных данных в поля таблиц или при использовании их в качестве аргументов других функций контекст зависит от того, что ожидается получателем данных. В частности, когда данные выбраны для их последующего ввода в поля числового типа, контекст функции будет числовым.</p>
<p>Далее приведены все встроенные в MySQL функции:</p>
<p>ABS(number)</p>
<p>Возвращает абсолютное значение числа number (например, ABS (-10) возвращает 10).</p>
<p>АCOS(number)</p>
<p>Возвращает арккосинус числа number в радианах (например, ACOS (0) возвращает 1.570796).</p>
<p>ASCII(char)</p>
<p>Возвращает ASCII код данного символа (например, ASCII (' h') вернет 104).</p>
<p>ASIN(number)</p>
<p>Возвращает арксинус числа number в радианах (например, ASIN (0) вернет 0.000000).</p>
<p>ATAN(number)</p>
<p>Возвращает арктангенс числа number в радианах (например, ATAN (1) вернет 0.785398).</p>
<p>ATAN2(X, Y)</p>
<p>Возвращает арктангенс точки (X, Y) (например, ATAN (-3,3) возвращает-0.785398).</p>
<p>СHAR(num1[,num2,. . .])</p>
<p>Возвращает строку, полученную в результате преобразования каждого из чисел в знак, соответствующий числовому ASCII коду (например, CHAR (122) возвращает'z').</p>
<p>CONCAT(string 1, string2 [, strings,. . . ])</p>
<p>Возвращает строку, сформированную соединением всех аргументов (конкатенация) (например, CONCAT('Hi',' ','Mom','!') вернет &#171;Hi Mom!&#187;).</p>
<p>CONV( number, basel, base2 )</p>
<p>Возвращает значение числа number, переведенного из системы счисления basel в base2. Число должно быть целочисленным (может быть задано собственно числом либо строкой). Система счисления задается любым целым числом от 2 до 36 (например, CONV (8,10,2) возвращает 1000 (число 8 в десятичной системе, приведенное к двоичному виду)).</p>
<p>BIN( decimal)</p>
<p>Возвращает двоичное значение указанного десятичного числа decimal. Это эквивалент функции CONV (decimal, 10,2) (например, BIN(8) вернет 1000).</p>
<p>BIT_COUNT( number)</p>
<p>Возвращает число битов, установленных в 1 в двоичном представлении числа (например, BIT_COUNT (17) возвращает 2).</p>
<p>CEILING( number)</p>
<p>Возвращает наименьшее целое число, которое больше или равняется указанному числу number (например, CEILING (5.67) возвратит 6).</p>
<p>COS( radians )</p>
<p>Возвращает косинус заданного в радианах числа number (например, COS(O) вернет 1. 000000).</p>
<p>СОТ( radians)</p>
<p>Возвращает котангенс числа number, заданного в радианах (например, СОТ(1) вернет 0.642093).</p>
<p>CURDATE()/CURRENT_DATE()</p>
<p>Возвращает текущую дату. При использовании в числовом контексте возвращается число вида YYYYMMDD , иначе вернется строка вида'YYYY-MM-DD' (например, CURDATE() может вернуть &#171;1998-08-24&#187;).</p>
<p>CURTIME()/CURRENT_TIME()</p>
<p>Возвращает текущее время. При использовании в числовом контексте возвращается число вида HHMMSS, иначе возвращается строка вида НН: ММ: SS (например, CURRENT_TIME() может вернуть 13:02:43).</p>
<p>DATABASE()</p>
<p>Возвращает имя текущей базы данных (например, DATABASE() может вернуть &#171;mydata&#187;).</p>
<p>DATE_ADD(date, INTERVAL amount type )/ADDOATE(date, INTERVAL amount type )</p>
<p>Возвращает дату, сформированную добавлением заданного количества времени к указанной дате. Добавляемое время может быть представлено одним из следующих типов: SECOND, MINUTE, HOUR, DAY, MONTH, YEAR, MINUTE_SECOND (как &#171;минутьпсекунды&#187;), HOUR_MINUTE (как &#171;часы:минуты&#187;), DAY_HOUR (как &#171;дни часы&#187;), YEAR_MONTH (как &#171;годы-месяцы&#187;), HOUR_SECOND (как &#171;часы:минуты:секунды&#187;), DAY_MINUTE (как &#171;дни часы:минуты&#187;) и DAY_SECOND (как &#171;дни часы:минуты:секунды&#187;). За исключением указанных выше типов, amount должно быть целым значением. (Например, DATE_ADD("1998-08-24 13:00:00", INTERVAL 2 MONTH) вернет &#171;1998-10-24 13:00:00&#187;.)</p>
<p>DATE_FORMAT( date, format )</p>
<p>Возвращает дату в указанном формате. Строка формата печатается в том виде, в каком задана, с выполнением следующих подстановок:</p>
<p>%а<br>
<p>&nbsp;</p>
<p>Сокращенное название дня недели (Sun, Mon и т. д.).</p>
<p>%b</p>
<p>Сокращенное название месяца (Jan, Feb и т. д.).</p>
<p>%D</p>
<p>День месяца с порядковым индексом (1-й, 2-й, 3-й и т. д.).</p>
<p>%d</p>
<p>День месяца.</p>
<p>%Н<br>
<p>&nbsp;</p>
<p>24-часовый час (всегда две цифры, например 01).</p>
<p>%h/%I</p>
<p>12-часовый час (всегда две цифры, например 09).</p>
<p>%i</p>
<p>Минуты.</p>
<p>%j</p>
<p>День года.</p>
<p>%k</p>
<p>24-часовый час (одна или две цифры, например 1).</p>
<p>%1</p>
<p>12-часовый час (одна или две цифры, например 9).</p>
<p>%М<br>
<p>&nbsp;</p>
<p>День месяца.</p>
<p>%m</p>
<p>Номер месяца (1 - это январь).</p>
<p>%р<br>
<p>&nbsp;</p>
<p>AM или РМ.</p>
<p>%r</p>
<p>12-часовое полное время (включая АМ/РМ).</p>
<p>%S</p>
<p>Секунды (всегда две цифры, например 04).</p>
<p>%s</p>
<p>Секунды (одна или две цифры, например 4).</p>
<p>%Т<br>
<p>&nbsp;</p>
<p>24-часовое полное время. </p>
<p>%U</p>
<p>Неделя года (новая неделя начинается с воскресенья).</p>
<p>%W</p>
<p>Название дня недели. </p>
<p>%w</p>
<p>Номер дня недели (0 - это воскресенье). </p>
<p>%Y</p>
<p>Четырехзначный год.</p>
<p>%У<br>
<p>&nbsp;</p>
<p>Год, две цифры.</p>
<p>%%</p>
<p>Символ &#171; % &#187;.</p>
<p>DATE_SUB( date, INTERVAL amount type )/SUBDATE( date, INTERVAL amount type )</p>
<p>Возвращает дату, сформированную вычитанием указанного количества времени из указанной даты. Используются те же самые типы, что и в команде DATE_ADD (например, SUBDATE(" 1999-05-20 11:04:23", INTERVAL 2 DAY) возвращает &#171;1999-05-18 11:04:23&#187;).</p>
<p>DAYNAME( date,)</p>
<p>Возвращает название дня недели для указанной даты (например,</p>
<p>DAYNAME(' 1998-08-22') </p>
<p>возвращает &#171;Saturday&#187;).</p>
<p>DAYOFMONTH( date)</p>
<p>Возвращает значение дня месяца для указанной даты (например, DAYOFMONTHC1998-08-22') возвращает 22).</p>
<p>DAYOFWEEK( ctete)/WEEKDAY( date)</p>
<p>Возвращает номер дня недели (1 - это воскресенье) для указанной даты (например, DAY_ OF_WEEK('1998-08-22') возвращает 7).</p>
<p>DAYOFYEAR( date)</p>
<p>Возвращает день года для указанной даты (например, DAYOFYEAR ('1983-02-15') возвращает 46).</p>
<p>DEGREES( radians )</p>
<p>Возвращает данный аргумент, конвертированный из радианов в градусы (например, DEGREES(2 *PI()) возвращает 360.000000).</p>
<p>ELT(number, string1, string2, . . . )</p>
<p>Возвращает string?, если number равно 1, string2, если number равно 2, и т. д. Если число number не соответствует ни одной строке, возвращается NULL (например, ELT(3, "once", "twice", "thrice", "fourth") возвращает &#171;thrice&#187;).</p>
<p>ENCRYPT( string[, salt])</p>
<p>Шифрует, ставит пароль на данную строку. Если указана база для шифрования salt, она используется при генерации пароля (например, ENCRYPT('mypass', 'За') может вернуть &#171;3afi4004idgv&#187;).</p>
<p>ЕХР(power)</p>
<p>Возвращает число е, возведенное в указанную степень (например, ЕХР(1) возвращает 2.718282).</p>
<p>FIELD( string, string1, string2, . . . )</p>
<p>Возвращает позицию аргумента (начиная со stringl) в списке аргументов, который совпадает со string. Вернет 0, если совпадений нет (например, FIELD( 'abe', 'деогде', 'John', 'abe', 'bill') возвращает 3).</p>
<p>FINO_IN_SET( string, set)</p>
<p>Возвращает позицию string в наборе set. Аргумент set &#8212; это набор строк, разделенных запятыми (например, FIND_IN_SET ('abe', 'деогде, John, abe, bill') возвращает 3).</p>
<p>FLOOR( number)</p>
<p>Возвращает наибольшее целое число, которое меньше или равно number (например, FLOOR (5.67) возвращает 5).</p>
<p>FORMAT( number, decimals )</p>
<p>Аккуратно форматирует заданное число, используя заданную длину дробной части (например, FORMAT(4432.99134,2) возвращает &#171;4,432.99&#187;).</p>
<p>FROM_DAYS( days)</p>
<p>Возвращает дату, заданную числом дней (где день 1 - это первое января первого года) (например, FROM_DAYS(728749) вернет &#171;1995-04-02&#187;).</p>
<p>FROM_UNIXTIME( seconds [, format])</p>
<p>Возвращает дату (GMT), соответствующую указанному числу секунд, прошедших с начала отсчета (1-е января 1970 г. GMT). Если определен формат (с использованием тех же параметров, что и в команде DATE_FORMAT ), возвращаемое время форматируется соответствующим образом (например, FROM_UNIXTIME(903981584) возвращает &#171;1998-08-24 18:00:02&#187;)-</p>
<p>GET_LOCK( name, seconds )</p>
<p>Создает определяемую пользователем блокировку, которая ждет заданное количество секунд до таймаута. Ее можно использовать в клиентском приложении для выполнения блокирования в программах, которые используют одинаковые имена блокировок. Если блокировка прошла успешно, возвращается 1. Если время ожидания истекло, вернется 0. При остальных ошибках вернется значение NULL. Возможна только одна активная блокировка для одной сессии. Повторный запуск GET_LOCK() удалит любую предыдущую блокировку без предупреждения (например, GET_ LOCK("mylock", 10) может вернуть 1 в течение 10 секунд).</p>
<p>GREATEST (num 1, num2[, numЗ, . . . ])</p>
<p>Возвращает наибольший из всех имеющихся аргументов (например, GREATEST(5, 6, 68,1,4) возвращает 68).</p>
<p>НЕХ(decimal )</p>
<p>Возвращает шестнадцатеричное значение указанного десятичного числа. Эквивалент функции CONV(decimal, 10,16) (например, НЕХ(90) возвращает &#171;За&#187;).</p>
<p>HOUR(time)</p>
<p>Возвращает час из указанной даты (например, HOUR('15:33:30') возвращает 15).</p>
<p>IF(test, value1, value2 )</p>
<p>Если test истинно, возвращает valuel, иначе возвращает value2. Значение test должно быть целочисленным, поэтому числа с плавающей запятой следует использовать после преобразования их к типу integer (например, IF(1&gt;0, "true", "false") возвращает true).</p>
<p>IFNULL( value, value2 )</p>
<p>Возвращает value, если оно не равно null, иначе возвращает value2 (например, IFNULL(NULL, "bar") возвращает &#171;bar&#187;).</p>
<p>INSERT( string, position, length, new )</p>
<p>Возвращает строку, созданную путем замены некоторых символов из строки string на символы new. Будет заменено количество символов, указанное в length, начиная с позиции position (например, INSERT( 'help', 3,1, ' can jum') возвращает &#171;he can jump&#187;).</p>
<p>INSTR( string, substring )</p>
<p>Идентично функции LOCATE, за исключением того, что .аргументы идут в обратном порядке (например, INSTR( 'makebelieve', 'lie') возвращает 7).</p>
<p>ISNULL( expression )</p>
<p>Возвращает 1, если выражение в expression равно NULL, иначе возвращает 0 (например, ISNULL(3) вернет 0).</p>
<p>INTERVAL( А, В, С, D, . . . )</p>
<p>Возвращает 0, если А - это наименьшее значение, 1 - если А находится между В и С, 2- если А находится между С и D, и т. д. Все значения, кроме А, должны идти по порядку (например, INTERVAL (5,2,4,6,8) возвращает 2 (так как 5 находился во втором интервале между 4 и 6).</p>
<p>LAST_INSERT_ID()</p>
<p>Возвращает последнее значение поля AUTO_INCREMENT , которое было создано автоматически (например, LAST_INSERT_ID() может вернуть 4).</p>
<p>LCASE( string )/LOWER( string)</p>
<p>Возвращает строку string, где все символы переведены в нижний регистр (например, LCASE(' ВоВ') возвращает &#171;bob&#187;).</p>
<p>LEAST(num1, num2[, num3, . . . ])</p>
<p>Возвращает наименьший из всех имеющихся аргументов (например, LEAST(5,6,68,1,4) возвращает 1).</p>
<p>LEFT( string, length )</p>
<p>Возвращает количество символов length из строки string, начиная с начала строки (например, LEFTC 12345", 3) возвращает &#171;123&#187;).</p>
<p>LENGTH (string)/OCTET_LENGTH( string )/CHAR_LENGTH( string)/ CHARACTER_LENGTH( string)</p>
<p>Возвращает длину строки string (например, CHAR_LENGTH( 'Hi Mom! ' ) возвращает 7). В многобайтных наборах символов один символ может занимать более одного байта (например, в Unicode и некоторых азиатских наборах символов). В этих случаях строковые функции MySQL должны правильно считать число символов, а не байтов. Однако в версиях до 3.23 эта функция не работала и возвращала число байт.</p>
<p>LOCATE( substring, string [, number ])/POSITION( substring, string )</p>
<p>Возвращает позицию подстроки substring в строке string. Возвращает 0, если substring не найдена. Если в LOCATE задан третий числовой аргумент, поиск подстроки начнется только с позиции, указанной этим аргументом (например, LOCATE(' SQL', ' MySQL') вернет 3).</p>
<p>LOG(number)</p>
<p>Возвращает натуральный логарифм числа number (например, LOG(2) возвращает 0.693147).</p>
<p>LOG10(number)</p>
<p>Возвращает обычный (десятичный) логарифм числа (например, LOG10(1000) возвращает 3.000000).</p>
<p>LPAD( string, length, padding )</p>
<p>Возвращает заданную строку string с дополнением padding к началу строки. Дополнение будет повторяться, пока новая строка не достигнет длины, указанной в length, (например, LPAD(' -Merry X-Mas',18, 'Но') возвращает &#171;НоНоНо Merry X-Mas&#187;).</p>
<p>LTRIM( string)</p>
<p>Возвращает строку string с удалением всех начальных пробелов (например, LTRIM(' Oops') возвращает &#171;Oops&#187;).</p>
<p>MID( string, position, length )/SUBSTRING( string, position, length )/</p>
<p>SUBSTRING( string FROM position FOR length )</p>
<p>Возвращает подстроку из количества символов, указанного в length, взятых из строки string, начиная с позиции position (например, SUBSTRING(' 12345', 2,3) возвращает &#171;234&#187;).</p>
<p>MINUTE( time)</p>
<p>Возвращает количество минут указанного времени (например, MI-NUTE('15:33:30') возвращает 33).</p>
<p>МOD(num1, пит2)</p>
<p>Возвращает модуль числа пит1, деленного на число пит2. Функция аналогична оператору % (например, MOD(11,3) возвращает 2).</p>
<p>MONTH (date)</p>
<p>Возвращает номер месяца (1 в случае января) для указанной даты (например, MONTH(' 1998-08-22') возвращает 8).</p>
<p>MONTHNAME( date)</p>
<p>Возвращает название месяца для указанной даты (например, MONTHNAME('1998-08- 22') возвращает &#171;August&#187;).</p>
<p>NOW()/SYSDATE()/CURRENT_TIMESTAMP()</p>
<p>Возвращает текущую дату и время. В числовом контексте возвращается число вида YYYYMMDDHHMMSS , в ином случае вернется строка вида 'YYYY-MM-DD HH:MM:SS' (например, SYSDATE() может вернуть &#171;1998-08-24 12:55:32&#187;).</p>
<p>OCT( decimal)</p>
<p>Возвращает восьмеричное значение заданного десятичного числа. Функция эквивалентна функции CONV(deciinal, 10,8) (например, ОСТ(8) возвращает 10).</p>
<p>PASSWORD( string)</p>
<p>Возвращает зашифрованную версию заданной строки. (Например, PASSWD( 'mypass') может вернуть &#171;3afi4004idgv&#187;.)</p>
<p>PERIOD_ADD( date, months )</p>
<p>Возвращает дату, сформированную путем добавления указанного числа месяцев к заданной дате (которая должна быть в формате YYMM или YYYYMM) (например, PERIOD_ADD(9808,14) возвращает 199910).</p>
<p>PERIOD_DIFF( date1, date2 )</p>
<p>Возвращает количество месяцев между указанными датами (которые должны быть указаны в формате YYMM или YYYYMM) (например, PERIOD_DIFF(199901,8901) вернет 120).</p>
<p>PI()</p>
<p>Возвращает число к: 3.141593.</p>
<p>POW(num1, num2)/POWER( num1, num2]</p>
<p>Возвращает значение числа пит 1, возведенного в степень пит2- (например, POWER(3,2) возвращает 9.000000).</p>
<p>QUARTER( date)</p>
<p>Возвращает номер квартала указанной даты (1 - это январь-март) (например, QUARTER(' 1998-08-22') возвращает 3).</p>
<p>RADIANS( degrees)</p>
<p>Возвращает значение заданного аргумента, переведенное из градусов в радианы (например, RADIANS(-90) возвращает -1.570796).</p>
<p>RAND ([seed])</p>
<p>Возвращает случайную десятичную дробь от 0 до 1. Если задан аргумент, он используется как источник (seed) для генератора случайных чисел (например, RAND(3) может вернуть 0.435434).</p>
<p>RELEASE_LOCK( name)</p>
<p>Удаляет блокировку, созданную функцией GET_LOCK . Вернет 1, если снятие блокировки было успешным; 0, если блокировку не удалось снять, поскольку она не принадлежит текущему потоку; и NULL, если блокировки нет (например, RELEASE_LOCK("mylock") ).</p>
<p>REPEAT( string, number )</p>
<p>Возвращает строку, полученную путем повторения заданной строки некоторое число раз (указано в number). Вернет пустую строку, если number меньше или равно нулю (например, REPEAT( 'ma', 4) возвращает 'mamamama').</p>
<p>REPLACE( string, old, new )</p>
<p>Возвращает строку, в которой все вхождения подстроки old заменяются на подстроку new (например, REPLACE('black jack','ack1,'oke') возвращает &#171;bloke joke&#187;).</p>
<p>REVERSE( string)</p>
<p>Возвращает символы строки string в обратном порядке (например, REVERSE('my bologna') возвращает &#171;angolobym&#187;).</p>
<p>RIGHT( string, length )/SUBSTRING( string FROM length)</p>
<p>Возвращает количество символов из string, указанное в length, начиная с конца строки (например, SUBSTRING( &#171;12345&#187; FROM 3) возвращает &#171;345&#187;).</p>
<p>ROUND( number [.decimal ])</p>
<p>Округляет дробную часть числа number до указанного количества цифр. Если аргумент decimal не указан, число округляется до целого (например, ROUND(5.67,1) возвращает 5.7).</p>
<p>RPAD( string, length, padding )</p>
<p>Возвращает строку string с дополнением padding к концу строки. Дополнение будет повторяться, пока новая строка не достигнет длины, указанной в length (например, RPAD( 'Yo', 5, '! ') возвращает &#171;Yo!!!&#187;).</p>
<p>RTRIM( string)</p>
<p>Возвращает строку string с удалением всех концевых пробелов (например, RTRIM( 'Oops ') вернет &#171;Oops&#187;).</p>
<p>SECOND( time)</p>
<p>Возвращает секунды из указанного времени (например, SE-COND('15:33:30') возвращает 30).</p>
<p>SEC_TO_TIME( seconds )</p>
<p>Возвращает число часов, минут и секунд в заданном количестве секунд. При использовании в числовом контексте возвращает число в формате HHMMSS, иначе вернет строку вида HH:MM:SS (например, SEC_TO_TIME(3666) возвращает &#171;01:01:06&#187;).</p>
<p>SING( number)</p>
<p>Возвращает -1, если число number отрицательное, 0, если это ноль, и 1, если оно положительное (например, SIGN(4) возвращает 1).</p>
<p>SIN( radians)</p>
<p>Возвращает синус числа, заданного в радианах (например, SIN(2*РI()) возвращает0. 000000).</p>
<p>SOUNDEX(stdng)</p>
<p>Возвращает код Soundex, связанный со строкой (например, SOUNDEX(' Jello') возвращает &#171;J400&#187;).</p>
<p>SPACE(number)</p>
<p>Возвращает строку из пробелов, число которых указанно в number (например, SPACE( 5) возвращает&lt;&gt;).</p>
<p>SQRT(number)</p>
<p>Возвращает квадратный корень числа number (например, SQRT(16) возвращает 4.000000).</p>
<p>STRCMP( string1, string2 )</p>
<p>Возвращает 0, если строки совпадают, -1 если бы string1 при сортировке оказалась раньше строки string2; или 1, если string! была бы при сортировке после string2 (например, STRCMP( 'bob', 'bobbie') возвращает &#8212;1).</p>
<p>SUBSTRING_INDEX( string, character, number )</p>
<p>Считает количество указанных символов character в строке string до тех пор, пока не досчитает до заданного числа number. Если это число было отрицательным, вернется все, что слева от символа, на котором остановился счетчик, а если число положительное, то функция вернет все, что находится справа от него. (Например, SUBSTRINGJENDEXC 1,2, 3,4,5', ',',-3) возвращает &#171;1,2,3&#187;.)</p>
<p>SUBSTRING( string,position )</p>
<p>Возвращает строку string, начиная с символа указанного в position (например, SUBSTRING(&#171;123456&#187;, 3) возвращает &#171;3456&#187;).</p>
<p>TAN(radians )</p>
<p>Возвращает тангенс числа, заданного в радианах (например, TAN(0) возвращает 0.000000).</p>
<p>TIME_FORMAT( time, format)</p>
<p>Форматирует заданное время в указанный формат. Формат тот же, что и в команде DATE FORMAT , описанной выше.</p>
<p>TIME_TO_SEC( time)</p>
<p>Возвращает количество секунд в аргументе time (например, ТIМЕ_ТО_ 8ЕС(' 01:01:06') возвращает 3666).</p>
<p>TO_DAYS(date)</p>
<p>Возвращает количество дней, прошедшее до указанной даты (день 1 - это 1-е января 1-го года). Дата может быть значением типа DATE, DATETIME, TIMESTAMP или числом в формате YYMMDD либо YYYYMMDD (например, TO_DAYS( 19950402) возвращает 728749).</p>
<p>TRIM([BOTH|LEADING|TRAILING] [ remove ] [FROM] string)</p>
<p>Возвращает строку string с удаленными концевыми и начальными пробелами. Вы можете указать, какие пробелы хотите удалить (концевые, начальные или и те и другие). Также вместо пробела можно указать другой символ (например, TRIM( both ' ' from ' --look here&#8212;') возвращает &#171;look here&#187;).</p>
<p>TRUNCATE( number, decimals )</p>
<p>Возвращает number с дробной частью, усеченной до указанного количества цифр. (Например, TRUNCATE(3.33333333,2) возвращает 3.33.)</p>
<p>UCASE( string)/UPPER( string)</p>
<p>Возвращает string, где все символы переведены в верхний регистр (например, UPPER ('Scooby') возвращает &#171;SCOOBY&#187;).</p>
<p>UNIX_TIMESTAMP([ date])</p>
<p>Возвращает число секунд, прошедшее с начала отсчета (1 января 1970 г. GMT) до заданной даты (GMT). Если дата не указана, возвращает число секунд, прошедшее до текущей даты (например, UNIX_TI-MESTAMPC1998-08-24 18:00:02') возвращает 903981584).</p>
<p>USER()/SYSTEM_USER()/SESSION_USER()</p>
<p>Возвращает имя текущего пользователя (например, SYSTEM_USER() может вернуть &#171;ryarger&#187;).</p>
<p>VERSION()</p>
<p>Возвращает версию самого сервера MySQL (например, VERSION() может вернуть &#171;3.22. 5c-alpha&#187;).</p>
<p>WEEK(date)</p>
<p>Возвращает порядковый номер недели года из указанной даты (например, WEEK( '1998-12-29') возвращает 52).</p>
<p>YEAR (date)</p>
<p>Возвращает год из указанной даты (например, YEAR('1998-12-29') возвращает 1998).</p>
<p>Далее идут агрегатные функции, выполняемые над набором данных. Обычно этот метод используется для выполнения некоторого действия над всем набором возвращаемых данных. Например, функция SELECT</p>
<p>AVG(height) FROM kids возвращала бы среднее от значений поля ' height' в таблице kids.</p>
<p>AVG( expression )</p>
<p>Возвращает среднее значение из значений в expression (например, SELECT AVG(score) FROM tests ).</p>
<p>BIT_AND( expression )</p>
<p>Возвращает результат побитового И, агрегирующего все значения в expression (например, SELECT BIT_AND(flags) FROM options ).</p>
<p>BIT_OR( expression )</p>
<p>Возвращает побитовое ИЛИ, агрегирующее все значения значения в expression (например, SELECT BIT_ OR(flags) FROM options ).</p>
<p>COUNT( expression )</p>
<p>Возвращает количество раз, когда значение expression было не нулевым. COUNT(*) вернет число записей с какими-либо данными во всей таблице (например, SELECT COUNT( *) FROM folders ).</p>
<p>MAX( expression )</p>
<p>Возвращает наибольшее из значений в expression (например, SELECT MAX (elevation) FROM mountains ).</p>
<p>MIN( expression )</p>
<p>Возвращает наименьшее из значений в expression (например, SELECT MIN(level) FROM toxic_waste ).</p>
<p>STD( expression )/STDDEV( expression )</p>
<p>Возвращает среднеквадратичное отклонение значения в expression (например, SELECT STDDEV(points) FROM data ).</p>
<p>SUM(expression )</p>
<p>Возвращает сумму значений в expression (например, SELECT SUM(calories) FROM daily_diet ).</p>
<p>Примеры<br>
<p>&nbsp;</p>
<p>Найти все имена (пате)в таблице 'people', у которых поле 'state' равно 'Ml'.</p>
<pre name="code" class="sql">
SELECT name FROM people WHERE state-'MI' 
</pre>
<p>Показать все данные из таблицы 'mytable'. </p>
<pre name="code" class="sql">
SELECT * FROM mytaPle
</pre>

<p>SET</p>
<pre name="code" class="sql">
SET OPTION SQL_OPTION=va.Zue
</pre>

<p>Устанавливает настройки для текущей сессии. Определенные этим оператором параметры действуют только для текущего соединения и исчезают при его закрытии. В настоящее время поддерживаются следующие настройки:</p>
<p>CHARACTER SET charselname или DEFAULT</p>
<p>Изменяет набор символов, используемый MySQL. Сейчас поддерживается только один альтернативный набор символов cp1251_koi8, который относится к русскому языку. Указав DEFAULT, вы вернете обычную таблицу символов.</p>
<p>LAST_INSERT_ID= number</p>
<p>Устанавливает значение, возвращаемое функцией LAST_INSERT_ID() .</p>
<p>SQL_BIG_SELECTS=0 или 1</p>
<p>Определяет реакцию системы при обнаружении длинного запроса SELECT. Если установить 1, MySQL прервет запрос, выдав ошибку с предупреждением о том, что запрос, возможно, потребует слишком много времени на обработку. MySQL решает, что запрос является слишком длинным, если придется обрабатывать больше записей, чем указано в системной переменной max_join_size . По умолчанию значение равно 0, что разрешает любые запросы.</p>
<p>SQL_BIG_TABLES=0 или 1</p>
<p>Определяет работу с временными таблицами (создаваемыми обычно при обработке больших наборов данных). Если это значение равно 1, временные таблицы хранятся на диске, что будет медленнее работы с оперативной памятью, но может предотвратить ошибки в системах с небольшим объемом памяти. Значение по умолчанию -О, все временные таблицы хранятся RAM.</p>
<p>SQL_LOG_OFF=0 или 1</p>
<p>При установке параметра в 1 выключается стандартная журнализа-ция-текущей сессии. Журнализация ISAM и журнал обновлений базы не выключаются. У вас должны быть права PROCESS LIST для использования этой установки. По умолчанию значение равно 0, что разрешает обычную журнализацию. В главе 4 &#171;MySQL&#187;, описаны разные схемы журнализации MySQL.</p>
<p>SQL_SELECT_LIMIT= number</p>
<p>Максимальное количество записей, возвращаемое запросом SELECT. Спецификатор LIMIT отменяет это значение. По умолчанию возвращаются все записи.</p>
<p>SQL_UPDATE_LOG=0 или 1</p>
<p>Выключает журнализацию обновления базы данных для текущей сессии при значении, равном 0. Не влияет на стандартную журнализацию или на журнализацию ISAM. У вас должны быть права<br>
<p>&nbsp;</p>
<p>PROCESS LIST для использования этой установки. По умолчанию значение равно 1, что разрешает обычную журнализацию.</p>
<p>TIMESTAMP= value или DEFAULT</p>
<p>Устанавливает время, использованное для сессии. Это время записывается в журнал обновлений и применяется при восстановлении данных из журнала. Установка DEFAULT вернет системное время.</p>
<p>Пример<br>
<p>&nbsp;</p>
<p> Выключить журнализацию текущей сессии.</p>
<pre name="code" class="sql">SET OPTION SQL_LOG_OFF=1
</pre>

<p>SHOW</p>
<pre name="code" class="sql">
SHOW DATABASES [LIKE clause]
SHOW KEYS FROM table [FROM database]
SHOW INDEX FROM table [FROM database]
SHOW TABLES [FROM database] [LIKE clause]
SHOW COLUMNS FROM table [FROM database] [LIKE clause]
SHOW FIELDS FROM table [FROM database] [LIKE clause]
SHOW STATUS
SHOW TABLE STATUS [FROM database] [LIKE clause]
SHOW VARIABLES [LIKE clause]
</pre>

<p>Выводит различную информацию о системе MySQL. Выражение можно использовать для выяснения статуса или структуры практически любой части.</p>
<p>Примеры<br>
<p>&nbsp;</p>
<p>Показать все доступные БД. SHOW DATABASES Показать информацию об индексах таблицы 'bigdata'</p>
<pre name="code" class="sql">
SHOW KEYS FROM bigdata
</pre>

<p>Показать информацию об индексах в таблице 'bigdata' в БД 'mydata'</p>
<pre name="code" class="sql">
SHOW INDEX FROM bigdata FROM mydata
</pre>

<p>Показать все доступные таблицы из БД 'mydata', начинающиеся с  буквы 'z'</p>
<pre name="code" class="sql">
SHOW TABLES FROM mydata LIKE 'z%'
</pre>

<p>If Выдать информацию обо всех столбцах таблицы 'skates'</p>
<pre name="code" class="sql">
SHOW COLUMNS FROM stakes
</pre>

<p>Выдать информацию обо всех столбцах таблицы 'people', с именами кончающимися на '_name'</p>
<pre name="code" class="sql">
SHOW FIELDS FROM people LIKE '%\_name'
</pre>

<p>Показать информацию о состоянии сервера SHOW STATUS Показать системные переменные </p>
<pre name="code" class="sql">SHOW VARIABLES
</pre>

<p>UNLOCK</p>
<p>UNLOCK TABLES</p>
<p>Разблокирует все таблицы в текущем соединении, заблокированные с помощью выражения LOCK.</p>
<p>Пример<br>
<p>&nbsp;</p>
<p>Unlock all tables </p>
<pre name="code" class="sql">UNLOCK TABLES
</pre>

<p>UPDATE</p>
<p>UPDATE table SET column=value, . . . [WHERE clause]</p>
<p>Изменяет данные в таблице. Выражение используется для изменения имеющихся данных без модификации структуры самой таблицы. Можно использовать имя столбца как источник значения value при установке нового значения. Например, UPDATE health SET miles_ran=miles_ran+5 добавит 5 к текущему значению поля miles_ran. Возвращает число измененных записей.</p>
<p>Для выполнения выражения необходимы права UPDATE .</p>
<p>Пример<br>
<p>&nbsp;</p>
<p># Изменить имя 'John Deo' на 'John Doe' во всей таблице 'people'. </p>
<pre name="code" class="sql">
UPDATE people SET name='John Doe' WHERE name='John Deo'
</pre>

<p>USE</p>
<p>USE database</p>
<p>Выбирает БД по умолчанию. Указанная в выражении БД будет использоваться по умолчанию во всех последующих запросах. Другие БД могут быть явно указаны с помощью полной системы обозначения database.table.column .</p>
<p>Пример<br>
<p>&nbsp;</p>
<p># Сделать db1 БД по умолчанию USE db1</p>
<p>mSQLSQL</p>
<p>CREATE</p>
<p>CREATE TABLE name field_name field_type, [field2 type2, ...]</p>
<p>CREATE SEQUENCE ON table [STEP value] [VALUE value]</p>
<p>CREATE INDEX name ON table ( column, ...)</p>
<p>Создает новые элементы базы данных (или полностью новые базы). Предложение используется для создания БД, таблиц, индексов и счетчиков.</p>
<p>CREATE SEQUENCE создает счетчик на таблицу. Счетчик - это простое значение, связанное с таблицей, за которым следит сервер mSQL. Наиболее часто счетчик используют для создания уникальных идентификаторов в таблицах. При прочтении значение счетчика каждый раз инкрементируется. Спецификатор STEP указывает на какое значение каждый раз инкрементируется счетчик. Спецификатор VALUE задает начальное значение счетчика.</p>
<p>Оператор CREATE INDEX определяет индекс для таблицы. Система mSQL поддерживает индексы, содержащие более одного поля. Вы должны дать индексу имя, необязательно осмысленное, поскольку конечным пользователям редко необходим доступ к индексам.</p>
<p>CREATE TABLE определяет структуру таблицы в базе данных. Этим оператором создаются все таблицы mSQL. Предложение состоит из имени таблицы, за которым идет любое количество определений полей. Синтаксис определения полей включает в себя имя поля, затем его тип, за которым следует любой модификатор (например: name char(30) not null). mSQL поддерживает следующие типы данных:</p>
<p>CHAR (length)</p>
<p>Текстовое значение фиксированной длины. Никакое значение не может быть больше заданной длины.</p>
<p>DATE</p>
<p>Стандартный тип даты.</p>
<p>INT</p>
<p>Стандартное четырехбайтовое целое в диапазоне от -2147483646 до 2147483647.</p>
<p>MONEY</p>
<p>Денежный тип, подходящий для аккуратного хранения денежных значений. Тип позволяет хранить десятичные значения (как 19.99) без необходимости использовать тип числа с плавающей запятой.</p>
<p>REAL</p>
<p>Стандартное восьмибайтовое число с плавающей запятой. Минимальные ненулевые значения +/-4.94Е-324 и максимальные значения +/- 1.79Е+308.</p>
<p>ТЕХТ( length)</p>
<p>Текстовое значение переменной длины. Заданная длина - это максимальное значение для большинства данных, однако могут быть введены и более длинные данные.</p>
<p>TIME</p>
<p>Стандартный тип времени.</p>
<p>UINT</p>
<p>Стандартное четырехбайтовое беззнаковое целое. Диапазон от 0 до 4294967295.</p>
<p>В дополнение к основным типам могут быть использованы несколько спецификаторов для уточнения свойств типа:</p>
<p>length</p>
<p>Это является максимальной длиной символьного типа. Для типа CHAR это абсолютный максимум, для типа TEXT это приблизительный максимум, применяющийся только к большинству данных. Более длинные данные могут быть введены в поле TEXT, однако это замедлит операции с таблицей.</p>
<p>NOT NULL</p>
<p>Указывает, что поле не может содержать нулевое значение. Попытка ввести в это поле такое значение вызовет ошибку.</p>
<p>Примеры<br>
<p>&nbsp;</p>
<p># Создать 'простую таблицу</p>
<pre name="code" class="sql">
CREATE TABLE emp_data ( id INT, name CHAR(50) )
</pre>

<p># Добавить счетчик к таблице 'checks' с начальным значением '1000' и # шагом инкрементации по умолчанию (1)</p>
<p>CREATE SEQUENCE ON checks VALUE 1000</p>
<p># Создать индекс для таблицы 'music', включающий в себя<br>
<p>&nbsp;</p>
<p># поля 'artist','publisher' и 'title'.</p>
<p>CREATE INDEX idxl O.N music ( artist, publisher, title )</p>
<p>DELETE</p>
<p>DELETE FROM table [WHERE clause]</p>
<p>Удаляет запись из таблицы. Если применяется без предложения WHERE, будет полностью удалена вся таблица, а затем создана новая пустая<br>
<p>&nbsp;</p>
<p>таблица. С использованием WHERE будут удалены записи, отвечающие условиям выражения.</p>
<p>Примеры<br>
<p>&nbsp;</p>
<p># Стереть все данные из таблицы 'olddata'(no не саму таблицу). DELETE FROM olddata</p>
<p># Стереть все записи в таблице 'sales', в которых поле 'year' равно '1995', DELETE FROM sales WHERE year=1995</p>
<p>DROP</p>
<p>DROP INDEX name DROP TABLE name DROP SEQUENCE FROM table</p>
<p>Полностью удаляет таблицу, индекс или счетчик из системы mSQL.</p>
<p><img src="pic/embim1733.png" width="48" height="44" vspace="1" hspace="1" border="0" alt=""></p>
<p>DROP - это, возможно, самое опасное из выражений SQL. Если вы имеете право на выполнение команд DROP, вы можете полностью стереть таблицу или даже целую базу данных. Это произойдет без предупреждения или запроса на подтверждение. Единственный способ отменить DROP - восстановление базы данных из резервной копии. Поэтому следует запомнить два правиле: (1) всегда сохраняйте резервную копию вашей базы (backup); (2) не используйте DROP до тех пор, пока вы полностью не уверены в том, что это необходимо.</p>
<p>Примеры<br>
<p>&nbsp;</p>
<p># Удалить таблицу 'oh_no'. DROP TABLE oh_no</p>
<p># Удалить индекс с именем 'my_index' DROP INDEX my_index</p>
<p># Стереть счетчик для таблицы 'counter'. Другой счетчик может быть </p>
<p># создан в любое время с помощью команды 'CREATE SEQUENCE'.</p>
<p>DROP SEQUENCE FROM counter</p>
<p>INSERT</p>
<p>INSERT INTO table [ (column, ...) ] VALUES ( values )</p>
<p>Записывает данные в таблицу. Этот оператор вставит указанные значения в заданные столбцы. Поля, значения которых не указаны, получат значение NULL. Если вы не зададите список столбцов, число указанных значений должно точно совпадать с числом столбцов в таблице.</p>
<p>Примеры<br>
<p>&nbsp;</p>
<p># Добавить запись в таблицу'people'.</p>
<p>INSERT INTO people ( name, rank, serial_number )</p>
<p>VALUES ( 'Bob Smith', 'Captain', 12345 )</p>
<p>SELECT</p>
<p>SELECT [DISTINCT] columns FROM table [clause]</p>
<p>Выбирает данные из таблицы. Оператор SELECT является основным методом чтения данных из таблиц баз данных.</p>
<p>Если вы укажете несколько таблиц, mSQL автоматически объединит таблицы для сравнения записей.</p>
<p>Если указано ключевое слово DISTINCT, будет показана только одна запись из каждой группы одинаковых записей возвращаемого набора.</p>
<p>Имена столбцов могут быть указаны как column или как table, column . Длинная форма необходима только для того, чтобы отличать столбцы с одинаковыми именами, но ее можно использовать в любое время (например, SELECT name FROM people; SELECT people, name FROM people ).</p>
<p>Список таблиц для соединения указывается как Table1, Table2, Tab-1еЗ, .... Таблицы будут соединены таким образом, как mSQL сочтет наиболее эффективным. Именам таблиц могут быть присвоены псевдонимы (например, SELECT t1.name, t2.address FROM Iong_table_name=t1, Ionger_table_name=t2 ). Если не указано выражение clause, SELECT вернет все данные из выбранной таблицы (или таблиц).</p>
<p>Выражение отбора записей может содержать следующие операторы:</p>
<p>WHERE</p>
<p>Конструкция WHERE является основным способом поиска данных в SQL. В конструкции сравниваются два и более значений. Можно использовать значения с именами (такие как имена столбцов и псевдонимы), числовые константы и строки. Поддерживаются следующие операторы:</p>
<p>AND</p>
<p>Выполняет логическое И (вернет 0, если хоть один из аргументов равен 0, иначе вернет 1).</p>
<p>OR</p>
<p>Выполняет логическое ИЛИ (возвращает 1, если любой из аргументов не равен 0, иначе возвращает 0).</p>
<p>()</p>
<p>Скобки используются для группировки операторов, чтобы указать старшинство.</p>
<p>=</p>
<p>Возвращает 1, если два значения совпадают, иначе вернет 0. mSQL автоматически преобразует типы при сравнении значений.</p>
<p>&lt;&gt;</p>
<p>Возвращает 1, если два значения не совпадают, иначе возвращает 0.</p>
<p>&lt;=</p>
<p>Возвращает 1, если левое значение меньше или равно правому, иначе возвращает 0.</p>
<p>&lt;</p>
<p>Возвращает 1, если левое значение меньше, чем значение справа, иначе возвращает 0.</p>
<p>&gt;=</p>
<p>Возвращает 1, если левое значение больше или равно правому, иначе возвращает 0.</p>
<p>&gt;</p>
<p>Возвращает 1, если левое значение больше правого, иначе возвращает 0.</p>
<p>ORDER BY column [DESC][, column2 [DESC],...]</p>
<p>Сортирует возвращаемые данные по заданному столбцу (или столбцам). Если указать DESC, данные будут отсортированы в порядке убывания, иначе будет использована сортировка по возрастанию (например, SELECT name, age FROM people ORDER BY age DESC ).</p>
<p>value1 LIKE value2</p>
<p>Сравнивает valuel и value2 и возвращает 1, если они совпадают. Значение справа может содержать знак подстановки &#171; % &#187;, который заменяет любое количество символов (в том числе и отсутствие символа), и знак '_', замещающий в точности один символ. Это, возможно, наиболее употребительное в SQL сравнение. Чаще всего используется сравнение поля с некоторой строкой, содержащей знак подстановки (например, SELECT name FROM people WHERE name LIKE 'B%' ).</p>
<p>value1 RLIKE value2</p>
<p>Сравнивает valuel и value2, используя расширенный синтаксис регулярных выражений, и возвращает 1, если они совпадают. Значение справа может содержать полные подстановочные выражения и конструкции Unix (например, SELECT name FROM people WHERE name RLIKE '^В. *').</p>
<p>value1 CLIKE value2</p>
<p>Сравнивает value1 с value2, используя нечувствительную к регистру версию оператора LIKE (например, SELECT name FROM people WHERE name CLIKE 'b%' ).</p>
<p>Предложение WHERE возвращает все записи, для которых значение заданного выражения не равно 0 или NULL. Таким образом, SELECT age FROM people WHERE age&gt;10 вернет только те записи, где 'ages' больше 10.</p>
<p>Примеры<br>
<p>&nbsp;</p>
<p># Найти все имена (пате)в таблице 'people', у которых поле 'state' равно 'МI'. SELECT name FROM people WHERE state='MI' # Показать все данные из таблицы 'mytable'. SELECT * FROM mytable</p>
<p>UPDATE</p>
<p>UPDATE table SET column=value, . . . [WHERE clause]</p>
<p>Изменяет данные в таблице. Используется для обновления существующих данных, не изменяя саму таблицу.</p>
<p>Пример<br>
<p>&nbsp;</p>
<p># Изменить имя 'John Deo' на 'John Doe' во всей таблице 'people'.</p>
<pre name="code" class="sql"> UPDATE people SET name='John Doe' WHERE name='John Deo' 
</pre>

</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
