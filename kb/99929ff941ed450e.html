<!DOCTYPE html>
<html>
<head>
  <title>Алгоритм LZ-78</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Алгоритм LZ-78</h1>
<div id="date">01.01.2010</div>
Однако классический алгоритм Хаффмана обладает рядом недостатков. Во-первых, распаковщику для корректной работы необходима таблица кодов для символов, которую упаковщик строит в процессе сжатия. Следовательно, ее необходимо добавлять к сжатым данным, тем самым увеличивая размер заархивированного файла. Во-вторых, требуется два просмотра сжимаемого файла: первый для построения требуемой таблицы, а второй уже для сжатия. Избавиться от этих недостатков позволяет алгоритм адаптивного кодирования все по тому же Хаффману. Но о нем (если вас это заинтересует) мы поговорим позже. </p>
<p>В данной же статье мы рассмотрим идею, лежащую в основе алгоритмов семейства LZ-78 (L и Z - первые буквы фамилий Лемпеля и Зива, разработчиков первого LZ-алгоритма, 78 - год публикации) на примере широко известного алгоритма LZW (Лемпеля-Зива-Уэлча). Методы данного семейства относятся к словарным методам, в основе работы которых лежит принцип "повторения старого". Эти методы выделяют во входных данных повторяющиеся строки и заменяют их определенными кодами. Упомянутый же метод Хаффмана относится к статистическим методам, работающим по принципу "сокращения частого". </p>
<p>Итак, приступаем. Что нам понадобится для работы? Во-первых, данные, которые мы будем сжимать. Во-вторых, нам понадобится словарь, в котором мы будем хранить закодированные строки. Размер словаря выбирают равным целой степени двойки, обычно используют словари размером от 210 до 214 гнезд. В гнезда словаря мы будем заносить повторяющиеся строки, причем по номеру гнезда мы сразу сможем определить код данной строки (он будет равен номеру гнезда минус 1). Сразу отметим, что, хотя число кодов у нас равно размеру словаря, но для кодирования повторяющихся строк мы будем использовать на два кода меньше, поскольку последние два кода мы зарезервируем для служебных целей (о них поговорим чуть позже). После выбора размера словаря нам необходимо перед непосредственно архивированием провести инициализацию словаря, занеся в его первые гнезда все односимвольные строки. Их количество зависит от типа входных данных. В самом общем случае будут заполнены первые 256 гнезд словаря (т. е. в него мы занесем всю стандартную таблицу ASCII-символов). Но если известна особенность входных данных, предполагающая ограничение диапазона возможных символов, то количество инициализируемых гнезд может быть уменьшено. </p>
<p>Переходим теперь непосредственно к сжатию. Будем читать по одному символу входных данных, добавляя их в конец строки S (изначально пустой). При этом после каждого добавления будем проверять, есть ли полученная строка S в нашем словаре. В случае, если такая строка в словаре уже присутствует, то мы продолжим чтение входных данных. В противном случае (строки нет в словаре) выполняем следующие действия. Строку S можно представить в виде S'c, где c - последний добавленный символ, а S' - предшествующая ему строка, уже содержащаяся в словаре. Тогда в архив мы записываем код, соответствующий строке S', а в следующее пустое гнездо словаря добавляем строку S. После чего оставляем в строке S только последний прочитанный символ c и продолжаем процесс чтения входных данных. </p>
<p>Вот, в принципе, и весь алгоритм LZW. Упомянем еще о некоторых важных моментах. Если вы помните, мы зарезервировали два кода для служебных целей. Речь сейчас пойдет именно о них. Первый из этих кодов будем использовать в качестве признака завершения сжатия. При упаковке нескольких файлов в один архив необходимо по окончанию сжатия каждого файла записать данный код (иначе как распаковщик узнает, где заканчивается один файл и начинается другой?). Второй код - это код очистки словаря. Какого бы размера вы не взяли словарь, все равно найдутся такие данные, при сжатии которых словарь будет полностью заполнен в процессе архивирования. В этом случае можно либо "заморозить словарь" (т. е. прекратить добавлять в него новые строки), либо очистить его (записав в архив код очистки), причем можно очистить словарь как полностью (т. е. привести его в проинициализированное состояние), либо частично. </p>
<p>По такому принципу работает упаковщик. Вкратце опишем алгоритм работы распаковщика. После инициализации словаря (процессы инициализации у упаковщика и распаковщика должны быть полностью идентичны!) читается первый код из сжатых данных, и соответствующая ему строка выводится в разархивируемый файл. Следующие действия повторяются циклически до тех пор, пока не будет встречен признак завершения сжатия. Сохраняем прочитанный код как "старый". Читаем следующий код. Если такой код уже есть в словаре, то мы в разархивируемый файл выводим строку S, соответствующую этому коду, а в словарь добавляем строку вида S'K, где S' - это строка старого кода, а K - первый символ строки S. Если же в словаре прочитанного кода еще нет, то мы в разархивируемый файл выводим строку S'K' (K' - первый символ S') и эту же строку добавляем в словарь. </p>
<p>Ну ладно, хватит теории. Теория без практики мертва. Поэтому давайте рассмотрим на простеньком примере, как же работает алгоритм LZW. Возьмем, к примеру, текст "Мама мыла раму. Раму мыла мама". Словарь инициализируем всеми символами ASCII-таблицы, так что кодом для символа будет его порядковый номер в этой таблице. </p>
<p>Процесс сжатия представим таблицей (в третьем столбце в скобках указан номер гнезда, соответствующий строке S): </p>
<table>
<tr>
<td><p>Прочитанный символ</p>
</td>
<td><p>Строка S</p>
</td>
<td><p>Строка в словаре</p>
</td>
<td><p>Пишем в архив</p>
</td>
<td><p>Добавляем строку с кодом</p>
</td>
</tr>
<tr>
<td><p>'М'</p>
</td>
<td><p>'М'</p>
</td>
<td><p>есть (140)</p>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><p>'а'</p>
</td>
<td><p>'Ма'</p>
</td>
<td><p>нет</p>
</td>
<td><p>140</p>
</td>
<td><p>'Ма' 256</p>
</td>
</tr>
<tr>
<td><p>'м'</p>
</td>
<td><p>'ам'</p>
</td>
<td><p>нет</p>
</td>
<td><p>160</p>
</td>
<td><p>'ам' 257</p>
</td>
</tr>
<tr>
<td><p>'а'</p>
</td>
<td><p>'ма'</p>
</td>
<td><p>нет</p>
</td>
<td><p>172</p>
</td>
<td><p>'ма' 258</p>
</td>
</tr>
<tr>
<td><p>' '</p>
</td>
<td><p>'а '</p>
</td>
<td><p>нет</p>
</td>
<td><p>160</p>
</td>
<td><p>'а ' 259</p>
</td>
</tr>
<tr>
<td><p>'м'</p>
</td>
<td><p>' м'</p>
</td>
<td><p>нет</p>
</td>
<td><p>32</p>
</td>
<td><p>'м' 260</p>
</td>
</tr>
<tr>
<td><p>'ы'</p>
</td>
<td><p>'мы'</p>
</td>
<td><p>нет</p>
</td>
<td><p>172</p>
</td>
<td><p>'мы' 261</p>
</td>
</tr>
<tr>
<td><p>'л'</p>
</td>
<td><p>'ыл'</p>
</td>
<td><p>нет</p>
</td>
<td><p>235</p>
</td>
<td><p>'ыл' 262</p>
</td>
</tr>
<tr>
<td><p>'а'</p>
</td>
<td><p>'ла'</p>
</td>
<td><p>нет</p>
</td>
<td><p>171</p>
</td>
<td><p>'ла' 263</p>
</td>
</tr>
<tr>
<td><p>' '</p>
</td>
<td><p>'а '</p>
</td>
<td><p>есть (259)</p>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><p>'р'</p>
</td>
<td><p>'а р'</p>
</td>
<td><p>нет</p>
</td>
<td><p>259</p>
</td>
<td><p>'а р' 264</p>
</td>
</tr>
<tr>
<td><p>'а'</p>
</td>
<td><p>'ра'</p>
</td>
<td><p>нет</p>
</td>
<td><p>224</p>
</td>
<td><p>'ра' 265</p>
</td>
</tr>
<tr>
<td><p>'м'</p>
</td>
<td><p>'ам'</p>
</td>
<td><p>есть (257)</p>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><p>'у'</p>
</td>
<td><p>'аму'</p>
</td>
<td><p>нет</p>
</td>
<td><p>257</p>
</td>
<td><p>'аму' 266</p>
</td>
</tr>
<tr>
<td><p>'.'</p>
</td>
<td><p>'у.'</p>
</td>
<td><p>нет</p>
</td>
<td><p>227</p>
</td>
<td><p>'у.' 267</p>
</td>
</tr>
<tr>
<td><p>' '</p>
</td>
<td><p>'. '</p>
</td>
<td><p>нет</p>
</td>
<td><p>46</p>
</td>
<td><p>'. ' 268</p>
</td>
</tr>
<tr>
<td><p>'Р'</p>
</td>
<td><p>' Р'</p>
</td>
<td><p>нет</p>
</td>
<td><p>32</p>
</td>
<td><p>' Р' 269</p>
</td>
</tr>
<tr>
<td><p>'а'</p>
</td>
<td><p>'Ра'</p>
</td>
<td><p>нет</p>
</td>
<td><p>144</p>
</td>
<td><p>'Ра' 270</p>
</td>
</tr>
<tr>
<td><p>'м'</p>
</td>
<td><p>'ам'</p>
</td>
<td><p>есть (257)</p>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><p>'у'</p>
</td>
<td><p>'аму'</p>
</td>
<td><p>есть (266)</p>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><p>' '</p>
</td>
<td><p>'аму '</p>
</td>
<td><p>нет</p>
</td>
<td><p>266</p>
</td>
<td><p>'аму ' 271</p>
</td>
</tr>
<tr>
<td><p>'м'</p>
</td>
<td><p>' м'</p>
</td>
<td><p>есть (260)</p>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><p>'ы'</p>
</td>
<td><p>' мы'</p>
</td>
<td><p>нет</p>
</td>
<td><p>260</p>
</td>
<td><p>' мы' 272</p>
</td>
</tr>
<tr>
<td><p>'л'</p>
</td>
<td><p>'ыл'</p>
</td>
<td><p>есть (262)</p>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><p>'а'</p>
</td>
<td><p>'ыла'</p>
</td>
<td><p>нет</p>
</td>
<td><p>262</p>
</td>
<td><p>'ыла' 273</p>
</td>
</tr>
<tr>
<td><p>' '</p>
</td>
<td><p>'а '</p>
</td>
<td><p>есть (259)</p>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><p>'м'</p>
</td>
<td><p>'а м'</p>
</td>
<td><p>нет</p>
</td>
<td><p>259</p>
</td>
<td><p>'а м' 274</p>
</td>
</tr>
<tr>
<td><p>'а'</p>
</td>
<td><p>'ма'</p>
</td>
<td><p>есть (258)</p>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><p>'м'</p>
</td>
<td><p>'мам'</p>
</td>
<td><p>нет</p>
</td>
<td><p>258</p>
</td>
<td><p>'мам' 275</p>
</td>
</tr>
<tr>
<td><p>'а'</p>
</td>
<td><p>'ма'</p>
</td>
<td><p>есть (258)</p>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td><p>'.'</p>
</td>
<td><p>'ма.'</p>
</td>
<td><p>нет</p>
</td>
<td><p>258</p>
</td>
<td><p>'ма.' 276</p>
</td>
</tr>
<tr>
<td><p>конец данных</p>
</td>
<td><p>.</p>
</td>
<td>
</td>
<td><p>46</p>
</td>
<td><p>&nbsp;
</td>
</tr>
</table>
<p>И еще несколько слов. Во-первых, как можно заметить, строки, хранимые в словаре, обладают определенной особенностью: если в словаре есть строка S длины N, то должны быть также и строки длины 1, 2, ... , k, ... , N-1, состоящие из k первых символов строки S (таким образом, словарь у нас обладает свойством префиксности). Что же из этого следует? Во-первых, в словаре можно хранить строку S не полностью, а как указатель на строку, состоящую из первых N-1 символа строки S плюс последний символ, обеспечивающий ее уникальность. Во-вторых, данная особенность влияет на поиск строки в словаре. Так что когда мы ищем в словаре строку S длины N, то нам нет необходимости просматривать весь словарь. Мы начнем наш поиск со следующего за содержащим строку S' гнезда. Во-вторых, мы не сказали ни слова о размере нашего словаря. Давайте посмотрим, какие бы результаты сжатия у нас получились, если бы размер словаря был равен 1024 (210, 10-битовый код) или 8192 (212, 12-битовый код) гнезд. Длина нашего примера - 31 символ. Так как каждый символ кодируется 8 битами, то исходный текст должен был занимать 31*8=241 бит. В архив мы записали 23 кода (22 кода для строк, последний - признак окончания сжатия). Таким образом, в первом случае размер архива у нас будет 23*10=230 бит, а во втором - 23*12=276 бит. Что же получается - в первом случае мы действительно сжали текст, а во втором, наоборот, увеличили? Да, возможно и такое. Однако из этого не следует, что словарь нужно брать меньшего размера. Просто текст, взятый нами для примера, имел небольшую длину, да и повторяющиеся строки встречались не так уж и часто. Естественно, на больших объемах данных алгоритм все таки сожмет их. </p>
<p>Вот, в принципе, и все, что касается метода LZW. Отличие других методов семейства LZ-78 (среди них - MW, AP, Y) заключается в способе добавления новых строк в словарь. В частности, метод MW добавляет в словарь не строку S, как метод LZW, а конкатенацию строк S' и P' (S' - это подстрока строки S, уже имеющаяся в словаре, а P' - аналогичная строка для предыдущего добавления в словарь). Метод AP добавляет в словарь уже не одну строку, а множество строк AP(P',S'), т. е. все префиксы строки P'S'. </p>
<p><a href="http://delphiworld.narod.ru/" target="_blank">http://delphiworld.narod.ru/</a></p>
<p>DelphiWorld 6.0</p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
