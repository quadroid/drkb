<!DOCTYPE html>
<html>
<head>
  <title>WebSnap</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">WebSnap</h1>
<div id="date">01.01.2010</div>
<p>Итак, ура, мы добрались до новинок в Delphi 6. А именно, до набора компонентов, называемого WebSnap, находящихся на одноименной закладке в IDE Delphi. <br>
Технология WebSnap является дальнейшим развитием технологии WebBroker, еще более упрощающей разработку приложений для Web. Поддержка нескольких Web модулей делает возможной разделить труд по разработке приложения между несколькими разработчиками, возможность доступа к объектам модуля из скрипта, выполняемого на стороне сервера дает возможность &#171;оживить&#187; HTML страницы. Готовое приложение состоит из exe файла (или DLL в зависимости от формата приложения ) и набора файлов с HTML шаблонами страниц. Это позволяет вносить изменения в дизайн страниц без перекомпиляции проекта, а также разделить труд программиста и дизайнера. <br>
Для программиста приложение WebSnap представляет собой набор модулей, генерирующих информацию для отображения пользователю с помощью ряда компонентов.Модули делятся на два типа: <br>
1.Web Data Module &#8211; модуль для хранения компонентов общих для других модулей. В нем можно размещать невизуальные компоненты. Хорошая аналогия &#8211; модуль данных (Data Module) при разработке приложений баз данных. Данный модуль представляет собой просто хранилище компонентов. Содержимое его не отображается на этапе выполнения. <br>
2.Web Page Module &#8211; модуль страницы. Данный модуль представляет собой контейнер для размещения компонентов и генерации одной HTML(или XML) страницы приложения. В реализации модуля помимо файлов с расширением pas и xfm, традиционных для любого модуля в Delphi, присутствует файл с расширением html, в котором хранится шаблон HTML страницы для данного модуля. <br>
<p>Общая архитектура приложения представлена ниже: </p>
<img src="pic/clip0090.gif" width="557" height="457" border="0" alt="clip0090"></p>
<p>&nbsp;<br>
&nbsp;<br>
Назначение Web Request и Web Response тоже, что и в технологии Web Broker. Далее Page Dispatcher (диспетчер страниц) анализирует запрос и на основании пути запроса решает, какому модулю (Page module)он должен быть передан для дальнейшей обработки. Модуль генерирует запрошенную информацию, которая и отображается затем пользователю. Все гениальное просто. <br>
<p>Более подробная схема работы модуля страницы (Page Module) приведена ниже. HTML страница генерируется компонентом-продюсером на основании шаблона страницы. Шаблон страницы может содержать вставки со скриптами. Программист имеет возможность из скрипта обращаться к WebSnap компонентам приложения. Скрипт транслируется скриптовой машиной (Script Engine) в вызовы методов и свойств компонентов-адаптеров. Адаптеры являются мостом между приложением и скриптом в HTML странице. </p>
<img src="pic/clip0091.gif" width="510" height="334" border="0" alt="clip0091"></p>
<p>&nbsp;<br>
<p>Что касается компонентов, то все компоненты с закладки WebSnap, как и следует ожидать, можно разделить на: </p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Диспетчеры &#8211; компоненты, отвечающие за разбор запросов пользователя на получение информации и передачу этих запросов другим компонентам для генерации содержимого ответа и передачу запрошенной информации обратно клиенту. Представлены двумя компонентами. Первый PageDispatcher &#8211; его задача анализ HTTP запросов (см. схему выше). Второй AdapterDispatcher &#8211; его задача передача запросов адаптерам. </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Адаптеры &#8211; компоненты, позволяющие вам обращаться к свойствам объектов приложения из скриптового языка на стороне сервера, теги которого размещаются в тексте шаблона страницы. </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Продюсеры &#8211; компоненты, которые умеют генерировать динамическую информацию на основе заданного шаблона. </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Другие вспомогательные компоненты. </td></tr></table></div><p>Первый проект</p>
<p>А пока мы попробуем соорудить наш первый проект с использованием технологии WebSnap. Для этого выберем пункт меню File/New/Other в появившемся диалоге мы перейдем на закладку WebSnap. При этом мы увидим три пункта: WebSnap Application, WebSnap Data Module, WebSnap Page Module. Зачем нужен первый пункт, я думаю, вы догадались &#8211; он вызывает мастера создания WebSnap приложения. Второй пункт, WebSnap Data Module, позволяет добавить в проект модуль данных. Третий пункт WebSnap Page Module &#8211; для генерации заготовки модуля страницы. <br>
<p>Итак, выберем пункт WebSnap Application. При этом появится диалог мастера создания приложения WebSnap. </p>
<img src="pic/clip0092.gif" width="324" height="405" border="0" alt="clip0092"></p>
<p>&nbsp;<br>
Первая группа параметров Sever type позволяет выбрать формат приложения. Эти форматы были описаны в первой части статьи. Мы выберем формат CGI stand-alone executable. <br>
Вторая группа &#8211; Application Module Components предназначена для выбора компонентов, которые будут размещены в основном модуле приложения и вид данного модуля. Можно выбрать один из двух видов модулей: Page Module или Data Module. Назначение их было описано выше, отметим только, что слово Application в названии указывает на то, что модуль будет главным в приложении. Далее, нажав кнопку Components, мы увидим диалог выбора компонентов, которые будут размещены в модуле приложения. Пока мы не разобрались с назначением компонентов, мы оставим там все без изменений. <br>
<p>Третья группа параметров позволяет настроить параметры основного модуля приложения. Первый параметр Page Name позволяет указать имя страницы модуля (доступен лишь для типа модуля Page Module). Второй параметр Caching позволяет задать режим кэширования нашего приложения. По умолчанию параметр имеет значение Cache Instance, т.е разрешить кэширование. Второе возможное значение Destroy Instance отключает кэширование. Мы так же оставим данный параметр без изменения. Кнопка Page Options вызывает диалог настроек параметров модуля приложения, изображенный ниже. </p>
<img src="pic/clip0093.gif" width="321" height="337" border="0" alt="clip0093"></p>
<p>&nbsp;<br>
Рассмотрим этот диалог. Группа параметров Producer позволяет выбрать тип продюсера страницы (строка ввода Type) и скриптовый язык (JScript или VBasic). Вторая группа HTML позволяет указать шаблон для генерации HTML страницы. Третья группа параметров позволяет настроить параметры страницы имя, заголовок, видимость (параметр published) и необходимость аутентификации пользователя для просмотра данной страницы (параметр Login Required). Имя дублирует параметр Page Name предыдущего диалога. Опять же пока мы в данном диалоге оставим все без изменений. <br>
<p>Нажав кнопку ОК в обоих диалогах, мы получим заготовку приложения. Заготовка включает всего один модуль &#8211; Unit1. В нем содержится описание главного модуля приложения с именем PageProducerPage1. </p>
<img src="pic/clip0094.gif" width="215" height="295" border="0" alt="clip0094"></p>
<p>&nbsp;<br>
Теперь осталось сохранить и скомпилировать проект (Ctrl-F9) и полученный исполняемый файл и шаблон страницы Unit1.html разместить на Web сервере в директории для скриптов. Запустим Web броузер и в строке адреса наберем http://localhost/cgi-bin/Project1.exe (в случае использования Apache, для других Web серверов адрес может быть другим). В окне броузера мы увидим надпись PageProducerPage1 Поздравляю, Вы создали первое приложение WebSnap. После того как чепчики будут подброшены вверх, мы продолжим. <br>
<p>Взглянем на наш модуль, и попробуем разобраться, для чего служит каждый из размещенных в нем компонентов. </p>
<table>
<tr>
<td><p>Компонент </p>
</td>
<td><p>Назначение </p>
</td>
</tr>
<tr>
<td><p>TWebAppComponents </p>
</td>
<td><p>Содержит ссылки на другие компоненты, обеспечивающие функциональность приложения </p>
</td>
</tr>
<tr>
<td><p>ApplicationAdapter </p>
</td>
<td><p>Позволяет задать параметры приложения и позволяет обращаться к этим параметрам через глобальный объект Application в из скрипта на HTML странице </p>
</td>
</tr>
<tr>
<td><p>PageDispatcher </p>
</td>
<td><p>Диспетчер пользовательских запросов. Анализирует запросы пользователя и переадресует эти запросы, модулям, ответственным за их обработку. </p>
</td>
</tr>
<tr>
<td><p>AdapterDispatcher </p>
</td>
<td><p>AdapterDispatcher автоматически обрабатывает ввод данных из HTML форм, используя поля с информацией адаптера, расположенного в модуле. </p>
</td>
</tr>
<tr>
<td><p>PageProducer </p>
</td>
<td><p>Генерирует HTML страницу по заданному шаблону 
</td>
</tr>
</table>
<p>&nbsp;<br>
&nbsp;<br>
<p>Для доработки нашей страницы, мы установим свойство Title компонента ApplicationAdapter равным &#171;Заголовок нашего приложения&#187;. А теперь сюрприз, сгенерированная HTML страница может быть просмотрена без переноса приложения на Web сервер. Для этого всего лишь необходимо выбрать закладку &#171;Preview&#187; в нижней части окна редактирования. </p>
<img src="pic/clip0095.gif" width="457" height="55" border="0" alt="clip0095"></p>
<p>&nbsp;<br>
Для этого понадобится нажать кнопку с изображением стрелки указывающей вправо. Визуализация страниц может значительно ускорить разработку Web приложений. Другая закладка Unit1.html &#8211; содержит текст шаблона страницы &#8211; вы можете сделать страничку более симпатичной, правда, в среде разработки Вам она может отображаться не совсем так, как должна (например, я подправил цвет фона страницы, однако в IDE фон продолжал оставаться белым). <br>
Двигаемся далее, как уже вскользь упоминалось, приложение WebSnap может содержать (и в реальных проектах содержит ) несколько модулей страниц. Добавим новый модуль страницы в наше приложение. Идем в пункт меню File/New/Other и на закладке диалога, перейдя на закладку Web Snap, выбираем элемент WebSnap Page Module. Нашему вниманию будет представлен диалог выбора параметров модуля. Назначение параметров мы уже рассмотрели. Нажав кнопку ОК, мы получим модуль страницы с именем PageProducerPage2. Теперь, если мы скомпилируем наше приложение, и разместим его на Web севере (для этого необходимо скопировать файлы Unit1.html, Unit2.html, Project1.exe в папку для скриптов на сервере) в окне браузера мы увидим, что вверху страницы ниже заголовка появилась панель навигации по страницам нашего приложения. Сразу возникает вопрос, а как она появилась, ведь мы ничего не делали для ее генерации? Ответ кроется в файле Unit1.html. Трудно не заметить, что помимо тегов HTML страница содержит теги &lt;% %&gt;, внутри которых расположены операторы скриптового языка. Данные операторы выполняются на стороне сервера, результат их работы вставляется в страницу, отсылаемую клиенту. Из скриптов можно обращаться к большинству компонентов, расположенных в модулях. Это вносит замечательную гибкость и открывает большие возможности для создания сложных динамических страниц. <br>
Текст скрипта необходимо заключать в тег &lt;% %&gt;. В качестве скриптовых языков могут применяться JScript и VBScript. Мы будем использовать JScript. Теперь становится ясно, что функция: <br>
&lt;% e = new Enumerator(Pages) <br>
s = '' <br>
c = 0 <br>
for (; !e.atEnd(); e.moveNext()) <br>
{ <br>
if (e.item().Published) <br>
{ <br>
if (c&gt;0) s += ' | ' <br>
if (Page.Name != e.item().Name) <br>
s += '&lt;a href="' + e.item().HREF + '"&gt;' + e.item().Title + '&lt;/a&gt;' <br>
else <br>
s += e.item().Title <br>
c++ <br>
} <br>
} <br>
if (c&gt;1) Response.Write(s) <br>
%&gt; <br>
в файле Unit1.html генерирует панель навигации. Текст функции достаточно понятен, некоторые комментарии необходимы лишь для последнего оператора Response.Write &#8211; данный оператор выводит строку с результатом работы скрипта в HTML файл страницы. Есть еще один способ это использование тега &lt;%= %&gt;. Пример можно увидеть в том же Unit1.html: <br>
&lt;%= Application.Title %&gt; <br>
<p>В результате работы этого скрипта на страницу выводится ее заголовок. </p>
<p>&nbsp;<br>
<p>Использование TAdapter</p>
<p>Адаптеры предназначены для хранения различных параметров и процедур и предоставляют возможность обращаться к ним из скрипта. На странице WebSnap содержит несколько видов адаптеров. Наиболее неспециализированным из них является адаптер класса TAdapter. <br>
Параметры адаптера хранятся в так называемых полях (AdapterFields). На самом деле, поля TAdapter представляют программисту возможность задать обработчики для получения значения поля и других его параметров. TAdapter имеет свойство Data для хранения и управления своими полями. Процедуры (Actions) позволяют вызывать из скрипта выполнение каких-либо действий для управления ими TAdapter содержит свойство Actions. <br>
Рассмотрим пример создания страницы для ввода имени пользователя. Поместим компонент TAdapter в наш модуль PageModule2. Определим поле, которое будет возвращать имя пользователя. Для этого из инспектора объектов вызовем редактор свойства Data нашего адаптера Adapter1. В редакторе нажмем кнопку New Item, нам будет предложен диалог выбора типа поля. Мы выберем тип AdapterField, т.к он наиболее подходит для хранения небольших строк. В диалоге при этом появится элемент AdapterField1, соответствующий нашему полю. Выберем его. Теперь в инспекторе объектов перейдем на закладку Events и определим текст обработчик события OnGetValue. Данное событие возникает каждый раз, когда требуется узнать значение поля. Затребованное значение поля необходимо возвращать через параметр Value, передаваемый в обработчике. Код обработчика: <br>
Value:=FValue; <br>
FValue здесь переменная, в которой мы будем запоминать значение поля AdapterField1, необходимо определить эту переменную в секции public декларации TPageProducerPage2 как <br>
FValue:String; <br>
Для инициализации значения FValue в обработчике события OnCreate нашего модуля введем код: <br>
FValue:=&#8217;Неизвестный человек&#8217;; <br>
Теперь мы можем получать доступ к данному полю из скрипта. Для начала мы попробуем выводить значение поля пользователю. Для этого в код шаблона HTML страницы Unit2.html надо добавить после закрывающегося тега &lt;/table&gt; следующий код: <br>
&nbsp;<br>
&lt;BR&gt;&lt;BR&gt; <br>
Добрый день, уважаемый &lt;%=Adapter1.AdapterField1.DisplayText%&gt;. <br>
&nbsp;<br>
Скомпилировав проект и поместив его на Web сервер, мы на странице PageProducerPage2 увидим внизу страницы надпись &#171;Добрый день, уважаемый Неизвестный человек&#187;. <br>
<p>Далее создадим процедуру (action) для изменения значения имени пользователя. В инспекторе объектов вызовем редактор свойства Actions, и нажав кнопку New Item из появившегося диалога выберем тип процедуры AdapterAction. Будет создана новая процедура - AdapterAction1. В инспекторе объектов установим следующие свойства для процедуры: </p>
<table>
<tr>
<td><p>Свойство </p>
</td>
<td><p>Значение </p>
</td>
<td><p>Описание </p>
</td>
</tr>
<tr>
<td><p>DisplayLabel </p>
</td>
<td><p>OK </p>
</td>
<td><p>Текст для отображения в HTML шаблоне </p>
</td>
</tr>
<tr>
<td><p>ActionName </p>
</td>
<td><p>GetNameAction1 </p>
</td>
<td><p>Имя процедуры для использования в скриптах 
</td>
</tr>
</table>
<p>&nbsp;<br>
&nbsp;<br>
Осталось написать код обработчика события OnExecute нашей процедуры: <br>
FValue:=AdapterField1.ActionValue.Values[0]; <br>
&nbsp;<br>
Данная строка сохраняет значение поля AdapterField1 в переменную FValue. Чтобы дать пользователю возможность вводить свое имя в текст Unit2.html (после строки &#8220;Добрый день &#8230;&#8230;&#8221;) добавим определение формы ввода: <br>
&nbsp;<br>
&lt;FORM NAME="INPUT_NAME_FORM" METHOD=POST&gt; <br>
&lt;INPUT TYPE=HIDDEN NAME="__action" VALUE = "&lt;%=Adapter1.GetNameAction1.AsFieldValue%&gt;"&gt; <br>
Ваше имя: <br>
&lt;INPUT TYPE=INPUT VALUE="&lt;%=Adapter1.AdapterField1.EditText%&gt;" NAME= "&lt;%=Adapter1.AdapterField1.InputName%&gt;"&gt; <br>
&nbsp;<br>
&lt;INPUT TYPE=SUBMIT VALUE="&lt;%=Adapter1.GetNameAction1.DisplayLabel%&gt;" onclick="'INPUT_NAME_FORM.__action.value=&lt;%=Adapter1.GetNameAction1.AsFieldValue%&gt;'"&gt; <br>
&lt;/FORM&gt; <br>
&nbsp;<br>
Скомпилируем проект, перенесем его на Web сервер &#8211; поприветствуем себя J. <br>
PagedAdapter отличается тем, что позволяет разделить большой объем информации на страницы. Размер информации, размещаемой на одной странице, задается в свойстве PageSize. <br>
&nbsp;<br>
Парольный доступ к странице <br>
Очень часто требуется обеспечить ограничение доступа к определенным страницам приложения. Одним из методов решения данной задачи является парольная защита. Технология WebSnap позволяет реализовать доступ к страницам по паролю. <br>
<p>Для поддержки парольного доступа в главном модуле должны присутствовать следующие компоненты: </p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Компонент TWebUserList, который содержит список пользователей, их паролей и прав доступа </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Компонент TSessionsService, который содержит информацию о пользователях, использующих приложение в данный момент. </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Компонент TEndUserSessionAdapter, который обрабатывает события подключения пользователя </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Добавить эти компоненты можно либо на этапе создания модуля страницы в диалоге Web App Components </td></tr></table></div><img src="pic/clip0096.gif" width="399" height="381" border="0" alt="clip0096"></p>
<p>&nbsp;<br>
либо поместить их самостоятельно в уже созданный модуль. Мы воспользуемся вторым способом и обеспечим парольную защиту страницы PageProducerPage2. Разместим в модуле PageProducerPage1 вышеуказанные компоненты. Для свойства UserItems WebUserList1 из инспектора объектов вызовем редактор и введем двух пользователей, которым будет позволен доступ к странице: Mike с паролем 123 и admin с паролем admin. <br>
Следующий шаг &#8211; указать необходимость парольной защиты страницы, если это не было сделано на этапе создания модуля. Для этого в конце файла Unit2.pas, содержащим описание PageProducerPage2, найдем в конце секцию: <br>
&nbsp;<br>
initialization <br>
if WebRequestHandler &lt;&gt; nil then <br>
WebRequestHandler.AddWebModuleFactory(TWebPageModuleFactory.Create(TPageProducerPage2, TWebPageInfo.Create([wpPublished {, wpLoginRequired}], '.html'), crOnDemand, caCache)); <br>
и раскомментируем фрагмент &#8220;,wpLoginRequierd&#8221;. Кроме того, здесь можно исправить еще одну вещь, правда не относящуюся к парольной защите, а именно сделать отображение русских названий страниц в панели навигации. Для этого необходимо в конструкторе TWebPageInfo добавить параметр с русским названием страницы. Таким образом секция initialization будет выглядеть теперь так: <br>
&nbsp;<br>
initialization <br>
if WebRequestHandler &lt;&gt; nil then <br>
WebRequestHandler.AddWebModuleFactory(TWebPageModuleFactory.Create(TPageProducerPage2, TWebPageInfo.Create([wpPublished , wpLoginRequired], '.html','PageProducerPage2','Страница с паролем'), crOnDemand, caCache)); <br>
&nbsp;<br>
Теперь нужно сделать страничку для ввода имени и пароля пользователя. Наиболее простым представляется воспользоваться для этого компонентом AdapterPageProducer. Итак, как обычно, идем в меню File/New/Other. Выбираем закладку WebSnap и элемент WebSnap Page Module. В диалоге параметров страницы изменяем тип продюсера с PageProducer на AdapterPageProducer, а также снимаем флажок Published, т.к по умолчанию страница для ввода пароля не должна отображаться в панели навигации. В результате мы получим модуль страницы с единственным компонентом AdapterPageProducer. <br>
Компонент AdapterPageProducer представляет собой специализированный продюсер, позволяющий генерировать HTML страницы для отображения полей адаптеров. Принцип создания страницы в AdapterPageProducer1 очень прост. Весь документ представляет набор web компонентов, которые программист добавляет в редакторе, а с помощью инспектора объектов при необходимости настраивает их свойства и события. Web компоненты могут быть вложены один в другой. Все это позволяет комфортно и быстро проектировать HTML документы. <br>
<p>В качестве адаптера для обеспечения доступа к имени пользователя и его паролю мы используем компонент класса LoginFormAdapter1, который необходимо добавить в модуль. Далее двойным кликом мыши на компоненте AdapterPageProducer вызовем визуальный редактор HTML страницы. В нем нажмем кнопку New Item и добавим Web компонент типа AdapterForm, т.е HTML форму. Далее, еще раз нажав кнопку New Item ( при выбранном Web компоненте AdapterForm1 ) и добавим Web компонент типа AdapterFieldGroup, т.е набор полей для редактирования полей адаптера. Для AdapterFieldGroup1 установим свойство Adapter равным LoginFormAdapter1, таким образом указав поля какого адаптера мы будем отображать. Далее выберем web компонент AdapterForm1, еще раз нажмем кнопку New Item и добавим web компонент типа AdapterCommandGroup, т.е набор кнопок для вызова процедур адаптера. Для web компонента AdapterCommandGroup зададим свойство DisplayComponent равным AdapterFieldGroup1. Результат наших трудов представлен на рисунке ниже: </p>
<img src="pic/clip0097.gif" width="304" height="397" border="0" alt="clip0097"></p>
<p>&nbsp;<br>
Остался последний шаг, перейти в модуль PageProducderPage1(т.е главную страницу) указать в свойстве LoginPage компонента EndUserSessionAdapter1 значение AdapterPageProducerPage3. <br>
Все можно компилировать наш шедевр и переносить на web сервер. Смотрим, что получается &#8211; вверху страницы появилась ссылка с текстом Login. Выбираем, вводим имя и пароль, в качестве следующей страницы указываем &#8220;Страница с паролем&#8221;, жмем кнопку Login. Что не работает, не попадаем мы на указанную страницу? Аналогично. Ну, хорошо, тогда в среде Delphi создадим новый проект WebSnap приложения, но в качестве формата выберем не CGI, а WebDebug. В созданный проект подключим те же модули, предварительно удалив сгенерированный мастером главный модуль. Запустим, надо же работает. Парадокс? Ошибка разработчиков? Влияние злых инопланетных пришельцев? Именно такие мысли посещали и меня, пока я внимательно не прочел документацию. Все оказалось просто. Для хранения информации о том авторизован пользователь или нет используется SessionService. Он сохраняет эту информацию в памяти приложения, посему приложение должно быть запущено между запросами пользователя. В случае CGI этого не происходит, т.к протокол построен таким образом, что после обработки одного запроса приложение выгружается. Это и есть причина неработоспособности нашего примера в формате CGI. <br>
<p>Еще одним важным моментом является то, что пользователей в WebUserList мы добавляли на этапе разработки. Однако при этом отсутствует возможность управлять списком пользователей вне IDE. Решением данной проблемы является хранения списка пользователей во внешнем файле. Компонент WebUserList имеет метод SaveToFile для сохранения списка пользователей в файл и метод LoadFromFile для загрузки данных о пользователях из файла. При этом формат файла &#8211; текстовый, а пароли хранятся в открытом виде. Поэтому администратору сайта необходимо предпринимать дополнительные меры по ограничению доступа к файлу с данными пользователей. </p>
<p>Работа с базами данных</p>
<p>Современные базы данных представляют возможность хранить и обрабатывать большие объемы информации. Возможность работы с базами данных на сегодняшний день является просто необходимым атрибутом любого средства разработки приложений для Web. Технология WebSnap в этом смысле не стала исключением, т.к она предоставляет достаточно продуманные и удобные средства публикации содержимого БД, а в соединении с описанной в первой части статьи технологией Internet Express позволяет строить приложения для работы с БД, удовлетворяющие запросам самых привередливых пользователей. <br>
Итак, попробуем спроектировать страничку для отображения содержимого таблицы базы данных. В качестве таковой будет использована таблица biolife.db (BDE alias) из примеров, поставляемых с Delphi. <br>
<p>Опубликовать данные можно несколькими способами. На мой взгляд для вывода информации наиболее удобно использовать компонент-пробюсер AdapterPageProducer в сочетании с адаптером DataSetAdapter. Добавим в проект новый модуль страницы (при добавлении не забудьте указать тип пробюсера AdapterPageProducer). В полученный модуль добавим DataSetAdapter. Также добавим компоненты доступа к данным TTable и TSession. Установим свойства компонентов следующим образом: </p>
<table>
<tr>
<td><p>Свойство </p>
</td>
<td><p>Значение </p>
</td>
<td><p>Назначение свойства </p>
</td>
</tr>
<tr>
<td colspan="3" ><p>Session1 </p>
</td>
</tr>
<tr>
<td><p>AutoSessionName </p>
</td>
<td><p>True </p>
</td>
<td><p>Автоматическое присвоение имени новой сессии * </p>
</td>
</tr>
<tr>
<td colspan="3" ><p>TTable </p>
</td>
</tr>
<tr>
<td><p>SessionName </p>
</td>
<td><p>Session1_1 </p>
</td>
<td><p>Имя сессии * </p>
</td>
</tr>
<tr>
<td><p>DatabaseName </p>
</td>
<td><p>DBDEMOS </p>
</td>
<td><p>Псевдоним базы данных * </p>
</td>
</tr>
<tr>
<td><p>TableName </p>
</td>
<td><p>biolife.db </p>
</td>
<td><p>Таблица базы данных </p>
</td>
</tr>
<tr>
<td><p>Active </p>
</td>
<td><p>True </p>
</td>
<td><p>Активность (доступность данных) таблицы </p>
</td>
</tr>
<tr>
<td colspan="3" ><p>DataSetAdapter1 </p>
</td>
</tr>
<tr>
<td><p>DataSet </p>
</td>
<td><p>Table1 </p>
</td>
<td><p>Компонент, предоставляющий данные из БД для адаптера 
</td>
</tr>
</table>
<p>&nbsp;<br>
* - необходимость установки обусловлена особенностями BDE <br>
&nbsp;<br>
<p>После вышеперечисленных действий, двойным кликом мыши на компоненте AdapterPageProducer1, вызовем редактор для построения HTML страницы. Нажмем в редакторе кнопку New Item и добавим web компонент AdapterForm, далее на AdapterForm1 той же кнопкой добавим AdapterFieldGroup для отображения информации из полей таблицы. В инспекторе объектов свойство Adapter установим равным DataSetAdapter1. Следующим web компонентом, который мы добавим на AdapterForm1будет AdapterCommandGroup, в котором будут отображаться кнопки навигации по таблице. Свойство DisplayComponent установим равным AdapterFieldGroup1. Все в первом приближении страничка готова. Результат представлен ниже. </p>
<img src="pic/clip0098.gif" width="542" height="420" border="0" alt="clip0098"></p>
<p>&nbsp;<br>
<p>На этом мы закончим в данной статье рассмотрение возможностей технологии WebSnap. В приведенных примерах содержится лишь демонстрация основных возможностей новой технологии. Я не претендую на полноту освещения вопроса, к сожалению в одной статье не возможно рассказать обо всех нюансах. Для получения дополнительной информации обратитесь к документации и примерам, поставляемым с Delphi. </p>
<p>WEBSnap vs WEBBroker</p>
<p>Ниже в таблице приведены основные отличия технологий друг от друга: </p>
<table>
<tr>
<td><p>Web Broker </p>
</td>
<td><p>WebSnap </p>
</td>
</tr>
<tr>
<td><p>Обратно совметима </p>
</td>
<td><p>Можно использовать любой из продюсеров WebBroker </p>
</td>
</tr>
<tr>
<td><p>Реализована для CLX, поддерживается в Kylix </p>
</td>
<td><p>На сегодня реализация доступна только для Windows. Хотя Borland уже заявила о том, что технология будет перенесена в Kylix </p>
</td>
</tr>
<tr>
<td><p>В приложении может быть лишь один Web модуль </p>
</td>
<td><p>Поддержка нескольких модулей делает возможным распределение работы между несколькими разработчиками </p>
</td>
</tr>
<tr>
<td><p>В приложении может быть лишь один продюсер. </p>
</td>
<td><p>Несколько специализированных диспетчеров могут обрабатывать каждый свой вид запроса </p>
</td>
</tr>
<tr>
<td><p>Нет поддержки скриптов </p>
</td>
<td><p>Поддержка скриптов на стороне сервера (JScript или VBScript) </p>
</td>
</tr>
<tr>
<td><p>Нет встроенной поддержки именования страниц </p>
</td>
<td><p>Возможно обращаться из скриптов к объектам, содержащим свойства страниц </p>
</td>
</tr>
<tr>
<td><p>Нет встроенной поддержки сессий </p>
</td>
<td><p>Поддержка сессий иммется, что позволяет легко реализовать идентификацию пользователя при доступе к страницам </p>
</td>
</tr>
<tr>
<td><p>Только несколько компонентов позволяют визуализировать процесс разработки. Процесс разработки в основном невизуален </p>
</td>
<td><p>WebSnap дизайнер позволяет строить Web страницы с возможностью немедленного предпросмотра результата в IDE 
</td>
</tr>
</table>
<p id="author">Автор статьи: Mike Goblin </p>
<p><a href="http://www.delphimaster.ru" target="_blank">http://www.delphimaster.ru</a></p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
