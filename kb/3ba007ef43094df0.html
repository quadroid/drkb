<!DOCTYPE html>
<html>
<head>
  <title>Моя собственная база данных</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Моя собственная база данных</h1>
<div id="date">01.01.2010</div>

<p>(Перевод одноимённой статьи с сайта delphi.about.com)</p>
<p>В статье рассматривается работа с бинарными файлами из Delphi, а так же использование Object Pascal для управления записью, чтением и изменением собственных типов файлов.</p>
<p>Постановка задачи: Допустим, мне нужно в приложении Delphi сохранять некоторую информацию на диск. Мне не охото работать с текстовыми файлами, так как просмотр и обновление информации в них довольно муторное занятие. Преобладать будут операции записи и чтения, в то время как операции изменения и апдейта будут присутствовать в меньшей степени. Вся информация будет хранится в переопределённом типе данных Pascal Record. Итак, какой подход мне лучше всего использовать?</p>
<p>BDE плюс Paradox или Access, ... спасибо, не надо... Не хотелось бы испытывать мороку с BDE. Использовать текстовые файлы ASCII? Не пойдёт. Нужна хоть какая-то минимальная защита, а текстовые файлы "полностью видимы". Оказывается, ответ на данный вопрос кроется в Delphi, а именно в непечатных файлах (или файлы некоторых типов/бинарные файлы).</p>
<p><b>Файлы</b></p>
<p>В Delphi существует три класса файлов: typed, text, и untyped. Файлы typed - это файлы, которые содержат данные определённого типа, такие как Double, Integer или предварительно определённый тип Record. Текстовые файлы содержат читаемые символы ASCII. Файлы Untyped используются в том случае, если мы хотим работать с файлом через определённую структуру.</p>
<p><b>Файлы Typed</b></p>
<p>В отличие от тектовых файлов, которые содержат строки, завершающиеся комбинацией CR/LF, файлы typed содержат данные, взятые из определённой структуры данных.</p>
<p>Например, следующее объявление создаёт запись с именем TMember и массив переменных типа TMember, который мы будем использовать для хранения нашей информации.</p>
<pre name="code" class="delphi">
type
  TMember = record
    Name : string[50];
    eMail : string[30];
    Posts : LongInt;
  end;
 
 var Members : array[1..50] of TMember;
</pre>

<p>Перед тем, как мы сможем записать информацию на диск, нам необходимо объявить переменную типа file. Следующая строка объявляет переменную файла F:</p>

<pre name="code" class="delphi">var F: file of TMember;</pre>

<p>Обратите внимание: Чтобы создать файл typed в Delphi, мы используем следующий синтакс:</p>
<pre name="code" class="delphi">var SomeTypedFile: file of SomeType;</pre>
<p>Базовый тип&nbsp; (SomeType) для файла может быть скалярным (наподобие Double), массивом или записью. Он не может быть длинной строкой, динамическим массивом, классом, объектом или указателем.</p>
<p>Чтобы начать работать с файлом из Delphi нам надо связать файл на диске с переменной файла в нашей программе. Для этого используем процедуру AssignFile.</p>

<pre name="code" class="delphi">AssignFile(F, 'Members.dat')</pre>

<p>Как только связь с внешним файлом установлена, переменную F необходимо 'открыть' для подготовки её к чтению или записи. Для открытия существующего файла мы используем процедуру Reset либо Rewrite для создания нового файла. После того, как программа закончит обработку файла, его необходимо закрыть при помощи процедуры CloseFile. Сразу после закрытия файла, связанный с ним внешний файл будет обновлён. Затем переменную файла можно связать с другим внешним файлом. Вообще, мы должны всегда производить обработку исключительных ситуаций, так как при работе с файлами может происходить довольно много ошибок. Например, если мы вызовем CloseFile для файла, который уже закрыт, то Delphi выдаст ошибку I/O. С другой стороны, если мы попробуем закрыть файл, до вызова AssignFile, то результаты могут быть непредсказуемыми.</p>
<p><b>Запись</b></p>
<p>Предположим, что у нас есть массив, заполненный именами, e-мейлами и т.д., и мы хотим сохранить эту информацию на диск. Делается это следующим образом: </p>

<pre name="code" class="delphi">
var F : file of TMember;
begin
  AssignFile(F,'members.dat');
  Rewrite(F);
  try
    for i:= 1 to 50 do
      Write (F, Members[i]);
  finally
    CloseFile(F);
  end;
end;
</pre>

<p><b>Чтение</b></p>
<p>Для получения всей информации из файла 'members.dat' используется следующий код:</p>

<pre name="code" class="delphi">
var Member: TMember
  F: file of TMember;
begin
  AssignFile(F,'members.dat');
  Reset(F);
  try
    while not Eof(F) do
    begin
      Read(F, Member);
      {Что-нибудь делаем с данными;}
    end;
  finally
    CloseFile(F);
  end;
end;
</pre>

<p>Обратите внимание: Eof это функция проверки конца файла (EndOfFile). Мы используем эту функцию, чтобы не выйти за пределы файла (за пределы последней, сохранённой записи).</p>
<p><b>Поиск и позиционирование</b></p>
<p>Обычно, доступ к файлам осуществляется последовательно. При чтении из файла (используя стандартную процедуру Read) или при записи (используя стандартную процедуру Write), текущая позиция в файле перемещается на следующий по порядку компонент (следующая запись). К файлам typed так же можно обращаться через стандартную процедуру Seek, которая перемещает текущую позицию в файле на указанный компонент. Для определения текущей позиции в файле и размера файла можно использовать функции FilePos и FileSize.</p>

<pre name="code" class="delphi">
{устанавливаем на начало - на первую запись}
Seek(F, 0);

{устанавливаем на 5-ю запись}
Seek(F, 5);

{Переходим в конец - "после" последней записи}
Seek(F, FileSize(F));
</pre>

<p><b>Изменение и обновление</b></p>
<p>Мы разобрались как записывать и считывать из файла массив Members. А что, если нам нужно найти десятую запись и изменить в ней e-mail? Давайте посмотрим на процедуру, которая делает это:</p>

<pre name="code" class="delphi">
procedure ChangeEMail(const RecN: Integer; const NewEMail: string);
var
  DummyMember: TMember;
begin
  {связывание, открытие, блок обработки исключений}
  Seek(F, RecN);
  Read(F, DummyMember);
  DummyMember.Email := NewEMail;
  {чтение перемещается на следующую запись, для этого необходимо
  вернуться на первоначальную запись, а затем записать}
  Seek(F, RecN);
  Write(F, DummyMember);
  {закрываем файл}
end;
</pre>

<p><b>Всё готово</b></p>
<p>Итак, теперь мы имеем всё, что нам нужно для реализации нашей задачи. Мы можем записать информацию на диск, считать её, и даже изменить некоторые данные (например, e-mail) в "середине" файла.</p>
<p>Взято из <a href="http://forum.sources.ru" target="_blank">http://forum.sources.ru</a></p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
