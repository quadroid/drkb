<!DOCTYPE html>
<html>
<head>
  <title>Интерфейс переноса Drag &amp; Drop</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Интерфейс переноса Drag &amp; Drop</h1>
<div id="date">01.01.2010</div>
<p>Интерфейс переноса и приема компонентов появился достаточно давно. Он обеспечивает взаимодействие двух элементов управления во время выполнения приложения. При этом могут выполняться любые необходимые операции. Несмотря на простоту реализации и давность разработки, многие программисты (особенно новички) считают этот механизм малопонятным и экзотическим. Тем не менее использование Drag-and-Drop может оказаться очень полезным и простым в реализации. Сейчас мы в этом убедимся. </p>
<p>Для того чтобы механизм заработал, требуется настроить соответствующим образом два элемента управления. Один должен быть источником (Source), второй &#8212; приемником (Target). При этом источник никуда не перемещается, а только регистрируется в качестве такового в механизме. </p>
<p id="note">Примечание:</p>
<p>Один элемент управления может быть одновременно источником и приемником. </p>
<p>Пользователь помещает указатель мыши на нужный элемент управления, нажимает левую кнопку мыши и, не отпуская ее, начинает перемещать курсор ко второму элементу. При достижении этого элемента пользователь отпускает кнопку мыши. В этот момент выполняются предусмотренные разработчиком действия. При этом первый элемент управления является источником, а второй &#8212; приемником. </p>
<p>После выполнения настройки механизм включается и реагирует на перетаскивание мышью компонента-источника в приемник. Группа методов-обработчиков обеспечивает контроль всего процесса и служит для хранения исходного кода, который разработчик сочтет нужным связать с перетаскиванием. Это может быть передача текста, значений свойств (из одного редактора в другой можно передать настройки интерфейса, шрифта и сам текст); перенос файлов и изображений; простое перемещение элемента управления с места на место и т. д. Пример реализации Drag-and-Drop в Windows &#8212; возможность переноса файлов и папок между дисками и папками. </p>
<p>Как видите, можно придумать множество областей применения механизма Drag-and-Drop. Его универсальность объясняется тем, что это всего лишь средство связывания двух компонентов при помощи указателя мыши. А конкретное наполнение зависит только от фантазии программиста и поставленных задач. </p>
<p>Весь механизм Drag-and-Drop реализован в базовом классе TControl, который является предком всех элементов управления. Рассмотрим суть механизма. </p>
<p>Любой элемент управления из Палитры компонентов Delphi является источником в механизме Drag-and-Drop. Его поведение на начальном этапе переноса зависит от значения свойства </p>
<pre name="code" class="delphi">
type TDragMode = (dmManual, dmAutomatic);
 
property DragMode: TDragMode;
</pre>
<p>Значение dmAutomatic обеспечивает автоматическую реакцию компонента на нажатие левой кнопки мыши и начало перетаскивания &#8212; при этом механизм включается самостоятельно. </p>
<p>Значение dmManual (установлено по умолчанию) требует от разработчика обеспечить включение механизма вручную. Этот режим используется в том случае, если компонент должен реагировать на нажатие левой кнопки мыши как-то иначе. Для инициализации переноса используется метод </p>
<p>procedure BeginDrag(Immediate: Boolean; Threshold: Integer = -1);</p>
<p>Параметр immediate = True обеспечивает немедленный старт механизма. При значении False механизм включается только при перемещении курсора на расстояние, определенное параметром Threshold. </p>
<p>О включении механизма сигнализирует указатель мыши &#8212; он изменяется на курсор, определенный в свойстве </p>
<p>property DragCursor: TCursor;</p>
<p>Еще раз напомним, что источник при перемещении курсора не изменяет собственного положения, и только в случае успешного завершения переноса сможет взаимодействовать с приемником. </p>
<p>Приемником может стать любой компонент, в котором создан метод-обработчик </p>
<pre name="code" class="delphi">
procedure DragOver(Source: TObject; X, Y: Integer;
  State: TDragState; var Accept: Boolean);
</pre>
<p>Он вызывается при перемещении курсора в режиме Drag-and-Drop над этим компонентом. В методе-обработчике можно предусмотреть селекцию источников переноса по нужным атрибутам. </p>
<p>Если параметр Accept получает значение True, то данный компонент становится приемником. Источник переноса определяется параметром source. Через этот параметр разработчик получает доступ к свойствам и методам источника. Текущее положение курсора задают параметры X и Y. Параметр state возвращает информацию о характере движения мыши: </p>
<p>type TDragState = (dsDragEnter, dsDragLeave, dsDragMove);</p>
<p>dsDragEnter &#8212; указатель появился над компонентом; dsDragLeave &#8212; указатель покинул компонент; dsDragMove &#8212; указатель перемещается по компоненту. </p>
<p>Приемник должен предусматривать выполнение некоторых действий в случае, если источник завершит перенос именно на нем. Для этого используется метод-обработчик </p>
<pre name="code" class="delphi">
type TDragDropEvent = procedure(Sender, Source: TObject;
    X, Y: Integer) of object;
 
property OnDragDrop: TDragDropEvent;
</pre>
<p>который вызывается при отпускании левой кнопки мыши на компоненте-приемнике. Доступ к источнику и приемнику обеспечивают параметры Source и Sender соответственно. Координаты мыши возвращают параметры X и Y. </p>
<p>При завершении переноса элемент управления &#8212; источник &#8212; получает соответствующее сообщение, которое обрабатывается методом </p>
<p>type TEndDragEvent = procedure(Sender, Target: TObject;</p>
<p>  &nbsp; X, Y: Integer) of object;</p>
<p>property OnEndDrag: TEndDragEvent;</p>
<p>Источник и приемник определяются параметрами Sender и Target соответственно. Координаты мыши определяются параметрами X и Y. </p>
<p>Для программной остановки переноса можно использовать метод EndDrag источника (при обычном завершении операции пользователем он не используется): </p>
<p>procedure EndDrag(Drop: Boolean); </p>
<p>Параметр Drop = True завершает перенос. Значение False прерывает перенос. </p>
<p>Теперь настало время закрепить полученные знания на практике. Рассмотрим небольшой пример. В проекте DemoDragDrop на основе механизма Drag-and-Drop реализована передача текста между текстовыми редакторами и перемещение панелей по форме (рис. 27.1). </p>
<p>Листинг 27.1. Секция implementation модуля главной формы проекта DemoDragDrop </p>
<pre name="code" class="delphi">
implementation
{$R *.DFM}
 
procedure TMainForm.EditlMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, У: Integer);
begin
  if Button = mbLeft then
    TEdit(Sender).BeginDrag(True);
end;
 
procedure TMainForm.Edit2DragOver(Sender, Source: TObject;
  X, Y: Integer; State: TDragState; var Accept: Boolean);
begin
  if Source is TEdit then
    Accept := True
  else
    Accept := False;
end;
 
procedure TMainForm.Edit2DragDrop(Sender, Source: TObject;
  X, Y: Integer);
begin
  TEdit(Sender).Text := TEdit(Source).Text;
  TEdit(Sender).SetFocus;
  TEdit(Sender).SelectAll;
end;
 
procedure TMainForm.EditlEndDrag(Sender, Target: TObject;
  X, Y: Integer);
begin
  if Assigned(Target) then
    TEdit(Sender).Text := 'Текст перенесен в ' + TEdit(Target).Name;
end;
 
procedure TMainForm.FormDragOver(Sender, Source: TObject;
  X, Y: Integer; State: TDragState; var Accept: Boolean);
begin
  if Source.ClassName = 'TPanel' then
    Accept := True
  else
    Accept := False;
end;
 
procedure TMainForm.FormDragDrop(Sender, Source: TObject;
  X, Y: Integer);
begin
  TPanel(Source).Left := X;
  TPanel(Source).Top := Y;
end;
 
end.
</pre>
<p>Для однострочного редактора Edit1 определены методы-обработчики источника. В методе EditiMouseDown обрабатывается нажатие левой кнопки мыши </p>
<p>и включается механизм переноса. Так как свойство DragMode для Edit1 имеет значение dmManual, то компонент без проблем обеспечивает получение фокуса и редактирование текста. </p>
<p>Метод EditiEndDrag обеспечивает отображение информации о выполнении переноса в источнике. </p>
<p>Для компонента Edit2 определены методы-обработчики приемника. Метод Edit2DragOver проверяет класс источника и разрешает или запрещает прием. </p>
<p>Метод Edit2DragDrop осуществляет перенос текста из источника в приемник. </p>
<p id="note">Примечание </p>
<p>Обратите внимание, что оба компонента TEdit одновременно являются источниками и приемниками. Для этого каждый из них использует методы-обработчики другого. А исходный код методов настроен на обработку владельца как экземпляра класса TEdit. </p>
<p>Форма, как приемник Drag-and-Drop, обеспечивает перемещение панели Panel2, которая выступает в роли источника. Метод FormDragOver запрещает прием любых компонентов, кроме панелей. Метод FormDragDrop осуществляет перемещение компонента. </p>
<p>Панель не имеет своих методов-обработчиков, т. к. работает в режиме dmAutomatic и не нуждается в дополнительной обработке завершения переноса. </p>
<p><a href="http://delphiworld.narod.ru/" target="_blank">http://delphiworld.narod.ru/</a></p>
<p>DelphiWorld 6.0</p>
&nbsp;</p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
