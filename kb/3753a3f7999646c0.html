<!DOCTYPE html>
<html>
<head>
  <title>Сжатие данных в целях экономии места и ускорения работы Oracle</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Сжатие данных в целях экономии места и ускорения работы Oracle</h1>
<div id="date">01.01.2010</div>

<p>Используйте сжатие данных таблицы для экономии места на диске и повышения производительности запросов. В большинстве систем поддержки принятия решений (СППР) обычно используются большие объемы данных, которые хранятся в нескольких очень больших таблицах. При развитии подобных систем требования к дисковому пространству могут быстро расти. Сейчас хранилища данных объемом сотни терабайт встречаются все чаще.<br>
&nbsp;<br>
При решении проблем с дисковым пространством, появившаяся в oracle 9i release 2 возможность сжатия таблицы может существенно сократить объем дискового пространства, используемого таблицами базы данных и, в некоторых случаях, повысить производительность запросов.<br>
&nbsp;<br>
В этой статье я покажу, как работает сжатие таблиц при создании баз данных и управлении ими. Я также представлю определенные результаты по производительности, на основе результатов некоторых тестов, чтобы помочь вам понять, какие преимущества можно, предположительно, получить при использовании сжатия таблиц.<br>
Как это реализовано<br>
&nbsp;<br>
Возможность сжатия таблиц в oracle9i release 2 реализуется путем удаления дублирующихся значений данных из таблиц базы. Сжатие выполняется на уровне блоков базы данных. Когда таблица определена как сжатая, сервер резервирует место в каждом блоке базы данных для хранения одной копии данных, встречающихся в этом блоке в нескольких местах. Это зарезервированное место называют таблицей символов (symbol table). Помеченные для сжатия данные хранятся только в таблице символов, а не в строках данных. При появлении в строке данных, помеченных для сжатия, в строке, вместо самих данных, запоминается указатель на соответствующие данные в таблице символов. Экономия места достигается за счет удаления избыточных копий значений данных в таблице.<br>
&nbsp;<br>
Сжатие таблицы на пользователя или разработчика приложений никак не влияет. Разработчики обращаются к таблице одинаково, независимо от того, сжата она или нет, поэтому sql-запросы не придется менять, когда вы решите сжать таблицу. Параметры сжатия таблицы обычно устанавливаются и изменяются администраторами или архитекторами базы данных, и участие в этом процессе разработчиков или пользователей минимально.<br>
Как создать сжатую таблицу<br>
&nbsp;<br>
<p>Для создания сжатой таблицы используется ключевое слово compress в операторе create table. Ключевое слово compress требует от сервера oracle, по возможности, хранить строки таблицы в сжатом виде. Ниже представлен пример оператора create table compress:</p>
<pre name="code" class="sql">
create table sales_history_comp (
part_id varchar2(50) not null,
store_id varchar2(50) not null,
sale_date date not null,
quantity number(10,2) not null
)
compress;
</pre>
&nbsp;<br>
&nbsp;<br>
<p>Можно также использовать оператор alter table для изменения атрибута сжатия существующей таблицы, как в следующем примере:</p>
<pre name="code" class="sql">
alter table sales_history_comp compress;
</pre>
&nbsp;<br>
&nbsp;<br>
<p>Чтобы узнать, использовалось ли ключевое слово compress в определении таблицы, выполните запрос к представлению user_tables словаря данных и проверьте значение столбца compression, как в следующем примере:</p>
<pre name="code" class="sql">
select table_name, compression from user_tables;
</pre>
&nbsp;<br>
&nbsp;<br>
table_name compression<br>
------------------ -----------<br>
sales_history disabled<br>
sales_history_comp enabled<br>
&nbsp;<br>
<p>Атрибут compress также может быть задан на уровне табличного пространства, как в момент его создания (с помощью оператора create tablespace), так и в дальнейшем (с помощью оператора alter tablespace). Атрибут compress наследуется аналогично параметрам хранения. При создании таблицы в табличном пространстве наследуется атрибут compress этого табличного пространства. Чтобы определить, задан ли для табличного пространства атрибут compress, выполните запрос к представлению dba_tablespaces словаря данных и проверьте значение столбца def_tab_compression, как в следующем примере:</p>
<pre name="code" class="sql">
select tablespace_name, 
def_tab_compression 
from dba_tablespaces;
</pre>
&nbsp;<br>
&nbsp;<br>
tablespace_name def_tab_compression<br>
--------------- -------------------<br>
data_ts_01 disabled<br>
index_ts_01 disabled<br>
&nbsp;<br>
Как и следовало ожидать, вы можете сжимать или не сжимать таблицу в табличном пространстве, независимо от значения compress, заданного на уровне табличного пространства.<br>
Загрузка данных в сжатую таблицу<br>
&nbsp;<br>
Учтите, что при указании ключевого слова compress, как показано в примерах выше, вы, фактически, никаких данных не сжимаете. Представленные выше команды изменяют только установку в словаре данных. Данные реально не сжимаются, пока не будут загружены или вставлены в таблицу.<br>
&nbsp;<br>
Более того, чтобы гарантировать фактическое сжатие данных, надо использовать соответствующий метод загрузки или вставки данных в таблицу. Сжатие данных происходит только при массовой загрузке или в процессе массовой вставки, с помощью одного из следующих четырех методов:<br>
Непосредственная загрузка sql*loader<br>
Последовательные вставки insert с подсказкой append<br>
Параллельный insert<br>
create table ... as select<br>
&nbsp;<br>
Метод непосредственной загрузки sql*loader - наиболее удобный способ загрузки данных в таблицу, если данные доступны в текстовом файле. Пример представлен ниже:<br>
$sqlldr sanjay/sanjay@proddb control=sales_history.ctl direct=true <br>
&nbsp;<br>
Если данные доступны в промежуточной (staging) таблице, можно использовать последовательные операторы insert с подсказкой append или параллельный insert.<br>
&nbsp;<br>
<p>В качестве примера рассмотрим случай, когда входные данные доступны в не сжатой промежуточной таблице sales_history. Используя метод последовательной вставки, можно использовать следующий оператор для вставки данных в сжатую таблицу:</p>
<pre name="code" class="sql">
insert /*+ append */ 
into sales_history_comp
select * from sales_history;
</pre>
&nbsp;<br>
&nbsp;<br>
<p>Для переноса данных из промежуточной таблицы в сжатую можно также использовать параллельный insert, как показано ниже:</p>
<pre name="code" class="sql">
alter session enable parallel dml;
insert /*+parallel(sales_history_comp,4)*/ 
into sales_history_comp
select * from sales_history;
</pre>
&nbsp;<br>
&nbsp;<br>
Учтите, что при использовании параллельного insert надо сначала включить распараллеливание операторов dml в сеансе с помощью команды alter session enable parallel dml.<br>
&nbsp;<br>
Если входные данные представлены в обычном файле, можно также обратиться к нему как к внешней таблице, а затем вставлять данные в сжатую таблицу так же, как из промежуточной таблицы. (Обсуждение внешних таблиц выходит за рамки этой статьи.)<br>
&nbsp;<br>
<p>Можно также использовать оператор create table ... as select для создания сжатой таблицы и вставки в нее данных за один шаг. Вот пример:</p>
<pre name="code" class="sql">
create table sales_history_comp
compress
as select * from sales_history;
</pre>
&nbsp;<br>
&nbsp;<br>
Если не использовать соответствующий метод загрузки или вставки данных, данные в таблице окажутся не сжатыми, хотя для таблицы и определен атрибут compress. Например, если использовать обычную загрузку (conventional path) с помощью sql*loader или обычные операторы insert, данные не будут сжиматься.<br>
Когда использовать сжатие таблиц<br>
&nbsp;<br>
Применяемый сервером oracle алгоритм принятия решения о том, сжимать данные таблицы или не сжимать, приводит к определенным выводам об особенностях приложений, больше всего подходящих для сжатия таблиц. Как было описано выше, данные в таблице с атрибутом compress сжимаются только при непосредственной загрузке или при вставке с использованием подсказки append и распараллеливанием. Данные, вставленные обычными операторами insert, останутся не сжатыми.<br>
&nbsp;<br>
В системах оперативной обработки транзакций (online transaction processing - oltp) данные обычно вставляются обычными операторами insert. В результате, от использования сжатия для соответствующих таблиц большого преимущества не будет. Сжатие таблиц больше всего подходит для таблиц только для чтения, данные в которые загружаются один раз, а читаются - многократно. Таблицы, используемые при организации хранилищ данных, например, прекрасно подходят для сжатия.<br>
&nbsp;<br>
Более того, изменение данных в сжатой таблице может потребовать распаковки строк, что сводит на нет все преимущества сжатия. В результате, часто изменяемые таблицы плохо подходят для сжатия.<br>
&nbsp;<br>
Наконец, надо учесть последствия удаления строки при использовании сжатия таблицы. При удалении строки в сжатой таблице сервер освобождает место, занимаемое строкой в блоке. Это свободное место может быть повторно использовано при любой последующей вставке. Однако поскольку строка, вставленная в обычном режиме, не сжимается, маловероятно, что она поместится в освободившееся от сжатой строки место. Значительное количество последовательно выполняемых операторов delete и insert может вызвать фрагментацию и дискового пространства при этом будет напрасно использоваться больше, чем удалось сэкономить за счет сжатия.<br>
Сжатие существующей не сжатой таблицы<br>
&nbsp;<br>
<p>Уже существующую не сжатую таблицу можно сжать с помощью оператора alter table ... move. Например, не сжатую таблицу sales_history_temp можно сжать с помощью следующего оператора:</p>
<pre name="code" class="sql">
alter table sales_history_temp 
move compress;
</pre>
&nbsp;<br>
Оператор alter table ... move можно использовать и для отмены сжатия таблицы, как в следующем примере:<br>
<p>&nbsp;</p>
<pre name="code" class="sql">alter table sales_history_temp 
move nocompress;
</pre>
&nbsp;<br>
&nbsp;<br>
Учтите, что оператор alter table ... move устанавливает МОНОПОЛЬНУЮ блокировку таблицы, что предотвращает выполнение любых операторов dml с таблицей на время выполнения этого оператора. Этой потенциальной проблемы можно избежать за счет использования оперативного переопределения таблицы (online table redefinition), появившегося в oracle9i.<br>
Сжатие материализованного представления<br>
&nbsp;<br>
<p>Материализованные представления можно сжимать точно так же, как и таблицы. Следующий оператор создает сжатое материализованное представление:</p>
<pre name="code" class="sql">
create materialized view mv_sales_comp compress as 
select p.part_name, h.store_id, h.sale_date, h.quantity 
from sales_history h, parts p 
where p.part_id = h.part_id; 
</pre>
&nbsp;<br>
&nbsp;<br>
Материализованные представления на основе соединений нескольких таблиц обычно хорошо поддаются сжатию, поскольку в них часто встречаются повторяющиеся компоненты данных. Атрибут сжатия для материализованного представления можно изменить с помощью оператора alter materialized view. Следующий оператор показывает, как сжать существующее не сжатое материализованное представление:<br>
<p>&nbsp;</p>
<pre name="code" class="sql">alter materialized view mv_sales compress;
</pre>
&nbsp;<br>
&nbsp;<br>
<p>При использовании этого оператора учтите, что сжатие фактически произойдет при следующем обновлении материализованного представления.</p>
&nbsp;<br>
Сжатие секционированной таблицы1<br>
&nbsp;<br>
Вариантов использовании сжатия для секционированных таблиц много. Сжатие можно применять либо на уровне таблицы, либо на уровне секции. Например, оператор create table в Листинге 1 создает таблицу из четырех секций. Поскольку compress задается на уровне таблицы, все четыре секции будут сжиматься.<br>
&nbsp;<br>
Поскольку сжатие может быть задано на уровне секции, можно некоторые секции сжать, а другие оставить не сжатыми. Пример в Листинге 2 демонстрирует, как задать сжатие на уровне секции.<br>
&nbsp;<br>
В Листинге 2 две секции таблицы (sales_q1_03 и sales_q2_03) сжаты, а остальные две остаются не сжатыми. Учтите, что атрибуты сжатия, заданные на уровне секции, переопределяют атрибуты, заданные для этой же секции на уровне таблицы. Если атрибут сжатия для секции не задан, эта секция наследует значение из определения на уровне таблицы. В Листинге 2, поскольку атрибуты сжатия для секций sales_q3_03 и sales_q4_03 не указаны, эти две секции наследуют значение из определения таблицы (которое, в данном случае, стандартно - nocompress).<br>
&nbsp;<br>
Секционированные таблицы обеспечивают совместно со сжатием одно уникальное преимущество. Один из полезных способов секционировать таблицы - поместить подлежащие изменению (вставке, обновлению и удалению) данные в отдельные секции, а данные только для чтения вынести в другие. Например, в определении таблицы в Листинге 2 данные о продажах секционированы по значению столбца sale_date, так что хронологическая информация о продажах в каждом квартале хранится в отдельной секции. В этом примере данные о продажах за первый (q1) и второй (q2) кварталы 2003 года не могут быть изменены, поэтому они помещены в сжатые секции sales_q1_03 и sales_q2_03. Данные о продажах за третий (q3) и четвертый (q4) кварталы все еще могут меняться, поэтому соответствующие секции, sales_q3_03 и sales_q4_03, оставлены не сжатыми.<br>
&nbsp;<br>
Если в конце третьего квартала 2003 года данные в секции sales_q3_03 становятся доступными только для чтения, можно сжать эту секцию с помощью оператора alter table ... move partition, как показано ниже:<br>
<p>&nbsp;</p>
<pre name="code" class="sql">alter table sales_part_comp 
move partition sales_q3_03 compress;
</pre>
&nbsp;<br>
&nbsp;<br>
<p>Чтобы узнать, какие секции таблицы сжаты, можно выполнить запрос к представлению user_tab_partitions словаря данных, как в следующем примере:</p>
<pre name="code" class="sql">
select table_name, partition_name, 
compression
from user_tab_partitions;
</pre>
&nbsp;<br>
&nbsp;<br>
table_name partition_name compression<br>
---------------------------- -----------<br>
sales_part_comp sales_q4_03 disabled<br>
sales_part_comp sales_q1_03 enabled<br>
sales_part_comp sales_q2_03 enabled<br>
sales_part_comp sales_q3_03 enabled<br>
Оценка преимуществ<br>
&nbsp;<br>
Основной причиной использования сжатия таблицы является экономия дискового пространства. Таблица в сжатом виде обычно занимает меньше места. Чтобы проиллюстрировать это утверждение, рассмотрим следующий с двумя таблицами: одна не сжатая (sales_history), а другая - сжатая (sales_history_comp). В обе эти таблицы данные были загружены с помощью непосредственной загрузки утилитой sql*loader из текстового файла, содержащего два миллиона строк. После выполнения обеих загрузок оказалось, что сжатая таблица занимает на диске почти вдвое меньше места, чем не сжатая. Анализ представлен в Листинге 3. <br>
&nbsp;<br>
Тот факт, что для хранения сжатой таблицы надо меньше блоков, приводит к экономии дискового пространства, но уменьшение количества блоков может приводить и к повышению производительности. Запросы к сжатой таблице в среде с ограниченной производительностью ввода-вывода часто будут выполняться быстрее, поскольку требуют прочтения меньшего количества блоков. Чтобы проиллюстрировать это утверждение, я выполнил запрос к сжатой и не сжатой таблице и проанализировал результаты sqltrace/tkprof. Эти результаты представлены в Листинге 4.<br>
&nbsp;<br>
Отчет sqltrace/tkprof показывает, что мой запрос к сжатой таблице потребовал меньше операций физического и логического ввода-вывода, чем аналогичный запрос к не сжатой таблице, и, как следствие, выполняется быстрее.<br>
Снижение производительности при загрузке<br>
&nbsp;<br>
Поскольку сжатие таблицы выполняется при массовой загрузке, операции загрузки требуют дополнительной обработки - надо выполнять дополнительные действия. Чтобы измерить влияние сжатия на производительность, я выполнил тест, в котором загружал один миллион строк (с помощью непосредственной загрузки утилитой sql*loader) в две идентичных таблицы: со сжатием и без сжатия. В Таблице 1 представлены результаты, взятые из журнальных файлов sql*loader и показывающие, сколько времени потребовалось для загрузки данных в каждую из таблиц.<br>
Имя таблицы Количест- во строк Способ загрузки Сжатая? Время загрузки <br>
sales_history 1000000 Непосред- ственная Не сжатая 00:00:21.12 <br>
sales_history_comp 1000000 Непосред- ственная Сжатая 00:00:47.77 <br>
&nbsp;<br>
Таблица 1: Сравнение времени загрузки данных для сжатой и не сжатой таблиц<br>
&nbsp;<br>
Дополнительное время при загрузке в сжатую таблицу требуется для выполнения действий по сжатию загружаемых данных. В реальной ситуации различие во времени загрузки будет зависеть от особенностей таблицы и загружаемых данных.<br>
Заключение<br>
&nbsp;<br>
Сжатие таблицы в oracle9i release 2 позволяет существенно сэкономить дисковое пространство, особенно в базах данных, содержащих большие таблицы только для чтения. Если учитывать дополнительные требования к загрузке и вставке данных, а также правильно выбрать таблицы-кандидаты для сжатия, сжатие таблиц может оказаться потрясающим способом экономии дискового пространства и, в некоторых случаях, повышения производительности запросов. <br>
Автор: В. Кравчук <br>
<p>Источник: <a href="http://www.realcoding.net/" target="_blank">http://www.realcoding.net/</a></p>
&nbsp;</p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
