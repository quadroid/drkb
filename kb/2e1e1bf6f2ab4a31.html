<!DOCTYPE html>
<html>
<head>
  <title>Kylix Tutorial. Часть 4. Использование однонаправленных наборов данных</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Kylix Tutorial. Часть 4. Использование однонаправленных наборов данных</h1>
<div id="date">01.01.2010</div>

<p>Однонаправленные наборы данных предоставляют механизм доступа для чтения данных из таблиц сервера БД с помощью SQL команд. Они созданы для быстрого и "легковесного" доступа к информации сервера БД с минимальной загрузкой последнего. Однонаправленные наборы данных посылают команды серверу БД и в случае наличия набора записей, получают однонаправленный курсор для доступа к этим записям. Однонаправленные наборы данных не буферизируют полученные данные в памяти, что делает их более быстрыми и менее ресурсоемкими по сравнению с другими типами наборов данных. Однако, из-за отсутствия буфера записей, однонаправленные наборы данных менее гибки. Многие из возможностей, объявленных в TDataSet либо не реализованы, либо вызывают генерацию исключительных ситуаций. Например: </p>
<p>· Из методов навигации поддерживаются только First и Next. Большинство других методов вызывают исключения. Некоторые, такие как методы работы с закладками (Bookmarks), представляют собой просто заглушки.</p>
<p>· Нет встроенной поддержки для редактирования записей, поскольку для этого требуется буферизация. </p>
<p>· Свойство CanModify всегда равно False, и попытки перевода датасета в режим редактирования всегда приводят к неудаче. Редактирование данных, однако, может осуществляться с помощью SQL команды UPDATE или при помощи подключения клиентского набора данных.</p>
<p>· Отсутствует поддержка фильтров, поскольку это требует буферизации. При попытке фильтрации вызывается исключение. Все ограничения на диапазон выбираемых записей должны содержаться в SQL команде. </p>
<p>· Отсутствует поддержка lookup полей, т.к при этом необходимо буферизировать возможные значения такого поля. </p>
<p>  Однако отсутствие буферизации делает однонаправленные наборы данных быстрыми, простыми в реализации и распространении. На закладке dbExpress палитры компонентов представлены четыре типа однонаправленных наборов данных: TSQLDataSet, TSQLQuery, TSQLTable и TSQLStoredProc. </p>
<p>TSQLDataSet наиболее общий из всех четырех. Может использоваться для выборки любых данных или выполнения SQL команд. Данный компонент рекомендуется использовать для работы через dbExpress. </p>
<p>TSQLQuery можно использовать так же как и TSQLDataSet. Главное отсутсвии поддержки хранимых процедур (хотя многие сервера позволяют вызывать хранимые процедуры из запросов, но каждый делает это по-своему, стандартный синтаксис отсутствует). Данный компонент присутствует, в основном, для обеспечения совместимости при переносе приложений из Windows. </p>
<p>TSQLTable компонент, дающий доступ ко всем записям и полям таблицы. Данный компонент присутствует, в основном, для обеспечения совместимости при переносе приложений из Windows. </p>
<p>TStoredProc компонент доступа к хранимым процедурам сервера. Данный компонент присутствует, в основном, для обеспечения совместимости при переносе приложений из Windows.</p>
<p>Подключение к базе и открытие. Управление транзакциями. </p>
<p>  Так как TSQLDataSet рекомендован в качестве универсального датасета доступа к данным далее мы его и рассмотрим, хотя многие моменты, как Вы заметите, будут верны для всех однонаправленных датасетов. Для получения данных с SQL сервера необходимо подключить однонаправленный датасет к БД, задать комаду и активизировать (открыть) его.</p>
<p>Для подключения к БД необходимо установить свойство SQLConnection равным имени компонента TSQLConection, который обеспечивает подключение к базе. В инспекторе объектов на этапе разработки автоматически отображается выпадающий список доступных подключений. </p>
<p>Текст команды необходимо указать в свойстве CommandText, интерпретация текста команды зависит от типа команды, указанного в свойстве CommandType. TSQLDataSet поддерживает 3 типа команд:</p>
<p>· ctQuery - в свойстве CommandText должен присутсвовать SQL запрос; </p>
<p>· ctStoredProc - в свойстве CommandText указывается имя хранимой процедуры; </p>
<p>· ctTable - в свойстве CommandText указывается имя таблицы из которой будут выбраны записи. </p>
<p>Активизация датасета в случае выполнения команды, возвращающей набор данных, (запросы SELECT, выборка таблицы итд) производится установкой свойства Active в True, либо вызовом метода Open. В обратном случае, если набор данных при выполнении команды не формируется (не путайте с пустым набором данных), нужно использовать метод ExecSQL. </p>
<p>Управление транзакцией, в которой осуществляется работа с сервером БД, однонаправленный датасет реализует через public свойство TransactionLevel. При одновременном открытии нескольких транзакций в компоненте TSQLConnection, можно установить TransactionLevel в значение идентификатора желаемой транзакции (поле TransactionID в структуре описания транзакции TTransactionDesc) при этом выполнение команд будет происходить в заданной транзакции. </p>
<p>Примеры: </p>
<pre name="code" class="delphi">
// Выполнение запроса возвращающего набора данных 
begin 
  SQLDataSet1.CommandType:=ctQuery; 
  SQLDataSet1.CommandText:='select * from MyTable';
  SQLDataSet1.ExecSQL; 
end;
 
// Выполнение запроса не возвращающего набора данных 
begin 
  SQLDataSet1.CommandType:=ctQuery; 
  SQLDataSet1.CommandText:='update MyTable set StrField1 = '''+Edit1.Text+''' where id = 5';
  SQLDataSet1.ExecSQL; 
end;
 
// Выполнение запроса возвращающего таблицу с SQL сервера.
begin 
  SQLDataSet1.CommandType:=ctTable; 
  SQLDataSet1.CommandText:='MyTable'; 
  SQLDataSet1.ExecSQL; 
end;
</pre>

<p>Навигация по записям. Свойства Eof и Bof. Количество записей, номер записи. </p>
<p>  Если Вы работали с базами данных в Delphi, можете пропустить этот раздел. </p>
<p>Как уже говорилось ранее, поддерживаются всегод два метода навигации по набору данных First и Next. Метод First делает текущей первую запись, метод Next позволяет передвинуться на одну запись вперед. </p>
<p>Свойство Eof типа boolean определяет достигнут ли конец набора данных. Свойство Bof также типа boolean индицирует нахождение в начале набора данных. Приведем в качестве примера код процедуры перебора записей набора данных: </p>
<pre name="code" class="delphi">
begin 
  with SQLDataSet1 do 
  begin 
    Open; 
    while not Eof do 
    begin 
      Next; 
    end; 
  end; 
end; 
</pre>

<p>Количество записей в наборе данных содержится в public свойстве RecordCount, а порядковый номер записи в свойстве RecNo. Однако нумерация записей поддерживается не всеми типами серверов БД. Чтобы узнать поддерживается ли возможность нумерации необходимо проанализировать возвращаемое значение функции IsSequenced, если значение равно True, то нумерация поддерживается, иначе для всех записей значение свойства RecNo равно -1. </p>
<p>Порядок сортировки.</p>
<p>  Порядок сортировки записей для типа команд ctQuery при выборке данных определяется конструкцией SQL ORDER BY, заданной в тексте запроса ( св-во CommandText). </p>
<p>Для типа команды ctTable порядок сортировки по умолчанию определяет SQL сервер. Для изменения порядка сортировки в этом случае необходимо в свойстве SortFieldNames указать имена полей сортировки, разделив их точкой с запятой. При генерации запроса на выборку таблицы данные поля будут вставлены в запрос в конструкции ORDER BY. Данный способ пригоден и для команды ctQuery. При этом в тексте SQL команды не должно содержаться ORDER BY. Однако первый описанный способ сортировки для типа команд ctQuery более предпочтителен. </p>
<p>Для типа команды ctStoredProc порядок сортировки определяется в самой хранимой процедуре.</p>
<p>Использование параметров в запросах и хранимых процедурах,подготовка запросов </p>
<p>  Если Вы работали с базами данных в Delphi, можете пропустить этот раздел. </p>
<p>Свойство Params позволяет работать с параметрами запроса или хранимой процедуры. Параметры - это переменные запроса, которые Вы можете менять в design и runtime без изменения текста запроса. Например, в данном запросе параметр P_ID используется для задания критерия отбора записей. </p>
<p>SELECT * FROM mytable where id &lt; :P_ID </p>
<p>Параметр заменяет конкретное значение, которое подставляется на этапе выполнения запроса. Имена параметров начинаются со знака :. Перед выполнением запроса необходимо задать значения всех его параметров. </p>
<p>При изменении текста запроса параметры, указанные в тексте добавляются в свойсвтво Params автоматически, если необходимо отключить такое поведение сбросьте свойство ParamCheck в False. </p>
<p>Свойство Params является коллекцией объектов типа TParam. Класс TParam описывает параметр запроса или хранимой процедуры. Наиболее важные свойства этого класса: </p>
<p>· DataType:TFieldType - тип данных параметра </p>
<p>· ParamType:TParamType - тип параметра : </p>
<p>· ptUnknown - неопределенный тип, перед выполнением запроса или процедуры надо задать конкретный тип из следующих возможных </p>
<p>· ptInput - входной параметр (используется для передачи параметров), </p>
<p>· ptOutput - выходной (используется для возврата значений из хранимой процедуры),</p>
<p>· ptInputOutput - и входной и выходной, </p>
<p>· ptResult - результат работы процедуры может быть только один параметр данныого типа для одной процедуры. </p>
<p>· Value: Variant - значение параметра. Должно быть заполено перед выполнением запроса. </p>
<p>В режиме разработки данные свойства устанаваливаются с помощью Object Inspector. В режиме выполнения для установки свойств и значений параметров используются следующие методы: </p>
<p>· ParamByName - доступ к параметру по имени </p>
<p>Например: </p>
<p>SQLDataSet1.ParamByName('Country').AsString:='Russia'; </p>
<p>· Params - доступ по индексу(номеру). Индексирование ведется с 0. </p>
<p>Например: </p>
<p>SQLDataSet1.Params[0].AsString:='Russia'; </p>
<p>· ParamValues - установка значений нескольких параметров. </p>
<p>Например: </p>
<p>SQLDataSet1.ParamValues['Name;Country']:=VarArrayOf([Edit1.Text, Edit2.Text]); </p>
<p>Подготовка запроса подразумевает анализ и разбор текста запроса SQL сервером, подстановку параметров и подготовку к выполнению. После выполнения команды сервер освобождает задействованные ресурсы. Однако при частом исполнении одного и того же запроса (даже с разными значениями параметров) для повышения быстродействия имеет смысл хранить скомпилированный запрос на сервере. Для этого свойство Prepared необходимо установить в True.</p>
<p>Запросы главный-подчиненный.</p>
<p>  Если Вы работали с базами данных в Delphi, можете пропустить этот раздел. </p>
<p>Наличие у TSQLDataSet свойства TDataSource позволяет связать два набора данных отношениями главный-подчиненный, т.е отображать в подчиненном наборе только те записи, которые связаны с текущей записью главного набора данных. Для этого необходимо связать главный набор данных с компонентом TDataSource, установив у последнего св-во DataSet равным имени компонента с главным набором данных. Затем у подчиненного набора данных установить свойство DataSource равным имени компонента TDataSource, связанного с главным набором. После описанных манипуляций в тексте команды подчиненного запроса можно использовать поля главного набора для связи, указывая их в качестве параметров.</p>
<p>Доступ к метаданным </p>
<p>  Метаданные - это данные о структуре базы данных, такие как созданые таблицы, хранимые процедуры, поля таблиц и параметры процедур итд. Получение метаданных осуществляется вызовом метода SetSchemaInfo. Метод объявлен как: </p>
<p>procedure SetSchemaInfo(SchemaType: TSchemaType; SchemaObjectName, SchemaPattern: string); </p>
<p>Первый параметр определяет тип метаданных. Его возможные значения </p>
<p>stNoSchema - схема отсутствует - производится выборка результатов запроса </p>
<p>stTables - получение списка таблиц </p>
<p>stSysTables - получение информации о системных таблицах </p>
<p>stProcedures - получение информации о хранимых процедурах </p>
<p>stColumns - информация о полях таблицы </p>
<p>stProcedureParams - параметры хранимой процедуры </p>
<p>stIndexes - информация об индексах таблицы </p>
<p>Второй параметр - имя таблицы или хранимой процедуры, о полях или параметрах которой мы получаем информацию. Имеет смысл лишь при следующих значениях первого параметра </p>
<p>stColumns, stProcedureParams, stIndexes, иначе параметр игнорируется, </p>
<p>Третий параметр SchemaPattern - позволяет задать маску для фильтрации выбранной информации. При этом допустимо применение следующих подстановок </p>
<p>% - любые символы </p>
<p>_ - одиночный символ </p>
<p>Если же в маску должны входить вышеприведенные два символа, то они записываются как %% - знак процента, __ - подчеркивание. </p>
<p>При изменении свойства CommandText набор данных автоматически устанавливает значение свойства SchemaInfo равным stNoSchema.</p>
<p>Пример: </p>
<p>// Выборка информации о таблицах </p>
<p>SQLDataSet1.Close; </p>
<p>SQLDataSet1.SetSchemaInfo(stTables,'','%'); </p>
<p>SQLDataSet1.Open; </p>

<p id="author">Автор: Mike Goblin </p>
<p>Взято с сайта <a href="http://www.delphimaster.ru/" target="_blank">http://www.delphimaster.ru/</a></p>
<p> с разрешения автора.</p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
