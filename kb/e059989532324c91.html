<!DOCTYPE html>
<html>
<head>
  <title>Обработка событий Qt в Kylix-приложении</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Обработка событий Qt в Kylix-приложении</h1>
<div id="date">01.01.2010</div>

<p id="author">Автор: Андрей Боровский (<a href="http://www.myhomepage.com/index.html" target="_blank">www.kylixportal.chat.ru</a>)</p>
<p>Что представляют собой события Qt?</p>
<p>Система Windows взаимодействует с приложениями посредством механизма сообщений, обработка которых осуществляется в оконной функции. В приложениях, созданных на основе Qt library, сообщения используются редко, а основным механизмом взаимодействия между приложениями и системой являются события. Концептуально события Qt очень похожи на события Kylix. В ответ на событие система вызывает обработчик, являющийся методом Qt-объекта. Каждому событию в Qt соответствует свой класс. Обработчику события передается ссылка на экзмпляр класса события, содержащий необходимую информацию о нем. Для того, чтобы определить собственный обработчик события для какого-либо Qt класса, следует создать производный класс этого класса и заместить (override) метод-обработчик соответствующего события. Однако средства Object Pascal не позволяют создавать производные классы Qt и замещать их методы, поэтому в Kylix реализован специальный механизм обработки событий.</p>
<p>События Qt и Kylix</p>
<p>Прежде чем приступить к рассмотрению специальных методов обработки событий Qt в Kylix, необходимо отметить, что в большинстве случаев у программиста не возникает необходимости обращаться к этим методам. Для большинства событий Qt в объектной модели Kylix определены соответствующие события Kylix, и обработка этих событий может быть выполнена стандартными средствами Object Pascal. Тем не менее иногда возникает необходимость ввести в приложении обработку Qt событий, не определенных в VisualCLX. В CLXDisplay API предусмотрено несколько механизмов обработки таких событий. В этой статье будет рассмотрен один из них. </p>
<p>Как и в Delphi, в Kylix приложения строятся на основе класса TApplication. В Kylix в классе TApplication определено свойство OnEvent, позволяющее назначать приложению обработчик событий Qt. Обработчик OnEvent вызывается для каждого события каждого объекта Qt, являющегося дочерним объектом форм приложения, а также для других событий приложения. </p>
<p>Тип процедуры обработчика декларируется следующим образом:</p>
<p>procedure (Sender: QObjectH; Event: QEventH; var Handled: Boolean) of object;</p>
<p>В параметре Sender передается ссылка на объект, который должен реагировать на событие. Параметр Event является указателем на объект события. Он позволяет идентифицировать событие и получить информацию о нем. Переменная Handled позволяет сообщить компоненту Visual CLX о том, следует ли вызывать обработчик события, определенный в компоненте. </p>
<p>Рассмотрим простой пример: допустим мы хотим, чтобы перерисовка окна компонента Label1 типа TLabel не выполнялась, если некоторой глобальной переменной NoRedraw типа Boolean присвоено значение True. для этого напишем следующую процедуру AppEventHandler:</p>

<pre name="code" class="delphi">
 uses Qt, ...
 
 ...
 
 procedure TForm1.AppEventHandler(Sender: QObjectH; Event: QEventH; 
 var Handled: Boolean);
 begin
   Handled:=False;                       // Allow  default event processing
   if Sender=Label1.Handle then          // Identify sending Qt object
   if QEvent_isQPaintEvent(Event) then   // Identify the Paint event
   Handled:=NoRedraw;        // Disable or enable default event processing  
 end; 
 
 procedure TForm1.FormCreate(Sender: TObject);
 begin
   ...
   Application.OnEvent:=AppEventHandler;
 end; 
 
 procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);
 begin
   ...
   Application.OnEvent:=nil;
 end;
</pre>

<p>Определить, какому объекту соответствует событие можно, сравнивая значение Sender с полем Handle экземпляров объектов Kylix. Определенные в модуле Qt.pas функции QEvent_isQXXXEvent действуют подобно оператору is языка Object Pascal и позволяют определить тип события, требующего обработки. Аргументом этих функций является ссылка на объект QEvent, являющийся базовым для всех объектов событий. Функция возвращает True, если ей передан укзатель на объект события соответствующего ей типа и False в противном случае. Так как любой объект события в Qt является потомком класса QEvent, после определения типа объекта события мы можем преобразовать тип значения Event к типу указателя на соответствующий объект события и при помощи функций CLXDisplay API получить доступ к методам этого объекта. Переменная Handled служит для того, чтобы разрешить или запретить дальнейшую обработку события стандартными средствами. В начале мы устанавливаем значение этой переменной равным False, для того, чтобы события обрабатывались компонентами. Для того, чтобы запретить дальнейшую обработку события, нужно присвоить этой переменной значение True.</p>
<p>Обратите внимание на присвоение значения nil свойству OnEvent в методе FormClose. Так как время жизни объекта TApplication превышает время жизни объекта TForm, программа может пытаться вызвать обработчик OnEvent после уничтожения формы. Если после закрытия формы данное поле не будет помечено как свободное (unassigned), при выходе из программы возникнет ошибка сегментации.</p>
<p>Программа, демонстрирующая механизм Drag and Drop</p>
<p>Далее рассматривается небольшое приложение, демонстрирующее перенос данных между двумя Qt-программами методом Drag and Drop. Средства Drag and Drop, предоставляемые Kylix, позволяют переносить данные только между объектами Kylix-приложения, а для того, чтобы осуществлять перенос между разными приложениями, придется обратиться к методам объектов Qt library.</p>
<p>Последовательность событий при использовании механизма Drag and Drop такова: когда пользователь переводит курсор мыши в режиме перетаскивания в область визуального Qt объекта, являющегося приемником Drag and Drop, система генерирует событие dragEnterEvent и вызывает обработчик этого события, определенный в объекте-приемнике. В ответ на это событие объект должен либо подтвердить выполнение Drag and Drop операции, либо отказаться от него. Если объект-приемник подтверждает операцию, курсор мыши приобретает характерный вид "готов к приему объекта" и пользователь может отпустить кнопку мыши для передачи объекта Drag and Drop объекту-приемнику. В противном случае курсор принимает вид "прием Drag and Drop запрещен" и дальнейшие события Drag and Drop не генерируются. Если объект-приемник разрешил Drag and Drop операцию, при дальнейшем перемещении мыши над видимой областью соответствующего интерфейсного элемента генерируется серия событий dragMoveEvent. Если пользователь отпускает клавишу мыши, генерируется событие DropEvent. Обработчик этого события должен выполнить непосредственную операцию вставки данных. При выходе курсора, находящегося в режиме перетаскивания, за пределы визуального элемента система генерирует событие dragLeaveEvent. Следует особо отметить, что обработчики событий не должны уничтожать объекты событий, так как эти объекты контролируются системой.</p>
<p>Для того, чтобы какой-либо элемент Qt приложения мог принимать данные, передаваемые посредством Drag and Drop, необходимо создать производный класс от класса этого элемента, разрешить в этом классе прием Drag and Drop объектов, вызвав метод setAcceptDrops базового класса QWidget и заместить методы обработки событий dragEnterEvent, dragMoveEvent, dragLeaveEvent и DropEvent. Программирование Drag and Drop для Kylix приложения имеет некоторые отличия. В Kylix-приложении прием объектов Drag and Drop разрешен для всех компонентов VCL, поэтому вызывать setAcceptDrops не нужно. Кроме того, поскольку методы компонентов VisualCLX перекрывают обработчики событий Drag and Drop, подтверждать Drag and Drop операции необходимо также и в обработчике события dragMoveEvent. В принципе в Kylix приложении вообще нет необходимости обрабатывать событие dragEnterEvent, но в приводимом ниже примере такая обарботка выполняется для большей наглядности.</p>
<p>Демонстрационное приложение позволяет перетаскивать и вставлять фрагменты текста. Для приема и передачи объектов Drag and Drop используется компонент Label. Ниже приводится обработчик Qt событий AppEventHandler.</p>
<pre name="code" class="delphi">
 procedure TForm1.AppEventHandler;
 var
   QMS : QMimeSourceH;
   S : WideString;
 begin
   Handled:=False;
   if Sender=Label1.Handle then
   if QEvent_isQDropEventEvent(Event) then
   begin
     if QEvent_isQDragEnterEvent(Event) then
     begin
       if QDropEvent_source(QDropEventH(Event))=Label1.Handle then Exit;
       QMS:=QDropEvent_to_QMimeSource(QDropEventH(Event));
       QDropEvent_acceptAction(QDropEventH(Event), QTextDrag_canDecode(QMS));
     end else
     if QEvent_isQDragMoveEvent(Event) then
     begin
       if QDropEvent_source(QDropEventH(Event))=Label1.Handle then Exit;
       QMS:=QDropEvent_to_QMimeSource(QDropEventH(Event));
       QDropEvent_acceptAction(QDropEventH(Event), QTextDrag_canDecode(QMS))
     end else
     begin
       QMS:=QDropEvent_to_QMimeSource(QDropEventH(Event));
       if QTextDrag_canDecode(QMS) then
       QTextDrag_decode(QMS, @S);
       Label1.Caption:=S;
     end;
   end;
 end;
</pre>

<p>Прежде чем разобрать работу этого метода, отмечу одну деталь: в модуле Qt содержится ошибка. При первых попытках скомпилировать программу для работы с Drag and Drop, компиляция проходила без проблем, однако приложение аварийно завершалось сразу после запуска. Анализ сообщений, выводимых на консоль, показал, что программа не может разрешить ссылку на внешний объект с именем QEvent_isQDropEventEvent. Эта функция декларируется в файле Qt.pas, однако, судя по сообщениям, выводившимся во время выполнения программы, разделяемая библиотека libqtintf.so.2 не экспортирует функцию с таким именем. Очевидно, что в имя функции вкралась опечатка. Для того, чтобы исправить ошибку я изменил декларацию внешней функции QEvent_isQDropEventEvent в файле Qt.pas. В разделе implementation, в строке, объявляющей экспорт функции, после ключевого слова name я заменил "QEvent_isQDropEventEvent" на "QEvent_isQDropEvent", после чего программа заработала. Остальные имена в декларации функции я менять не стал, так что модуль Qt по-прежнему экспортирует эту функцию как QEvent_isQDropEventEvent. Если Вы хотите иметь возможность запускать демонстрационное приложение из этой статьи, Вы должны сделать тоже самое и перекомпилировать модуль Qt. Между прочим, эта же ошибка имеет место и в соответствующем модуле Delphi 6.</p>
<p>Функции QEvent_isQDragEnterEvent, QEvent_isQDragMoveEvent и QEvent_isQDropEventEvent служат для идентификации событий. Порядок их вызова неслучаен. Отношения наследования между классами этих трех событий можно представить так: QDropEvent =&gt; QDragMoveEvent =&gt; QDragEnterEvent. Таким образом функция QEvent_isQDropEventEvent вернет значение True для всех трех событий. Действия, связанные собственно с событием DropEvent, следует выполнять только если первые проверки вернули False.</p>
<p>Функция QDropEvent_source вызывает метод source объекта события QDropEvent - базового объекта событий Drag and Drop. Обратите внимание на преобразование типа аргумента функции. Такое преобразование корректно, поскольку объекты QDragEnterEvent и QDragMoveEvent являются потомками объекта QDropEvent. QDropEvent_source позволяет определить источник объекта Drag and Drop. Поскольку в создаваемом приложении компонент Label является и приемником и источником объектов Drag and Drop, мы должны проверять, какой Qt объект создал данный объект Drag and Drop и не выполнять дальнейшую обработку события, если источником объекта является компонент Label1.</p>
<p>Функция QDropEvent_to_QMimeSource преобразует объект типа QDropEvent в объект типа QMimeSource, являющийся контейнером передаваемых данных. Функция QDropEvent_acceptAction позволяет подтвердить операцию Drag and Drop, или отказаться от нее. Первый аргумент функции - ссылка на объект QDropEvent, второй аргумент - значение True или False. Для определения того, следует ли обрабатывать событие, мы используем функцию QTextDrag_canDecode. Эта функция возвращает True, если переданный ей объект QMimeSource содержит данные в текстовом формате и False в противном случае. Функция QTextDrag_decode извлекает текстовые данные из объекта QMimeSource. Обратите внимание, что обработчик не должен пытаться уничтожить объекты QMimeSource</p>
<p>Для того, чтобы Qt приложение могло стать источником объектов Drag and Drop, необходимо создать объект-контейнер данных и вызвать один из методов этого объекта : drag или dragCopy. Объект для перетаскивания лучше всего создавать в момент начала движения мыши при нажатой левой кнопке. В нашем приложении эту функцию выполняет обработчик события OnMouseMove объекта Label1:</p>
<pre name="code" class="delphi">
 procedure TForm1.Label1MouseMove(Sender: TObject; Shift: TShiftState; X,
   Y: Integer);
 var
   TextDragObject : QTextDragH;
   S : WideString;
   name : PChar;
 begin
   if ssLeft in Shift then
   begin
     S:=Label1.Caption;
     name:='TextDrag';
     TextDragObject:=QTextDrag_create(@S, Label1.Handle, name);
     if QDragObject_drag(TextDragObject) then Label1.Caption:='';
   end;
 end;
</pre>

<p>Функция QTextDrag_create создает экземпляр объекта-контейнера QTextDrag. Первый параметр - указатель на строку текста, которую мы хотим скопировать. Параметр name может содержать любую строку PChar. Функция QDragObject_drag инициирует процесс Drag and Drop. Эта функция не возвращает управление до тех пор, пока пользователь не отпустит кнопку мыши. QDragObject_drag возвращает значение True, если был выбран режим перемещения данных и False, если был выбран режим копирования. Выбор режима в системе определяется состоянием клавиши Ctrl. Процедура QDragObject_dragCopy выполняет те же действия, но возвращает управление сразу и не передает программе никаких значений. Хотя функция QDragObject_drag возвращает управление обработчику только после того, как пользователь отпустит левую кнопку мыши, обработчик не должен пытаться уничтожить объект QDragObject. Время жизни этого объекта контролируется системой, и попытка уничтожить его вызовет ошибку сегментации.</p>
<p>Полный исходный текст демонстрационного приложения можно скачать здесь. При работе с демонстрационным приложением следует учесть, что не все приложения, написанные для Qt/KDE, поддерживают Drag and Drop. Некоторые приложения, например KWord, могут быть источниками текстовых объектов Drag and Drop, но не приемниками. Учтите также, что в настоящее время Drag and Drop в KDE работает не очень стабильно. Работая с демонстрационной программой, вы можете столкнуться с тем, что некоторые другие приложения, использующиеся как источники или приемники объектов Drag and Drop, будут зависать. Это не связано с Kylix, так как при использовании "фирменных" примеров из поставки Qt возникают те же проблемы, по крайней мере на момент написания этой статьи.</p>
<p>Генерация событий Qt в программе</p>
<p>Обычно события Qt генерируются системой в ответ на действия пользователя или события в самой системе. Однако, иногда бывает желательно вызвать обработчик события из непосредственно из программы. Для этого необходимо создать объект соответствующего события и передать его методу Qt объекта. CLXDisplay API позволяет сделать это при помощи набора функций QOpenWidget_XXXEvent, определенных для различных типов событий. В следующем небольшом примере создаются объекты событий, при помощи которых в поле ввода визуального компонента Edit1 типа TEdit вводится текст, а затем эмулируется нажатие клавиши BackSpace (код $1003), стирающее последний введенный символ. </p>
<pre name="code" class="delphi">
var
  KeyEvent : QKeyEventH;
  S : WideString;
 ...
 begin
   ...
   S:='Some little text';
   KeyEvent:=QKeyEvent_create(QEventType_KeyPress, 0, 0, 0, @S, False, 0);
   QOpenWidget_keyPressEvent(QOpenWidgetH(Edit1.Handle), KeyEvent);
   QKeyEvent_destroy(KeyEvent);
   KeyEvent:=QKeyEvent_create(QEventType_KeyPress, $1003, 0, 0, nil, False, 0);
   QOpenWidget_keyPressEvent(QOpenWidgetH(Edit1.Handle), KeyEvent);
   QKeyEvent_destroy(KeyEvent);
   ...
</pre>

<p>Рассмотренный в этой статье метод обработки событий - не единственный. В следующей статье будут рассмторены перехватчики событий, а также еще один механизм взаимодействия между объектами Qt - сигналы и слоты. </p>
<p>Статья и примеры программ © 2001 Андрей Наумович Боровский.</p>
<p>Взято из <a href="http://forum.sources.ru" target="_blank">http://forum.sources.ru</a></p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
