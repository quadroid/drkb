<!DOCTYPE html>
<html>
<head>
  <title>Реализация односвязного и двусвязного списков</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Реализация односвязного и двусвязного списков</h1>
<div id="date">01.01.2010</div>
<p>Реализация односвязного и двусвязного списков <img src="pic/embim1797.gif" width="1" height="1" vspace="1" hspace="1" border="0" alt=""><br>
<img src="pic/embim1798.png" width="160" height="1" vspace="1" hspace="1" border="0" alt=""><br>
&nbsp;<br>
<p>&nbsp;</p>
По изданию "Модели и структуры данных"<br>
<p>Alexander S. Derevjanko</p>
<p>Ниже рассматриваются некоторые простые операции над линейными списками. Выполнение операций иллюстрируется в общем случае рисунками со схемами изменения связей и программными примерами. </p>
<p>На всех рисунках сплошными линиями показаны связи, имевшиеся до выполнения и сохранившиеся после выполнения операции. Пунктиром показаны связи, установленные при выполнении операции. Значком 'x' отмечены связи, разорванные при выполнении операции. Во всех операциях чрезвычайно важна последовательность коррекции указателей, которая обеспечивает корректное изменение списка, не затрагивающее другие элементы. При неправильном порядке коррекции легко потерять часть списка. Поэтому на рисунках рядом с устанавливаемыми связями в скобках показаны шаги, на которых эти связи устанавливаются. </p>
<p>В программных примерах подразумеваются определенными следующие типы данных: </p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>любая структура информационной части списка:</td></tr></table></div><pre name="code" class="delphi">type data = ...; 
</pre>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>элемент односвязного списка (sll - single linked list): </td></tr></table></div><pre name="code" class="delphi">type
 &nbsp; sllptr = ^slltype; { указатель в односвязном списке }
 &nbsp; slltype = record { элемент односвязного списка }
 &nbsp;&nbsp;&nbsp; inf : data;&nbsp;&nbsp;&nbsp; { информационная часть }
 &nbsp;&nbsp;&nbsp; next : sllptr; { указатель на следующий элемент }
 &nbsp;&nbsp;&nbsp; end;
</pre>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>элемент двухсвязного списка (dll - double linked list): </td></tr></table></div>&nbsp;</p>
<pre name="code" class="delphi">type
 &nbsp; dllptr = ^dlltype;&nbsp;&nbsp;&nbsp;&nbsp; { указатель в двухсвязном списке }
 &nbsp; dlltype = record { элемент односвязного списка }
 &nbsp;&nbsp;&nbsp; inf : data;&nbsp;&nbsp;&nbsp; { информационная часть }
 &nbsp;&nbsp;&nbsp; next : sllptr; { указатель на следующий элемент (вперед) }
 &nbsp;&nbsp;&nbsp; prev : sllptr; { указатель на предыдущий элемент (назад) }
 &nbsp;&nbsp;&nbsp; end;
</pre>
&nbsp;</p>
<p>&nbsp;<br>
Перебор элементов списка <img src="pic/embim1799.gif" width="1" height="1" vspace="1" hspace="1" border="0" alt=""><br>
<img src="pic/embim1800.png" width="160" height="1" vspace="1" hspace="1" border="0" alt=""><br>
&nbsp;<br>
<p>&nbsp;</p>
<p>Эта операция, возможно, чаще других выполняется над линейными списками. При ее выполнении осуществляется последовательный доступ к элементам списка - ко всем до конца списка или до нахождения искомого элемента. </p>
<p>Алгоритм перебора для односвязного списка представляется программным примером 1. </p>
<pre name="code" class="delphi">
{==== Программный пример 1 ====}
 { Перебор 1-связного списка }
 Procedure LookSll(head : sllptr);
  { head - указатель на начало списка }
  var cur : sllptr;  { адрес текущего элемента }
   begin
   cur:=head; { 1-й элемент списка назначается текущим }
   while cur &lt;&gt; nil do begin   &lt; обработка c^.inf &gt;
</pre>

<p>обрабатывается информационная часть того эл-та, на который указывает cur. Обработка может состоять в: </p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>печати содержимого инф.части; </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>модификации полей инф.части; </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>сравнения полей инф.части с образцом при поиске по ключу; </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>подсчете итераций цикла при поиске по номеру; </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>и т.д., и т.п. </td></tr></table></div><p> &nbsp;&nbsp;&nbsp; cur:=cur^.next;</p>
<p>из текущего эл-та выбирается указатель на следующий эл-т и для следующей итерации следующий эл-т становится текущим; если текущий эл-т был последний, то его поле next содержит пустой указатель и, т.обр. в cur запишется nil, что приведет к выходу из цикла при проверке условия while </p>
<p> &nbsp; end;&nbsp; end;</p>
<p>  { конец примера } </p>
<p>В двухсвязном списке возможен перебор как в прямом направлении (он выглядит точно так же, как и перебор в односвязном списке), так и в обратном. В последнем случае параметром процедуры должен быть tail - указатель на конец списка, и переход к следующему элементу должен осуществляться по указателю назад: </p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur:=cur^.prev;</p>
<p>Алгоритм перебора для двусвязного списка мы оставляем читателю на самостоятельную разработку. </p>
<p>&nbsp;<br>
Вставка элемента в список <img src="pic/embim1801.gif" width="1" height="1" vspace="1" hspace="1" border="0" alt=""><br>
<img src="pic/embim1802.png" width="160" height="1" vspace="1" hspace="1" border="0" alt=""><br>
&nbsp;<br>
<p>&nbsp;</p>
<p>Вставка элемента в середину односвязного списка показана на рис.1 и в примере 2. </p>
<img src="pic/clip0137.gif" width="485" height="122" border="0" alt="clip0137"></p>
Рис. 1: Вставка элемента в середину 1-связного списка</p>
<p>&nbsp;<br>
<p>&nbsp;</p>
<pre name="code" class="delphi">
 {==== Программный пример 2 ====}
 { Вставка элемента в середину 1-связного списка }
 Procedure InsertSll(prev : sllptr; inf : data);
 { prev - адрес предыдущего эл-та; inf - данные нового эл-та }
  var cur : sllptr;  { адрес нового эл-та }
   begin
   { выделение памяти для нового эл-та и запись в его инф.часть }
   New(cur); cur^.inf:=inf;
   cur^.next:=prev^.next; { эл-т, следовавший за предыдущим теперь
 будет следовать за новым }
   prev^.next:=cur;       { новый эл-т следует за предыдущим }
 end;
 
</pre>
<p>Рисунок 2 представляет вставку в двухсвязный список. </p>
<img src="pic/clip0138.gif" width="606" height="208" border="0" alt="clip0138"></p>
Рис. 2: Вставка элемента в середину 2-связного списка</p>
<p>&nbsp;<br>
<p>&nbsp;</p>
<p>Приведенные примеры обеспечивают вставку в середину списка, но не могут быть применены для вставки в начало списка. При последней должен модифицироваться указатель на начало списка, как показано на рис. 3. </p>
<img src="pic/clip0139.gif" width="295" height="122" border="0" alt="clip0139"></p>
Рис. 3: Вставка элемента в начало 1-связного списка</p>
<p>&nbsp;<br>
<p>&nbsp;</p>
<p>Программный пример 3 представляет процедуру, выполняющую вставку элемента в любое место односвязного списка.</p>
<pre name="code" class="delphi">
{==== Программный пример 3 ====}
 { Вставка элемента в любое место 1-связного списка }
 Procedure InsertSll
   var head : sllptr; { указатель на начало списка, может измениться в
 процедуре, если head=nil - список пустой }
       prev : sllptr; { указатель на эл-т, после к-рого делается вставка,
 если prev-nil - вставка перед 1-ым эл-том }
       inf : data { - данные нового эл-та }
  var cur : sllptr;  { адрес нового эл-та }
   begin
   { выделение памяти для нового эл-та и запись в его инф.часть }
   New(cur); cur^.inf:=inf;
   if prev &lt;&gt; nil then begin { если есть предыдущий эл-т - вставка в
 середину списка, см. прим. 2 }
     cur^.next:=prev^.next;  prev^.next:=cur;
     end
   else begin { вставка в начало списка }
     cur^.next:=head; { новый эл-т указывает на бывший 1-й эл-т списка;
 если head=nil, то новый эл-т будет и последним эл-том списка }
     head:=cur; { новый эл-т становится 1-ым в списке, указатель на
 начало теперь указывает на него }
  end; end;
</pre>
<p>&nbsp;<br>
Удаление элемента из списка <img src="pic/embim1803.gif" width="1" height="1" vspace="1" hspace="1" border="0" alt=""><br>
<img src="pic/embim1804.png" width="160" height="1" vspace="1" hspace="1" border="0" alt=""><br>
&nbsp;<br>
<p>&nbsp;</p>
<p>Удаление элемента из односвязного списка показано на рис. 4. </p>
<img src="pic/clip0140.gif" width="399" height="224" border="0" alt="clip0140"></p>
Рис. 4: Удаление элемента из 1-связного списка</p>
<p>&nbsp;<br>
<p>&nbsp;</p>
<p>Очевидно, что процедуру удаления легко выполнить, если известен адрес элемента, предшествующего удаляемому (prev на рис.4.а). Мы, однако, на рис. 4 и в примере 1 приводим процедуру для случая, когда удаляемый элемент задается своим адресом (del на рис.4). Процедура обеспечивает удаления как из середины, так и из начала списка. </p>
<pre name="code" class="delphi">
{==== Программный пример 1 ====}
 { Удаление элемента из любого места 1-связного списка }
 Procedure DeleteSll(
   var head : sllptr; { указатель на начало списка, может
                        измениться в процедуре }
       del : sllptr   { указатель на эл-т, к-рый удаляется }  );
  var prev : sllptr;  { адрес предыдущего эл-та }
   begin
   if head=nil then begin { попытка удаления из пустого списка 
   асценивается как ошибка (в последующих примерах этот случай 
   учитываться на будет) }
       Writeln('Ошибка!'); Halt;
       end;
   if del=head then { если удаляемый эл-т - 1-й в списке, то 
следующий за ним становится первым }
     head:=del^.next
   else begin { удаление из середины списка }
 
 { приходится искать эл-т, предшествующий удаляемому;
 поиск производится перебором списка с самого его начала,
 пока не будет найдет эл-т, поле next к-рого совпадает
 с адресом удаляемого элемента. }
 
     prev:=head^.next;
     while (prev^.next&lt;&gt;del) and (prev^.next&lt;&gt;nil) do
       prev:=prev^.next;
     if prev^.next=nil then begin
   { это случай, когда перебран весь список, но эл-т не найден,
   он отсутствует в списке; расценивается как ошибка 
   (в последующих примерах этот случай учитываться на будет)
       Writeln('Ошибка!'); Halt;
       end;
     prev^.next:=del^.next;
   { предыдущий эл-т теперь указывает
   на следующий за удаляемым }
     end;
   { элемент исключен из списка, теперь можно освободить 
занимаемую им память }
   Dispose(del);
 end;
 
</pre>
<p>На практике в односвязных списках используется преимущественно операция удаления элемента, следующего за данным, так как проход по всему списку - слишком дорогостоящая операция. Получается, также, что мы не можем быстро удалить текущий элемент. Такую операцию допускает лишь двусвязный список. Удаление элемента из двухсвязного списка показано на рис.5.</p>
<img src="pic/clip0141.gif" width="567" height="137" border="0" alt="clip0141"></p>
Рис. 5: Удаление элемента из 2-связного списка</p>
<p>&nbsp;<br>
<p>&nbsp;</p>
<p>Процедуру удаления элемента из двухсвязного списка окажется даже проще, чем для односвязного, так как в ней не нужен поиск предыдущего элемента, он выбирается по указателю назад. </p>
<p>&nbsp;<br>
Перестановка элементов списка. <img src="pic/embim1805.gif" width="1" height="1" vspace="1" hspace="1" border="0" alt=""><br>
<img src="pic/embim1806.png" width="160" height="1" vspace="1" hspace="1" border="0" alt=""><br>
<p>&nbsp;</p>
<p>Изменчивость динамических структур данных предполагает не только изменения размера структуры, но и изменения связей между элементами. Для связных структур изменение связей не требует пересылки данных в памяти, а только изменения указателей в элементах связной структуры. В качестве примера приведена перестановка двух соседних элементов списка. В алгоритме перестановки в односвязном списке (рис.6, пример 2) исходили из того, что известен адрес элемента, предшествующего паре, в которой производится перестановка. В приведенном алгоритме также не учитывается случай перестановки первого и второго элементов. </p>
<img src="pic/clip0142.gif" width="544" height="83" border="0" alt="clip0142"></p>
Рис. 6: Перестановка соседних элементов 1-связного списка</p>
<p>&nbsp;<br>
<p>&nbsp;</p>
<pre name="code" class="delphi">
 {==== Программный пример 2 ====}
 { Перестановка двух соседних элементов в 1-связном списке }
 Procedure ExchangeSll(
       prev : sllptr   { указатель на эл-т, предшествующий
 переставляемой паре }  );
  var p1, p2 : sllptr;  { указатели на эл-ты пары }
   begin
   p1:=prev^.next;     { указатель на 1-й эл-т пары }
   p2:=p1^.next;       { указатель на 2-й эл-т пары }
   p1^.next:=p2^.next; { 1-й элемент пары теперь указывает на
     следующий за парой }
   p2^.next:=p1;       { 1-й эл-т пары теперь следует за 2-ым }
   prev^.next:=p2;     { 2-й эл-т пары теперь становится 1-ым }
 end;
 
</pre>
<p>В процедуре перестановки для двухсвязного списка (рис.7.) нетрудно учесть и перестановку в начале/конце списка.</p>
<p>&nbsp;<br>
Копирование части списка <img src="pic/embim1807.gif" width="1" height="1" vspace="1" hspace="1" border="0" alt=""><br>
<img src="pic/embim1808.png" width="160" height="1" vspace="1" hspace="1" border="0" alt=""><br>
&nbsp;<br>
<p>&nbsp;</p>
<p>При копировании исходный список сохраняется в памяти, и создается новый список. Информационные поля элементов нового списка содержат те же данные, что и в элементах старого списка, но поля связок в новом списке совершенно другие, поскольку элементы нового списка расположены по другим адресам в памяти. Существенно, что операция копирования предполагает дублирование данных в памяти. Если после создания копии будут изменены данные в исходном списке, то изменение не будет отражено в копии и наоборот. </p>
<img src="pic/clip0143.gif" width="525" height="292" border="0" alt="clip0143"></p>
Рис. 5: Перестановка соседних элементов 2-связного списка</p>
<p>&nbsp;<br>
<p>&nbsp;</p>
<p>Копирование для односвязного списка показано в программном примере 3.</p>
<pre name="code" class="delphi">
 {==== Программный пример 3 ====}
{ Копирование части 1-связного списка. head - указатель на 
начало копируемой части; num - число эл-тов. Ф-ция возвращает
указатель на список-копию }
 Function CopySll ( head : sllptr; num : integer) : sllptr;
  var cur, head2, cur2, prev2 : sllptr;
  begin
    if head=nil then { исходный список пуст - копия пуста }
      CopySll:=nil
    else begin
      cur:=head; prev2:=nil;
      { перебор исходного списка до конца или по счетчику num }
      while (num&gt;0) and (cur&lt;&gt;nil) do begin
  { выделение памяти для эл-та выходного списка и запись в него
 информационной части }
        New(cur2); cur2^.inf:=cur^.inf;
  { если 1-й эл-т выходного списка - запоминается указатель на
 начало, иначе - записывается указатель в предыдущий элемент }
        if prev2&lt;&gt;nil then prev2^.next:=cur2 else head2:=cur2;
        prev2:=cur2;  { текущий эл-т становится предыдущим }
        cur:=cur^.next;  { продвижение по исходному списку }
        num:=num-1;   { подсчет эл-тов }
        end;
      cur2^.next:=nil; { пустой указатель - в последний эл-т
 выходного списка }
      CopySll:=head2;  { вернуть указатель на начало вых.списка }
  end;   end;
</pre>
<p>&nbsp;<br>
Слияние двух списков <img src="pic/embim1809.gif" width="1" height="1" vspace="1" hspace="1" border="0" alt=""><br>
<img src="pic/embim1810.png" width="160" height="1" vspace="1" hspace="1" border="0" alt=""><br>
&nbsp;<br>
<p>&nbsp;</p>
<p>Операция слияния заключается в формировании из двух списков одного - она аналогична операции сцепления строк. В случае односвязного списка, показанном в примере 4, слияние выполняется очень просто. Последний элемент первого списка содержит пустой указатель на следующий элемент, этот указатель служит признаком конца списка. Вместо этого пустого указатель в последний элемент первого списка заносится указатель на начало второго списка. Таким образом, второй список становится продолжением первого. </p>
<pre name="code" class="delphi">
{==== Программный пример 4 ====}
 { Слияние двух списков. head1 и head2 - указатели на начала
 списков. На результирующий список указывает head1 }
 Procedure Unite (var head1, head2 : sllptr);
  var cur : sllptr;
  begin          { если 2-й список пустой - нечего делать }
    if head2&lt;&gt;nil then begin
      { если 1-й список пустой, выходным списком будет 2-й }
    if head1=nil then head1:=head2
    else     { перебор 1-го списка до последнего его эл-та }
     begin  cur:=head1;
      while cur^.next&lt;&gt;nil do cur:=cur^.next;
      { последний эл-т 1-го списка указывает на начало 2-го }
      cur^.next:=head2;
     end;   head2:=nil; { 2-й список аннулируется }
   end; end;
</pre>
<p>&nbsp;<br>
Применение линейных списков <img src="pic/embim1811.gif" width="1" height="1" vspace="1" hspace="1" border="0" alt=""><br>
<img src="pic/embim1812.png" width="160" height="1" vspace="1" hspace="1" border="0" alt=""><br>
&nbsp;<br>
<p>&nbsp;</p>
<p>Линейные списки находят широкое применение в приложениях, где непредсказуемы требования на размер памяти, необходимой для хранения данных; большое число сложных операций над данными, особенно включений и исключений. На базе линейных списков могут строится стеки, очереди и деки. Представление очереди с помощью линейного списка позволяет достаточно просто обеспечить любые желаемые дисциплины обслуживания очереди. Особенно это удобно, когда число элементов в очереди трудно предсказуемо.</p>
<p>В программном примере 5 показана организация стека на односвязном линейном списке. Стек представляется как линейный список, в котором включение элементов всегда производятся в начала списка, а исключение - также из начала. Для представления его нам достаточно иметь один указатель - top, который всегда указывает на последний записанный в стек элемент. В исходном состоянии (при пустом стеке) указатель top - пустой. Процедуры StackPush и StackPop сводятся к включению и исключению элемента в начало списка.</p>
<p>Обратите внимание, что при включении элемента для него выделяется память, а при исключении - освобождается. Перед включением элемента проверяется доступный объем памяти, и если он не позволяет выделить память для нового элемента, стек считается заполненным. При очистке стека последовательно просматривается весь список и уничтожаются его элементы. При списковом представлении стека оказывается непросто определить размер стека. Эта операция могла бы потребовать перебора всего списка с подсчета числа элементов. Чтобы избежать последовательного перебора всего списка мы ввели дополнительную переменную stsize, которая отражает текущее число элементов в стеке и корректируется при каждом включении/исключении. </p>
<pre name="code" class="delphi">
 {==== Программный пример 5 ====}
 { Стек на 1-связном линейном списке }
 unit Stack;
 Interface
 type data = ...; { эл-ты могут иметь любой тип }
 Procedure StackInit;
 Procedure StackClr;
 Function StackPush(a : data) : boolean;
 Function StackPop(Var a : data) : boolean;
 Function StackSize : integer;
 Implementation
 type stptr = ^stit;  { указатель на эл-т списка }
      stit = record   { элемент списка }
        inf : data;   { данные }
        next: stptr;  { указатель на следующий эл-т }
        end;
 Var top : stptr; { указатель на вершину стека }
     stsize : longint;  { размер стека }
 {** инициализация - список пустой }
 Procedure StackInit;
   begin   top:=nil; stsize:=0;  end; { StackInit }
 {** очистка - освобождение всей памяти }
 Procedure StackClr;
  var x : stptr;
   begin   { перебор эл-тов до конца списка и их уничтожение }
   while top&lt;&gt;nil do
     begin  x:=top; top:=top^.next; Dispose(x);  end;
   stsize:=0;
 end; { StackClr }
 Function StackPush(a: data) : boolean;   { занесение в стек }
  var x : stptr;
   begin      { если нет больше свободной памяти - отказ }
   if MaxAvail &lt; SizeOf(stit) then StackPush:=false
   else   { выделение памяти для эл-та и заполнение инф.части }
     begin  New(x); x^.inf:=a;
                { новый эл-т помещается в голову списка }
       x^.next:=top; top:=x;
       stsize:=stsize+1; { коррекция размера }
       StackPush:=true;
     end;
 end; { StackPush }
 Function StackPop(var a: data) : boolean; { выборка из стека }
  var x : stptr;
   begin
   { список пуст - стек пуст }
   if top=nil then StackPop:=false
   else begin
     a:=top^.inf; { выборка информации из 1-го эл-та списка }
     { 1-й эл-т исключается из списка, освобождается память }
     x:=top; top:=top^.next; Dispose(top);
     stsize:=stsize-1; { коррекция размера }
     StackPop:=true;
 end;  end; { StackPop }
 Function StackSize : integer;  { определение размера стека }
   begin   StackSize:=stsize;   end; { StackSize }
 END.
</pre>
<p>Программный пример для организация на односвязном линейном списке очереди FIFO разработайте самостоятельно. Для линейного списка, представляющего очередь, необходимо будет сохранять: top - на первый элемент списка, и bottom - на последний элемент. </p>
<p>Линейные связные списки иногда используются также для представления таблиц - в тех случаях, когда размер таблицы может существенно изменяться в процессе ее существования. Однако, то обстоятельство, что доступ к элементам связного линейного списка может быть только последовательным, не позволяет применить к такой таблице эффективный двоичный поиск, что существенно ограничивает их применимость. Поскольку упорядоченность такой таблицы не может помочь в организации поиска, задачи сортировки таблиц, представленных линейными связными списками, возникают значительно реже, чем для таблиц в векторном представлении. Однако, в некоторых случаях для таблицы, хотя и не требуется частое выполнение поиска, но задача генерации отчетов требует расположения записей таблицы в некотором порядке. Некоторые алгоритмы, возможно, потребуют каких-либо усложнений структуры, например, быструю сортировку Хоара целесообразно проводить только на двухсвязном списке, в цифровой сортировке удобно создавать промежуточные списке для цифровых групп и т.д. Мы приведем два простейших примера сортировки односвязного линейного списка. В обоих случаях мы предполагаем, что определены типы данных: </p>
<pre name="code" class="delphi">
  type lptr = ^item; { указатель на элемент списка }
          item = record    { элемент списка }
            key : integer; { ключ }
            inf : data;    { данные }
            next: lptr;    { указатель на элемент списка }
            end;
</pre>
<p>В обоих случаях сортировка ведется по возрастанию ключей. В обоих случаях параметром функции сортировки является указатель на начало неотсортированного списка, функция возвращает указатель на начало отсортированного списка. Прежний, несортированный список перестает существовать.</p>
<p>Пример 6 демонстрирует сортировку выборкой. Указатель newh является указателем на начало выходного списка, исходно - пустого. Во входном списке ищется максимальный элемент. Найденный элемент исключается из входного списка и включается в начало выходного списка. Работа алгоритма заканчивается, когда входной список станет пустым. Обратим внимание читателя на несколько особенностей алгоритма. Во-первых, во входном списке ищется всякий раз не минимальный, а максимальный элемент. Поскольку элемент включается в начало выходного списка, элементы с большими ключами оттесняются к концу выходного списка и последний, таким образом, оказывается отсортированным по возрастанию ключей. Во-вторых, при поиске во входном списке сохраняется не только адрес найденного элемента в списке, но и адрес предшествующего ему в списке эле- мента - это впоследствии облегчает исключение элемента из списка (вспомните пример 1). В-третьих, обратите внимание на то, что у нас не возникает никаких проблем с пропуском во входном списке тех элементов, которые уже выбраны - они просто исключены из входной структуры данных. </p>
<pre name="code" class="delphi">
 {==== Программный пример 6 ====}
 { Сортировка выборкой на 1-связном списке }
 Function Sort(head : lptr) : lptr;
  var newh, max, prev, pmax, cur : lptr;
   begin        newh:=nil;         { выходной список - пустой }
   while head&lt;&gt;nil do { цикл, пока не опустеет входной список }
     begin   max:=head; prev:=head; { нач.максимум - 1-й эл-т }
     cur:=head^.next;     { поиск максимума во входном списке }
     while cur&lt;&gt;nil do begin
       if cur^.key&gt;max^.key then begin
{ запоминается адрес максимума и адрес предыдущего эл-та }
         max:=cur; pmax:=prev;
     end;    prev:=cur; cur:=cur^.next; { движение по списку }
       end;        { исключение максимума из входного списка }
     if max=head then head:=head^.next
     else pmax^.next:=max^.next;
     { вставка в начало выходного списка }
     max^.next:=newh; newh:=max;
   end;  Sort:=newh;
  end;
</pre>

<p>В программном примере 7 - иллюстрации сортировки вставками - из входного списка выбирается (и исключается) первый элемент и вставляется в выходной список "на свое место" в соответствии со значениями ключей. Обратите внимание на то, что в двух последних примерах пересылок данных не происходит, все записи таблиц остаются на своих местах в памяти, меняются только связи между ними - указатели. </p>
<pre name="code" class="delphi">
 {==== Программный пример 7 ====}
 { Сортировка вставками на 1-связном списке }
 type data = integer;
 Function Sort(head : lptr) : lptr;
  var newh, cur, sel : lptr;
   begin
   newh:=nil;  { выходной список - пустой }
   while head &lt;&gt; nil do begin { цикл, пока не опустеет входной список }
     sel:=head;  { эл-т, который переносится в выходной список }
     head:=head^.next;         { продвижение во входном списке }
     if (newh=nil) or (sel^.key &lt; newh^.key) then begin
{выходной список пустой или элемент меньше 1-го-вставка в начало}
     sel^.next:=newh; newh:=sel;   end
     else begin                { вставка в середину или в конец }
       cur:=newh;
{ до конца выходного списка или пока ключ следующего эл-та не будет
 больше вставляемого }
       while (cur^.next &lt;&gt; nil) and (cur^.next^.key &lt; sel^.key) do
         cur:=cur^.next;
       { вставка в выходной список после эл-та cur }
       sel^.next:=cur^.next;    cur^.next:=sel;
      end;   end;   Sort:=newh;
  end;
 
</pre>
<p>&nbsp;<br>
Мультисписки <img src="pic/embim1813.gif" width="1" height="1" vspace="1" hspace="1" border="0" alt=""><br>
<img src="pic/embim1814.png" width="160" height="1" vspace="1" hspace="1" border="0" alt=""><br>
&nbsp;<br>
<p>&nbsp;</p>
<p>В программных системах, обрабатывающих объекты сложной структуры, могут решаться разные подзадачи, каждая из которых требует, возможно, обработки не всего множества объектов, а лишь какого-то его подмножества. Так, например, в автоматизированной системе учета лиц, пострадавших вследствие аварии на ЧАЭС, каждая запись об одном пострадавшем содержит более 50 полей в своей информационной части. Решаемые же автоматизированной системой задачи могут потребовать выборки, например: </p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>участников ликвидации аварии; </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>переселенцев из зараженной зоны; </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>лиц, состоящих на квартирном учете; </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>лиц с заболеваниями щитовидной железы; </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 7px 0px 7px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>и т.д., и т.п. </td></tr></table></div><img src="pic/clip0144.gif" width="398" height="438" border="0" alt="clip0144"></p>
Рис. 8: Пример мультисписка</p>
<p>&nbsp;<br>
<p>&nbsp;</p>
<p>Для того, чтобы при выборке каждого подмножества не выполнять полный просмотр с отсеиванием записей, к требуемому подмножеству не относящихся, в каждую запись включаются дополнительные поля ссылок, каждое из которых связывает в линейный список элементы соответствующего подмножества. В результате получается многосвязный список или мультисписок, каждый элемент которого может входить одновременно в несколько односвязных списков. Пример такого мультисписка для названной нами автоматизированной системы показан на рис.8. </p>
<p>К достоинствам мультисписков помимо экономии памяти (при множестве списков информационная часть существует в единственном экземпляре) следует отнести также целостность данных - в том смысле, что все подзадачи работают с одной и той же версией информационной части и изменения в данных, сделанные одной подзадачей немедленно становятся доступными для другой подзадачи. </p>
<p>Каждая подзадача работает со своим подмножеством как с линейным списком, используя для этого определенное поле связок. Специфика мультисписка проявляется только в операции исключения элемента из списка. Исключение элемента из какого-либо одного списка еще не означает необходимости удаления элемента из памяти, так как элемент может оставаться в составе других списков. Память должна освобождаться только в том случае, когда элемент уже не входит ни в один из частных списков мультисписка. Обычно задача удаления упрощается тем, что один из частных списков является главным - в него обязательно входят все имеющиеся элементы. Тогда исключение элемента из любого неглавного списка состоит только в переопределении указателей, но не в освобождении памяти. Исключение же из главного списка требует не только освобождения памяти, но и переопределения указателей как в главном списке, так и во всех неглавных списках, в которые удаляемый элемент входил. </p>
<p><a href="http://algolist.manual.ru" target="_blank">http://algolist.manual.ru</a></p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
