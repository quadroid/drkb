<!DOCTYPE html>
<html>
<head>
  <title>Метаклассы</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Метаклассы</h1>
<div id="date">01.01.2010</div>

<p>МЕТАКЛАССЫ</p>
<p>ССЫЛКИ НА КЛАССЫ</p>
<p>Язык Object Pascal позволяет рассматривать классы как своего рода объекты, которыми можно манипулировать в программе. Такая возможность рождает новое понятие &#8212; класс класса; его принято обозначать термином метакласс.</p>
<p>Для поддержки метаклассов введен специальный тип данных &#8212; ссылка на класс (class reference). Он описывается с помощью словосочетания class of, например:</p>
<pre name="code" class="delphi">
type
  TResourceGaugeClass = class of TResourceGauge;
</pre>
&nbsp;</p>
<p>Переменная типа TResourceGaugeClass объявляется в программе обычным образом:</p>
<pre name="code" class="delphi">
var
  ClassRef: TResourceGaugeClass;
</pre>
&nbsp;</p>
<p>Значениями переменной ClassRef могут быть класс TResourceGauge и все порожденные от него классы. Допустимы, например, следующие операторы:</p>
<pre name="code" class="delphi">
ClassRef := TResourceGauge;
ClassRef := TDiskGauge;
ClassRef := TMemoryGauge;
</pre>
&nbsp;</p>
<p>По аналогии с тем, как для всех классов существует общий предок TObject, у ссылок на классы существует базовый тип TCIass:</p>
<pre name="code" class="delphi">
type TCIass = class of TObject;
</pre>
&nbsp;</p>
<p>Переменная типа TCIass может ссылаться на любой класс.</p>
<p>Практическая ценность ссылок на классы состоит в возможности создавать программные модули, работающие с любыми классами объектов, даже с теми, которые еще не разработаны.</p>
<p>МЕТОДЫ КЛАССОВ</p>
<p>Метаклассы привели к возникновению нового типа методов &#8212; методов класса. Метод класса оперирует не экземпляром объекта, а непосредственно классом. Он объявляется как обычный метод, но перед словом procedure или function записывается зарезервированное слово class, например:</p>
<pre name="code" class="delphi">
type
  TResourceGauge = class
     ...
    class function GetClassName : string;
  end;
</pre>
&nbsp;</p>
<p>Псевдопараметр Self, передаваемый в метод класса, содержит не ссылку на объект, а ссылку на класс, поэтому в теле метода нельзя обращаться к полям, методам и свойствам объекта. Зато можно вызывать другие методы класса, например:</p>
<pre name="code" class="delphi">
class function TResourceGauge.GetClassName: string;
begin
  Result := ClassName;
end;
</pre>
&nbsp;</p>
<p>Метод ClassName объявлен в классе TObject и возвращает имя класса, к которому применяется. Очевидно, что надуманный метод GetClassName просто дублирует эту функциональность для класса TResourceGauge и всех его наследников.</p>
<p>Методы класса применимы и к классам, и к объектам. В обоих случаях в параметре Self передается ссылка на класс объекта. Пример:</p>
<pre name="code" class="delphi">
var
  Gauge: TResourceGauge;
  S: string;
begin
  { Вызов метода с помощью ссылки на класс }
  S := TDiskGauge.GetClassName; { S получит значение 'TDiskGauge' }
  Gauge := TDiskGauge.Create('С');
  { Вызов метода с помощью ссылки на объект }
  S := Gauge.GetClassName;    { S получит значение 'TDiskGauge' }
end;
</pre>
<p>Методы классов могут быть виртуальными. Например, в классе TObject определен виртуальный метод класса Newlnstance. Он служит для распределения памяти под объект и автоматически вызывается конструктором. Его можно перекрыть в своем классе, чтобы обеспечить нестандартный способ выделения памяти для экземпляров. Метод Newlnstance должен перекрываться вместе с другим методом Freelnstance, который автоматически вызывается из деструктора и служит для освобождения памяти. Добавим, что размер памяти, требуемый для экземпляра, можно узнать вызовом предопределенного метода класса InstanceSize.</p>
<p>ВИРТУАЛЬНЫЕ КОНСТРУКТОРЫ</p>
<p>Особая мощь ссылок на классы проявляется в сочетании с виртуальными конструкторами. Виртуальный конструктор объявляется с ключевым словом virtual. Вызов виртуального конструктора происходит по фактическому значению ссылки на класс, а не по ее формальному типу. Это позволяет создавать объекты, классы которых неизвестны на этапе компиляции. Механизм виртуальных конструкторов применяется в Delphi при создании форм и компонентов.</p>
<p>На этом закончим изучение теории объектно-ориентированного программирования и в качестве практики рассмотрим несколько широко используемых инструментальных классов Delphi. Разберитесь с их назначением и работой. Это поможет глубже понять ООП и пригодится на будущее.</p>
<p>КЛАССЫ ОБЩЕГО НАЗНАЧЕНИЯ В DELPHI</p>
<p>Как показывает практика, в большинстве задач приходится использовать однотипные структуры данных: списки, массивы, множества и т.д. От задачи к задаче изменяются только их элементы, а методы работы сохраняются. Например, для любого списка нужны процедуры вставки и удаления элементов. В связи с этим возникает естественное желание решить задачу «в общем виде», т.е. создать универсальные средства для управления основными структурами данных. Эта идея не нова. Она давно пришла в голову разработчикам инструментальных пакетов, которые быстро наплодили множество вспомогательных библиотек. Эти библиотеки содержали классы объектов для работы со списками, коллекциями (динамические массивы с переменным количеством элементов), словарями (коллекции, индексированные строками) и другими «абстрактными» структурами. Для Delphi тоже разработаны аналогичные классы объектов. Их большая часть сосредоточена в модуле Classes. Наиболее нужными для вас являются списки строк (TStrings, TStringList) и потоки (TSream, THandleSream, TFileStream, TMemoryStream и TBIobStream). Рассмотрим кратко их назначение и применение.</p>
<p>КЛАССЫ ДЛЯ ПРЕДСТАВЛЕНИЯ СПИСКА СТРОК</p>
<p>Для работы со списками строк служат классы TStrings и TStringList. Они используются в библиотеке VCL повсеместно и имеют гораздо большую универсальность, чем та, что можно почерпнуть из их названия. Классы TStrings и TStringList служат для представления не просто списка строк, а списка элементов, каждый из которых представляет собой пару строка-объект. Если со строками не ассоциированы объекты, получается обычный список строк.</p>
<p>Класс TStrings используется визуальными компонентами и является абстрактным. Он не имеет собственных средств хранения строк и определяет лишь интерфейс для работы с элементами. Класс TStringList является наследником TStrings и служит для организации списков строк, которые используются отдельно от управляющих элементов. Объекты TStringList хранят строки и объекты в динамической памяти.</p>
<p>Свойства класса TStrings описаны ниже.</p>
<p>Count: Integer &#8212; число элементов в списке.</p>
<p>Strings[lndex: Integer]: string &#8212; обеспечивает доступ к массиву строк по индексу. Первая строка имеет индекс, равный 0. Свойство Strings является основным свойством объекта.</p>
<p>Objects[lndex: Integer]: TObject &#8212; обеспечивает доступ к массиву объектов. Свойства Strings и Objects позволяют использовать объект TStrings как хранилище строк и ассоциированных с ними объектов произвольных классов.</p>
<p>Text: string &#8212; позволяет интерпретировать список строк как одну большую строку, в которой элементы разделены символами #13#10 (возврат каретки и перевод строки),</p>
<p>Наследники класса TStrings иногда используются для хранения строк вида Имя=3начение, в частности, строк INI-файлов (см. гл. 6). Для удобной работы со строками такой структуры в классе TStrings дополнительно имеются следующие свойства.</p>
<p>Names[lndex: Integer]: string &#8212; обеспечивает доступ к той части строки, в которой содержится имя.</p>
<p>Values[const Name: string]: string &#8212; обеспечивает доступ к той части строки, в которой содержится значение. Указывая вместо Name ту часть строки, которая находится слева от знака равенства, вы получаете ту часть, что находится справа.</p>
<p>Управление элементами списка осуществляется с помощью следующих методов:</p>
<p>Add(const S: string): Integer &#8212; добавляет новую строку S в список и возвращает ее позицию. Новая строка добавляется в конец списка.</p>
<p>Add0bject(const S: string; AObject: TObject): Integer &#8212; добавляет в список строку S и ассоциированный с ней объект AObject. Возвращает индекс пары строка&#8212;объект.</p>
<p>AddStrings(Strings: TStrings) &#8212; добавляет группу строк в существующий список. Append(const S: string) &#8212; делает то же, что и Add, но не возвращает значения. Clear &#8212; удаляет из списка все элементы.</p>
<p>Delete(lndex: Integer) &#8212; удаляет строку и ассоциированный с ней объект. Метод Delete, так же как метод Clear, не разрушает объектов, т.е. не вызывает у них деструктор. Об этом вы должны позаботиться сами.</p>
<p>Equals(Strings: TStrings): Boolean &#8212; возвращает True, если список строк в точности равен тому, что передан в параметре Strings.</p>
<p>Exchange(lndex1, lndex2: Integer) &#8212; меняет два элемента местами.</p>
<p>GetText: PChar &#8212; возвращает все строки списка в виде одной большой нуль-терминированной строки.</p>
<p>lndex0f(const S: string): Integer &#8212; возвращает позицию строки S в списке. Если заданная строка в списке отсутствует, функция возвращает значение &#8212;1.</p>
<p>lndexOfName(const Name: string): Integer &#8212; возвращает позицию строки, которая имеет вид Имя=3начение и содержит в себе Имя, равное Name.</p>
<p>lndexOfObject(AObject: TObject): Integer &#8212; возвращает позицию объекта AObject в массиве Objects. Если заданный объект в списке отсутствует, функция возвращает значение &#8212;1.</p>
<p>lnsert(lndex: Integer; const S: string) &#8212; вставляет в список строку S в позицию Index.</p>
<p>lnsert0bject(lndex: Integer; const S: string; AObject: TObject) &#8212; вставляет в список строку S и ассоциированный с ней объект AObject в позицию Index.</p>
<p>LoadFromFile(const FileName: string) &#8212; загружает строки списка из текстового файла.</p>
<p>LoadFromStream(Stream: TStream) &#8212; загружает строки списка из потока данных (см. ниже).</p>
<p>Move(Curlndex, Newlndex: Integer) &#8212; изменяет позицию элемента (пары строка-объект) в списке.</p>
<p>SaveToFile(const FileName: string) &#8212; сохраняет строки списка в текстовом файле.</p>
<p>SaveToStream(Stream: TStream) &#8212; сохраняет строки списка в потоке данных.</p>
<p>SetText(Text: PChar) &#8212; загружает строки списка из одной большой нуль-терминированной строки.</p>
<p>Класс TStringList добавляет к TStrings несколько дополнительных свойств и методов, а также два свойства-события для уведомления об изменениях в списке. Они описаны ниже.</p>
<p>Свойства:</p>
<p>Duplicates: TDuplicates &#8212; определяет, разрешено ли использовать дублированные строки в списке. Свойство может принимать следующие значения: duplgnore (дубликаты игнорируются), dupAccept (дубликаты разрешены), dupError (дубликаты запрещены, попытка добавить в список дубликат вызывает ошибку).</p>
<p>Sorted: Boolean &#8212; если имеет значение True, то строки автоматически сортируются в алфавитном порядке.</p>
<p>Методы:</p>
<p>Find(const S: string; var Index: Integer): Boolean &#8212; выполняет поиск строки S в списке строк. Если строка найдена, Find помещает ее позицию в переменную, переданную в параметре Index, и возвращает True.</p>
<p>Sort &#8212; сортирует строки в алфавитном порядке.</p>
<p>События:</p>
<p>OnChange: TNotifyEvent &#8212; указывает на обработчик события, который выполнится при изменении содержимого списка. Событие OnChange генерируется после того, как были сделаны изменения.</p>
<p>OnChanging: TNotifyEvent &#8212; указывает на обработчик события, который выполнится при изменении содержимого списка. Событие OnChanging генерируется перед тем, как будут сделаны изменения.</p>
<p>Ниже приводится фрагмент программы, демонстрирующий создание списка строк и манипулирование его элементами:</p>
<pre name="code" class="delphi">
var
  Items: TStrings;
  I: Integer;
begin
  { Создание списка }
  Items := TStringList.Create;
  Items.Add('Туризм');
  Items.Add('Наука');
  Items.Insert(1, 'Бизнес');
  ...
  { Работа со списком }
  for I := 0 to Items. Count - 1 do
   Items[I] := Uppercase(Items [I]);
  ...
   { Удаление списка }
   Items.Free;
end;
</pre>
&nbsp;</p>
<p>КЛАССЫ ДЛЯ ПРЕДСТАВЛЕНИЯ ПОТОКА ДАННЫХ</p>
<p>В Delphi существует иерархия классов для хранения и последовательного ввода-вывода данных. Классы этой иерархии называются потоками. Потоки лучше всего представлять как файлы. Классы потоков обеспечивают различное физическое представление данных:</p>
<p>файл на диске, раздел оперативной памяти, поле в таблице базы данных (см. табл. 1).</p>
<p>Таблица 1.</p>
<p>Класс &nbsp; &nbsp; &nbsp; &nbsp;Описание &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>TStream &nbsp; &nbsp; &nbsp; &nbsp;Абстрактный поток, от которого наследуются все остальные. Свойства и методы класса TStream образуют базовый интерфейс потоковых объектов. &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>THandleStream &nbsp; &nbsp; &nbsp; &nbsp;Поток, который хранит свои данные в файле. Для чтения-записи файла используется дескриптор (handle), поэтому поток называется дескрипторным. Дескриптор - это номер открытого файла в операционной системе. Его возвращают низкоуровневые функции создания и открытия файла. &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>TFileStream &nbsp; &nbsp; &nbsp; &nbsp;Поток, который хранит свои данные в файле. Отличается от ThandleStream тем, что сам открывает (создает) файл по имени, переданному в конструктор. &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>TMemoryStream &nbsp; &nbsp; &nbsp; &nbsp;Поток, который хранит свои данные в оперативной памяти. Моделирует работу с файлом. Используется для хранения промежуточных результатов, когда файловый поток не подходит из-за низкой скорости передачи данных. &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>TResourceStream &nbsp; &nbsp; &nbsp; &nbsp;Поток, обеспечивающий доступ к ресурсам в Windows-приложении. &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>TBIobStream &nbsp; &nbsp; &nbsp; &nbsp;Обеспечивает последовательный доступ к большим полям таблиц в базах данных. &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>Потоки широко применяются в библиотеке VCL и наверняка вам понадобятся. Поэтому ниже кратко перечислены их общие ключевые свойства и методы.</p>
<p>Общие свойства:</p>
Position: Longint &#8212; текущая позиция чтения-записи.</p>
Size: Longint &#8212; текущий размер потока в байтах.</p>
<p>Общие методы:</p>
<p>CopyFrom(Source: TStream; Count: Longint): Longint &#8212; копирует Count байт из потока Source в свой поток.</p>
<p>Read(var Buffer; Count: Longint): Longint &#8212; читает Count байт из потока в буфер Buffer, продвигает текущую позицию на Count байт вперед и возвращает число прочитанных байт. Если значение функции меньше значения Count, то в результате чтения был достигнут конец потока.</p>
<p>ReadBuffer(var Buffer; Count: Longint) &#8212; читает из потока Count байт в буфер Buffer и продвигает текущую позицию на Count байт вперед. Если выполняется попытка чтения за концом потока, то генерируется ошибка.</p>
<p>Seek(0ffset: Longint; Origin: Word): Longint &#8212; продвигает текущую позицию в потоке на Offset байт относительно позиции, заданной параметром Origin. Параметр Origin может иметь одно из следующих значений: 0 &#8212; смещение задается относительно начала потока; 1 &#8212; смещение задается относительно текущей позиции в потоке; 2 &#8212; смещение задается относительно конца потока.</p>
<p>Write(const Buffer; Count: Longint): Longint &#8212; записывает в поток Count байт из буфера Buffer, продвигает текущую позицию на Count байт вперед и возвращает реально записанное количество байт. Если значение функции отличается от значения Count, то при записи была ошибка.</p>
<p>WriteBuffer(const Buffer; Count: Longint) &#8212; записывает в поток Count байт из буфера Buffer и продвигает текущую позицию на Count байт вперед. Если по какой-либо причине невозможно записать все байты буфера, то генерируется ошибка.</p>
<p>Ниже приводится фрагмент программы, демонстрирующий создание файлового потока и запись в него строки:</p>
<pre name="code" class="delphi">
var
  Stream: TStream;
  S: AnsiString;
  StrLen: Integer;
begin
  { Создание файлового потока }
  Stream := TFileStream.Create('Sample.Dat', fmCreate);
  ...
  { Запись в поток некоторой строки }
  StrLen := Length(S) * SizeOf(Char);
  Stream.Write (StrLen, SizeOf (Integer) ) ; { запись длины строки }
  Stream.Write (S, StrLen);              { запись символов строки }
  ...
  { Закрытие потока }
  Stream.Free;
end;
</pre>
&nbsp;</p>
<p>итоги</p>
<p>Теперь для вас нет секретов в мире ООП. Вы на достаточно серьезном уровне познакомились с объектами и их свойствами; узнали, как объекты создаются, используются и уничтожаются. Если не все удалось запомнить сразу &#8212; не беда. Возвращайтесь к материалам главы по мере решения стоящих перед вами задач, и работа с объектами станет простой, естественной и даже приятной. Когда вы добьетесь понимания того, как работает один объект, то автоматически поймете, как работают все остальные. Теперь мы рассмотрим то, с чем вы встретитесь очень скоро &#8212; ошибки программирования.</p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
