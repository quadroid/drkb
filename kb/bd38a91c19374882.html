<!DOCTYPE html>
<html>
<head>
  <title>Алгоритмы теории графов</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Алгоритмы теории графов</h1>
<div id="date">01.01.2010</div>

<p>К сожалению только на украинском языке</p>
<p>АЛГОРИТМИ ТЕОРІЇ ГРАФІВ</p>
<p>Основні визначення теорії графів</p>
<p>Орієнтований граф, як пишуть у [1] &#8211; це «пара (V, E), де V &#8211; кінцева множина, а E &#8211; бінарне відношення на V, тобто підмножина множини V*V… …множину V називають множиною вершин графа, а множину E &#8211; множиною ребер».</p>
<p>У неорієнтованому графі множина V складається з неупорядкованих пар вершин. Парою називається множина {u,v}, де u і v належать V.</p>
<p>Якщо в графі є ребро (u,v), то говорять, що вершина u суміжна з вершиною v. Для неорієнтованих графів відношення суміжності є симетричним.</p>
<p>Шлях довжини k з вершини u у вершину v визначається як послідовність вершин v0, v1, v2, … vk, у який v0 = u, vk = v, а (vi-1, vi) &#8211; ребро графа.</p>
<p>Циклом в орієнтованому графі називається шлях, у якому початкова вершина збігається з кінцевою і який містить хоча б одне ребро. Граф, у якому немає циклів, називається ациклічним.</p>
<p>Представлення графів</p>
<p>Є два стандартних способи представлення графів: як список суміжних вершин чи як матрицю суміжності. Обидва способи мають свої плюси і недоліки.</p>
<p>Список суміжних вершин дуже зручний при представленні розріджених графів. Він дає вигідне зменшення займаного обсягу пам'яті. Але при цьому цей спосіб не дає можливості швидко перевірити наявність ребра між двома довільними вершинами. Це представлення графу використовує масив списків по одному списку для кожної вершини. Список зберігає усі вершини, суміжні з даною вершиною в довільному порядку.</p>
<p>Матриця суміжності займає більший обсяг пам'яті, але зручна для представлення щільних графів. Тут кожен елемент Mij матриці позначає наявність ребра межу вершиною i та вершиною j. Якщо граф &#8211; зважений, то Mij може позначати вагу ребра (i,j).</p>
<p>Алгоритм пошуку в ширину</p>
<p>Алгоритм пошуку в ширину (Breadth-first search) &#8211; один з базисних алгоритмів, що є основою багатьох інших. Наприклад, алгоритм Дейкстри пошуку найкоротших шляхів з однієї вершини й алгоритм Прима пошуку мінімального покриваючого дерева можуть розглядатися як узагальнення пошуку в ширину..</p>
<p>Нехай заданий граф G і фіксована початкова вершина s. Алгоритм пошуку в ширину перелічує всі досяжні з s (якщо йти по ребрах) вершини в порядку збільшення відстані від s. У процесі пошуку з графу виділяється частина, що називається «деревом пошуку в ширину» з коренем s. Вона містить усі досяжні з s вершини (і тільки їх). Для кожної з них шлях з кореня в дереві пошуку буде одним з найкоротших шляхів до s. Алгоритм можна застосувати і до орієнтованих, і до неорієнтованих графів.</p>
<p>Назва пояснюється тим, що в процесі пошуку ми йдемо в широчінь, а не в глиб (з початку переглядаємо сусідні вершини, потім сусідів сусідів, і т.д.).</p>
<p>Для наочності будемо вважати, що в процесі роботи алгоритму вершини графа можуть бути білими, сірими і чорними. Спочатку вони всі білі, а в ході роботи алгоритму біла вершина може стати сірою, сіра - чорною, але не навпаки. Зустрівши нову вершину, алгоритм пошуку фарбує її, так що сірі і чорні вершини - уже виявлені вершини. Різниця між сірими і чорними вершинами використовується алгоритмом для керування порядком обходу: сірі вершини утворять "лінію фронту", а чорні - "тил". Таким чином, тільки сірі вершини можуть мати суміжні невиявлені вершини.</p>
<p>Спочатку дерево пошуку складається тільки з початкової вершини s. Як тільки алгоритм виявляє нову вершину v, суміжну з раніше знайденою вершиною u, вершина v разом з ребром (u, v) додається до дерева пошуку, стаючи дитиною вершини u, а u стає батьком v. Кожна вершина виявляється тільки один раз, так що двох батьків у вершини бути не може.</p>
<p>Оцінюючи складність цього алгоритму, ми зауважуємо, що вершини тільки сутеніють, отже, кожна вершина обробляється тільки один раз. При цьому для обходу суміжних вершин для даної вершини використовується часу O(E). Отже, обчислювальна складність алгоритму пошуку в ширину &#8211; O(V+E), де V &#8211; кількість вершин у графі, а E &#8211; кількість ребер.</p>
<p>Алгоритм пошуку в глибину</p>
<p>Пошук у глибину &#8211; ще один спосіб обходу графу. Він застосовується в таких алгоритмах, як алгоритм топологічного сортування, алгоритм пошуку сильно зв'язаних компонентів.</p>
<p>Стратегія пошуку в глибину така: йти вглиб, поки це можливо (є непройдені вихідні ребра), повертатися і шукати інший шлях, коли таких ребер немає. Якщо після цього залишаються недоторкані вершини - можна вибрати одну з них і повторювати процес доти, поки залишаються невиявлені вершини.</p>
<p>Знайшовши уперше вершину v, суміжну з u, ми відзначаємо цю подію, записуючи в поле ?[v] значення u. Утворюється дерево чи кілька дерев.</p>
<p>Як і пошук у ширину, алгоритм пошуку в глибину використовує кольори вершин. Спочатку усі вершини - білі. При виявленні нової вершини, вона фарбується в сірий колір. Коли вершина цілком оброблена, вона фарбується в чорний колір.</p>
<p>Крім цього пошук у глибину ставить на вершинах мітки часу. Кожна вершина має дві мітки: d[v] показує, коли вершина була виявлена, f[v] - коли оброблена. Ці мітки використовуються в багатьох алгоритмах на графах.</p>
<p>Під час виконання цього алгоритму, обробка кожної вершини відбувається рівно один раз. Отже, складність роботи даного алгоритму становить O(V+E), де V &#8211; кількість вершин у графі, а E &#8211; кількість ребер.</p>
<p>Алгоритм Дейкстри пошуку найкоротших шляхів</p>
<p>Уявимо собі карту автомобільних шляхів України. Як знайти найкоротший шлях із Дніпропетровська в Київ? Можна, звичайно, перебрати всі можливі варіанти і вибрати мінімальний з них. Але тоді ми одержуємо мільйони свідомо невірних операцій (наприклад, навіщо нам їхати з Дніпропетровська в Київ через Донецьк, що знаходиться зовсім в іншому боці). Далі буде розглянутий спосіб ефективного рішення цієї задачі.</p>
<p>Тут буде розглядатися тільки пошук найкоротших шляхів з однієї вершини: даний зважений граф G і початкова вершина s. Потрібно знайти всі найкоротші шляхи з s в усі вершини графу. Алгоритм Дейкстри здатний знайти найкоротший шлях тільки для графів, у яких усі ребра недодатньої ваги.</p>
<p>Багато алгоритмів пошуку найкоротших шляхів використовують особливу техніку &#8211; техніку релаксації. І алгоритм Дейскстри &#8211; не виключення. Техніка релаксації полягає в наступному: для кожної вершини v ми зберігаємо деяке число d[v], що є верхньою оцінкою ваги найкоротшого шляху з s у v. Початкове значення оцінки найкоротшого шляху і масиву ? (масиву предків) задається наступною процедурою:</p>
<p>Initialize-Single-Source(G, s)</p>
<p>1 for (для) усіх вершин v</p>
<p>2&nbsp; do d[v] = ?</p>
<p>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?[v] = NIL</p>
<p>4 d[s] = 0</p>
<p>Релаксація ребра (u,v) полягає в наступному: значення d[v] зменшується до d[u]+w(u,v) (якщо друге значення менше попереднього). При цьому d[v] залишається верхньою оцінкою.</p>
<p>Relax(u, v, w)</p>
<p>1 if d[v] &gt; d[u] + w(u,w)</p>
<p>2&nbsp; then d[v] = d[u] + w(u,w)</p>
<p>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?[v] = u</p>
<p>По своїй суттевості, алгоритм Дейкстри є жадним алгоритмом.</p>
<p>У процесі роботи алгоритму Дейкстри підтримується множина S, що складається з вершин v, для яких знайдений найкоротший шлях. Алгоритм вибирає вершину u з найменшим d[u], додає її до множини S і здійснює релаксацію всіх ребер, що виходять з u, після чого цикл повторюється.</p>
<p>Складність роботи алгоритму Дейкстри становить O(V2)</p>
<p>Пошук максимального паросполучення</p>
<p>Нехай G(V, E) - неорієнтований граф. Паросполученням назвемо множину ребер M, що не мають спільних кінців (кожна вершина v з V є кінцем максимум одного ребра з M). Будемо говорити, що вершина v з V входить у паросполучення M, якщо в M є ребро з кінцем v. У противному випадку v вільна. Максимальне паросполучення - це паросполучення M, що містить максимально можливе число ребер.</p>
<p>Для рішення задачі про найбільше паросполучення використовується метод ланцюгів, що чергуються. Нехай M - паросполучення в двочастковому графі G. Ланцюг, у який по черзі входять ребра з M і з "не-M", назвемо ланцюгом, що чергується. Вершини, инцидентні ребрам з M, назвемо насиченими. Чергуючийся відносно M ланцюг з ненасиченими вершинами називається ланцюгом, що збільшує, відносно M.</p>
<p>Паросполучення M є максимальним тоді і тільки тоді, коли немає збільшуючих відносно M ланцюгів</p>
<p>Для задач про максимальне паросполучення є безліч метафор. Ось одна з них: є множина чоловіків і множина наречених. Ребро (u,v) означає, що чоловік u і наречена v згодні оженитися. Максимальне паросполучення доставляє ЗАГСу більше всього роботи.</p>
<p>Алгоритм пошуку максимального паросполучення такий:</p>
<p>1. Ініціалізація</p>
<p>2. Побудова жадібного паросполучення.</p>
<p>3. У циклі по i з I' застосувати алгоритм знаходження всіх досяжних вершин з </p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i. Якщо серед них виявиться вершина з J', то збільшити ланцюг.</p>
<p>4. Якщо множини I' і J' непорожні і на кроці 3 удалося збільшити ланцюг, то&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; перейти до 3</p>
<p>5. Видати рішення</p>
<p>Тут I' і J' - множини ненасичених вершин із двох часток графа. "Збільшити ланцюг" - говорячи простою мовою - означає розгорнути ребра графа.</p>
<p id="author">Автор: Fedor</p>
<p>Взято с Vingrad.ru <a href="http://forum.vingrad.ru" target="_blank">http://forum.vingrad.ru</a></p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
