<!DOCTYPE html>
<html>
<head>
  <title>Прокси</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Прокси</h1>
<div id="date">01.01.2010</div>
<p>11. Прокси (proxy &#8211; заместитель, уполномоченный)</p>
Один из частых вопросов "Как я могу использовать Indy с прокси?". Когда задают этот вопрос, то ответить непросто. Не всегда возможно ответить, поскольку существует множество, самых различных прокси. Некоторые протоколы, также имеют свои собственные методы общения с прокси. Рассмотрим наиболее распространенные виды прокси.</p>
Прокси и файрволы выполняют похожие задачи, но имеют разные цели. Поскольку у них похожие задачи, они могут использоваться для выполнения функций друг друга и могут быть объединены в комбинацию прокси-файрвол.</p>
Прокси могут быть разделены на две категории:</p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Прозрачные</td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Непрозрачные</td></tr></table></div>11.1. Прозрачные прокси</p>
Прозрачные прокси &#8211; это прокси, которые не требуют вмешательства в протокол обмена. О наличии прозрачного прокси часто не догадываются разработчики или пользователи (на то они и прозрачные и их нельзя обойти).</p>
Хотя прозрачные прокси не оказывают влияния на клиента, они оказывают влияние на сервера. В большинстве случаев, серверы позади таких прокси скрыты от остального мира. Это позволяет иметь доступ к серверу с другой стороны прокси через его порты и эти порты туннелируются снаружи внутрь.</p>
11.1.1. Туннелирование IP / Трансляция сетевого адреса (NAT)</p>
IP маскирование ли трансляция сетевого адреса (NAT) в прокси позволяет всем исходящис соединеним быть прозрачными и не оказывать влияния на клиентов. Клиенты продолжают работать как обычно и не требуется их конфигурирование.</p>
Microsoft Internet Connection Sharing работает по данному методу.</p>
11.1.2. Маппирование портов / Туннели</p>
Маппированый порт или туннелированный прокси работает путем создания туннелей через блокированный маршрут. Маршрут может быть заблокирован в сетевой конфигурации, или может быть мостом между двумя сетями, или может быть умышленно защищен файрволом внутренней сети.</p>
Внутренняя сеть определятся как одна сторона сети в локальной сети и другой сети или внешней сети, к которой подключена внутренняя сеть. (Бр &#8211; фраза, не подлежащая к переводу, очень трудная к пониманию, принимайте как получилось. Если сказать своими словами &#8211; это часть сети отделенная от других сетей, как локальных, так и глобальных Почему бы так и не сказать?)</p>
Поскольку маршрут блокирован, весь доступ возможен только через туннелирование порта. Порты назначаются на локальном сервере, который доступен извне. Этот сервер затем пересылает данные из и во внутреннею сеть. Недостатком маппированых портов является то, что маппированый порт маппируется на фиксированный удаленный узел и порт. Для таких протоколов, как почтовые и сервера новостей они определены заранее и работают нормально. Но для протоколов подобных HTTP данный способ не работает, поскольку удаленное место неизвестно до общения (речь про доступ изнутри).</p>
Маппированные порты могут быть использованы также для маппирования портов снаружи во внутреннею сеть. Маппированые порты часто используются совместно с NAT прокси, для представления серверов во внешней сети.</p>
11.1.3. FTP User@Site прокси</p>
Для реализации FTP прокси имеются несколько методов. Основной тип FTP прокси называется User@site.</p>
При использования метода User@Site, все FTP сессии подсоединяются к локальному прокси серверу. Прокси притворяется что он FTP сервер. Прокси сервер перехватывает и интерпретирует FTP запросы. Когда прокси запрашивает имя пользователя, то имя пользователя и нужный FTP посылаются в виде username@ftpsite. Прокси соединяется нужным FTP и перехватывает команды передачи.</p>
Для каждой команды передачи, прокси динамически маппирует локальный порт для передачи данных и модифицирует информацию передачи, возвращаемую клиенту. FTP клиент контактирует с прокси вместо доступа к реальному FTP серверу. Из-за трансляции, FTP клиент не знает, что прокси является ненастоящим сервером.</p>
Например, пусть дан FTP сайт - ftp.atozedsoftware.com и имя пользователя joe, а его пароль smith, то нормальная сессия выглядит так:</p>
Host: ftp.atozedsoftware.com</p>
User: joe</p>
Password: smith</p>
Если User@Site прокси существует и его имя corpproxy, то FTP сессия выглядит так:</p>
Host: corpproxy</p>
User: joe@ftp.atozedsoftware.com</p>
Password: smith</p>
11.2. Непрозрачные прокси</p>
Непрозрачные прокси требуют вмешательства в используемые протоколы. Многие протоколы имеют встроенную поддержку для непрозрачных прокси.</p>
11.2.1. SOCKS прокси</p>
SOCKS &#8211; это прокси, которые не требуют изменений в протоколе высокого уровня, но работают на уровне TCP. Для протоколов, которые используют SOCKS прокси, программная часть должна быть реализована на уровне TCP.</p>
Если программное обеспечение не поддерживает явно SOCKS прокси, то оно не может быть использовано для работы с SOCKS файрволом. Большинство популярного обеспечения, такое как &#8211; браузеры и ICQ поддерживают SOCKS, но прочее программное обеспечение как правило нет. Поэтому, SOCKS часто должен развертываться с внутренними серверами, маппироваными портами, другими прокси или их комбинациями.</p>
Для программного обеспечения, которое поддерживает SOCKS, вместо соединения с сервером назначения, сначала происходит соединение с SOCKS прокси. При этом передается запись с данными, содержащими сервер назначения и дополнительно данные аутентификации. SOCKS сервер затем динамически строит туннель к серверу.</p>
Поскольку SOCKS протокол работает динамически на основе переданных данных, он очень настраиваемый и гибкий.</p>
11.2.2. HTTP (CERN) прокси</p>
HTTP прокси, иногда называемый CERN прокси, это специализированный прокси, который обслуживает только трафик браузеров. В дополнение HTTP, также может обслуживать и FTP трафик, если FTP делается поверх HTTP. HTTP прокси могут также кэшировать данные и часто используется только по этой причине.</p>
Многие корпоративные сети часто закрывают свои внутренние сети файрволом и разрешают выход наружу только через HTTP и почту. Почта предоставляется с помощью внутреннего почтового сервера, а HTTP предоставляется с помощью HTTP прокси. Данный тип HTTP является дружественным файрволу, поэтому многие новые протоколы используют HTTP как транспорт. SOAP и другие web службы являются замечательным примером.</p>
&nbsp;</p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
