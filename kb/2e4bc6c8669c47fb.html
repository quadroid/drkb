<!DOCTYPE html>
<html>
<head>
  <title>Клиент многозвенного распределенного приложения (статья)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Клиент многозвенного распределенного приложения (статья)</h1>
<div id="date">01.01.2010</div>

<p>Клиент многозвенного распределенного приложения </p>
<p>Клиентское ПО в распределенном многозвенном приложении имеет особенности архитектуры, продиктованные его ролью &#8212; ведь большая часть бизнес-логики и функций обработки данных сосредоточены в сервере приложений. Такая схема призвана обеспечить более высокую эффективность обработки запросов многочисленных удаленных клиентов, а также упрощает обслуживание клиентского ПО. Клиенты, выполняющие лишь необходимый минимум операций, называются "тонкими". </p>
<p>Клиенты многозвенных приложений обеспечивают выполнение следующих функций: </p>

<table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="13">&#183;</td><td> соединение с сервером приложений, прием и передача данных;&nbsp; </td></tr></table><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="13">&#183;</td><td> отображение средствами пользовательского интерфейса;&nbsp; </td></tr></table><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="13">&#183;</td><td> простейшие операции редактирования;&nbsp; </td></tr></table><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="13">&#183;</td><td> сохранение локальных копий данных.</td></tr></table>
<p>При разработке клиентских частей многозвенных приложений в Delphi используются компоненты DataSnap, а также компонент TClientoataSet, роль которого трудно переоценить. </p>
<p>Помимо новых компонентов в процессе разработки применяются стандартные компоненты отображения данных</p>
<p>Структура клиентского приложения </p>
<p>По своей структуре клиентское приложение подобно обычному приложению баз данных</p>
<p>Соединение клиента с сервером приложений осуществляется специализированными компонентами DataSnap. Эти компоненты взаимодействуют с удаленным модулем данных, входящим в состав сервера, при помощи методов интерфейса IAppServer. </p>
<p>Также в клиентском приложении могут использоваться дополнительные, определенные разработчиком, методы интерфейса удаленного модуля данных, унаследованного от интерфейса IAppServer. Подробнее об этих компонентах и способах их настройки на удаленный сервер приложений см. гл. 21. </p>
<p>Внимание </p>
<p>Соединение с сервером приложений обеспечивает динамическая библиотека MIDAS.DLL, которая должна быть зарегистрирована на компьютере клиента. </p>
<p>Как и обычное приложение БД, клиент многозвенного распределенного приложения должен содержать компоненты, инкапсулирующие набор данных, которые связаны с визуальными компонентами отображения данных посредством компонентов TDataSource. </p>
<p>Очевидно, что набор данных сервера должен быть скопирован клиентским приложением в некий локальный буфер. При этом должен использоваться эффективный механизм загрузки данных сравнительно небольшими порциями, что позволяет значительно разгрузить транспортный канал между клиентом и сервером приложений. </p>
<p>Кэширование и редактирование данных в клиентском приложении обеспечивает специализированный компонент TclientDataSet, отдаленным предком которого является класс TDataSet. Помимо унаследованных от предков методов, класс TclientDataSet инкапсулирует ряд дополнительных функций, облегчающих управление данными. </p>

<p id="note">Примечание&nbsp; </p>
<p>Подобно обычному приложению БД, в "тонком" клиенте для размещения невизуальных компонентов доступа к данным необходимо использовать модули данных. </p>
<p>Для получения набора данных сервера компонент TclientDataSet взаимодействует с компонентом TDataSetProvider, используя методы интерфейса IProviderSupport (см. гл. 21). </p>
<p>По существу все уникальные функции клиентского приложения сосредоточены в компоненте TclientDataSet, изучением которого мы и займемся далее в этой главе. В остальном клиентское приложение не отличается от обычного приложения БД и при его разработке могут применяться стандартные методы. </p>
<p>Клиентские наборы данных </p>
<p>В Палитре компонентов Delphi представлено несколько компонентов, инкапсулирующих клиентский набор данных. В то же время при разработке настоящих удаленных клиентских приложений применяется компонент TClientDataSet. Внесем ясность в этот вопрос. Итак, помимо компонента TClientDataSet, расположенного на странице Data Access, существуют еще два компонента: </p>
<p> TSimpleDataSet &#8212; разработан для технологии доступа к данным dbExpress и, по существу, является единственным полноценным средством для работы с набором данных в рамках этой технологии; </p>
<p> TiBdientDataSet &#8212; используется в технологии доступа к данным сервера InterBase &#8212; InterBase Express. </p>
<p>Все перечисленные компоненты произошли от общего предка &#8212; класса TCustomClientoataSet. Они обеспечивают локальное кэширование данных и взаимодействие с серверным набором данных при посредстве интерфейса IProviderSupport. </p>
<p>Основное различие между компонентом TClientDataSet и другими клиентскими компонентами заключается в том, что первый предназначен для использования с внешним компонентом-провайдером данных. А значит, он может взаимодействовать с удаленным провайдером данных. </p>
<p>Остальные перечисленные компоненты инкапсулируют внутренний провайдер данных, предоставляя тем самым для использования в рамках соответствующих технологий доступа к данным эффективный механизм локального кэширования данных. Использование внутреннего провайдера данных обеспечивает общий класс- предок TCustomCachedDataSet. </p>
<p>Для этого он имеет защищенное свойство </p>
<p>property Provider: TDataSetProvider; </p>
<p>Соединение с источником данных осуществляется не свойством RemoteServer (будет рассмотрено ниже применительно к компоненту TclientDataSet). задающим удаленный сервер, а стандартными средствами соответствующей технологии доступа к данным. </p>
<p>Таким образом, для работы с удаленными данными (т. е. внешними по отношению к клиенту) пригоден только компонент TclientDataSet, умеющий работать с внешним провайдером данных. </p>
<p>Компонент TClientDataSet </p>
<p>Компонент TclientDataSet используется в клиентской части многозвенного распределенного приложения. Он инкапсулирует набор данных, переданный при помощи компонента-провайдера из удаленного набора данных. Компонент обеспечивает выполнение следующих основных функций: </p>
<p> получение данных от удаленного сервера и передача ему сделанных изменений с использованием удаленного компонента-провайдера; </p>
<p> представление набора данных при помощи локального буфера и поддержка основных операций, унаследованных от класса TDataSet; </p>
<p> объединение записей набора данных при помощи агрегатных функций для получения суммарных данных; </p>
<p> локальное сохранение набора данных в файле и последующее восстановление набора данных из файла; </p>
<p> представление набора данных в формате XML. </p>
<p>Предком компонента TclientDataSet является класс TDataSet, поэтому TclientDataSet обладает таким же набором функций, что и обычный компонент, инкапсулирующий набор данных. Основное же отличие заключается в том, источник данных для него доступен только через удаленный компонент-провайдер. Это означает, что сохранение изменений и обновление набора данных осуществляется локально, без обращения к источнику данных. </p>
<p>Например, выполнение метода Post приведет лишь к сохранению текущей записи набора данных в локальном кэше. Все изменения отсылаются на сервер только при необходимости и легко управляются разработчиком. </p>
<p>Как и обычный компонент, компонент TclientDataSet может использоваться совместно с визуальными компонентами отображения данных. Для этого нужен компонент TDataSource. </p>
<p>Рассмотрим основные функции, реализуемые компонентом TclientDataSet. </p>
<p>Получение данных от компонента - провайдера </p>
<p>Компонент TClientDataSet получает доступ к удаленным данным через компонент соединения DataSnap (см. гл. 20). В зависимости от используемой технологии, это могут быть технологии TDCOMConnection, TSocketConnection, TWebConnection ИЛИ TCorbaConnection. </p>
<p>Компонент TClientDataSet связывается с компонентом соединения при помощи свойства </p>
<p>property RemoteServer: TCustomRemoteServer; </p>
<p>Если соединение настроено правильно, то ссылка на интерфейс IAppServer в свойстве </p>
<p>property AppServer: IAppServer; </p>
<p>совпадает со свойством </p>
<p>ClientDataSet.RemoteServer.AppServer; </p>
<p>После настройки соединения в свойстве property ProviderName: string; </p>
<p>можно выбрать один из компонентов-провайдеров, которые доступны на сервере приложений, выбранном в компоненте соединения. </p>
<p>Если провайдер был подключен правильно, свойство только для чтения </p>
<p>property HasAppServer: Boolean; </p>
<p>автоматически принимает значение True. </p>
<p>Теперь компонент готов к приему данных. При использовании метода </p>
<p>procedure Open; </p>
<p>или свойства </p>
<p>property Active: Boolean; </p>
<p>компонент получает от провайдера первый пакет данных. </p>
<p>Размер пакета определяется свойством </p>
<p>property PacketRecords: Integer; </p>
<p>которое задает число записей, передаваемое в одном пакете. Если свойство имеет значение &#8212;1 (это значение по умолчанию), передаются все записи набора данных. Если оно равно 0 &#8212; клиенту передаются только метаданные о наборе данных. </p>
<p>Если соединение клиента с сервером медленное, число записей в пакете можно уменьшить, но желательно так, чтобы при использовании компонентов TDBGrid полученные в одном пакете записи полностью заполняли рабочую область этого компонента. </p>
<p>Одновременно разработчик имеет возможность управлять доставкой следующих пакетов. Для этого используется метод </p>
<p>function GetNextPacket: Integer; </p>
<p>Например, это можно сделать следующим образом: </p>
<p>procedure TDataModulel.ClientDataSetAfterScroll(DataSet: TDataSet); </p>
<p>begin </p>
<p>  if ClientDataSet.EOF then ClientDataSet.GetNextPacket; </p>
<p>end; </p>
<p>Свойство </p>
<p>property FetchOnDemand: Boolean; </p>
<p>должно иметь значение False. При значении True оно разрешает компоненту получать новые пакеты данных по мере надобности, например, при необходимости прокрутки записей в компоненте TDBGrid. </p>
<p>До и после получения очередного пакета соответственно выполняются обработчики событий: </p>
<p>type </p>
<p>  TRemoteEvent = procedure(Sender: TObject; var OwnerData: OleVariant) of object; </p>
<p>  property BeforeGetRecords: TRemoteEvent;&nbsp; </p>
<p>  property AfterGetRecords: TRemoteEvent; </p>
<p>Содержимое очередного пакета представлено свойством </p>
<p>property Data: OleVariant; </p>
<p>Данные в нем хранятся в транспортном формате, готовые для пересылки. Причем его можно использовать не только для чтения, но и для записи, формируя пакет данных для отправки провайдеру: </p>
<p>var OwnerData: OleVariant; </p>
<p> &nbsp;&nbsp; MaxErrors, ErrorCount: Integer; </p>
<p> &nbsp;&nbsp; MaxErrors := 0; </p>
<p>ResultDataSet.Data := SourceDataSet.AppServer.AS_ApplyUpdates('',&nbsp;&nbsp;&nbsp; SourceDataSet.Delta, MaxErrors, ErrorCount, OwnerData); </p>
<p>Метод AS_AppiyUpdates передает данные, содержащиеся в буфере Delta, провайдеру на сервер и возвращает записи, сохранить которые не удалось. </p>
<p>Размер буфера Data в байтах возвращает свойство </p>
<p>property DataSize: Integer; </p>
<p>Кэширование и редактирование данных </p>
<p>После получения записей от провайдера набор данных сохраняется в локальном буфере памяти. И все вносимые изменения после применения метода Post также сохраняются локально и не пересылаются на сервер. Буфер изменений доступен при помощи свойства </p>
<p>property Delta: OleVariant; </p>
<p>Для передачи изменений на сервер используется метод </p>
<p>function ApplyUpdates(MaxErrors: Integer); Integer; virtual; </p>
<p>где параметр MaxErrors задает число ошибок, которые игнорируются при сохранении данных на сервере. Если параметр равен &#8212;1, сохранение на сервере прерывается при первой же ошибке. Метод возвращает число сохраненных записей. </p>
<p>После выполнения метода ApplyUpdates все записи, сохранить которые не удалось, возвращаются клиенту в локальный буфер Delta. </p>
<p>Если клиентское приложение будет редко изменять свои наборы данных, сохранение изменений на сервере можно связать с методом-обработчиком </p>
<p>AfterPost: </p>
<p>procedure TForml.ClientDataSetAfterPost(DataSet: TDataSet);&nbsp; </p>
<p>begin </p>
<p>  ClientDataSet.ApplyUpdates(-1);&nbsp; </p>
<p>end; </p>
<p>Свойство только для чтения </p>
<p>property ChangeCount: Integer; </p>
<p>возвращает общее число изменений, содержащееся в буфере Delta. Для очистки буфера изменений используется метод </p>
<p>procedure CancelUpdates; </p>
<p>После вызова метода свойство ChangeCount принимает значение 0. </p>
<p>До и после сохранения изменений на сервере соответственно вызываются методы-обработчики </p>
<p>property BeforeApplyUpdates: TRemoteEvent; </p>
<p>property AfterApplyUpdates: TRemoteEvent; </p>
<p>Несмотря на сделанные локально многократные изменения, запись может быть восстановлена в первоначальном виде. Метод </p>
<p>procedure RefreshRecord; </p>
<p>получает от провайдера первоначальный вариант текущей записи, сохраненный на сервере. </p>
<p>При этом (и при всех других случаях, когда компонент запрашивает обновление текущей записи) вызываются методы-обработчики </p>
<p>property BeforeRowRequest: TRemoteEvent; </p>
<p>property AfterRowRequest: TRemoteEvent; </p>
<p>Но что делать, если необходимо восстановить удаленную запись? В обычном наборе данных после сохранения это невозможно. В компоненте TClientDataSet существует метод </p>
<p>function UndoLastChange(FollowChange: Boolean): Boolean; </p>
<p>который возвращает набор данных к состоянию до последней выполненной операции редактирования, добавления или удаления записи. Если параметр FollowChange имеет значение True, курсор набора данных будет установлен на восстановленную запись. </p>
<p>О состоянии текущей записи позволяет судить метод </p>
<p>function UpdateStatus: TUpdateStatus; override; </p>
<p>который возвращает значение типа </p>
<p>TUpdateStatus = (usUnmodified, usModified, uslnserted, usDeleted); </p>
<p>означающее состояние текущей записи: </p>
<p>usUnmodified &#8212; запись осталась неизменной; </p>
<p>usModified &#8212; запись была изменена; </p>
<p>uslnserted &#8212; запись была добавлена; </p>
<p>usDeleted &#8212; запись была удалена. </p>
<p>Например, при закрытии набора данных можно выполнить проверку: </p>
<p>if ClientDataSet.UpdateStatus = usModified then ShowMessage('Record was changed'); </p>
<p>На основе типа можно управлять видимостью записей в наборе данных. Свойство </p>
<p>property StatusFilter: TUpdateStatusSet; </p>
<p>определяет, какой тип записей будет отображаться в наборе данных. Например: </p>
<p>ClientDataSet.StatusFilter := usDeleted; </p>
<p>отобразит в наборе данных только удаленные записи (при этом изменения не сохранены на сервере). </p>
<p>Управление запросом на сервере </p>
<p>Компонент TdientDataSet может не только эффективно управлять своим набором данных, но и влиять на выполнение серверного компонента, с которым он связан через провайдер. </p>
<p>Свойство </p>
<p>property CornmandText: string; </p>
<p>содержит текст запроса SQL, имя таблицы или хранимой процедуры в зависимости от типа серверного компонента. </p>
<p>Изменив значение этого свойства на клиенте, можно, например, модифицировать запрос SQL на сервере. Но для этого в свойстве Options соответствующего компонента-провайдера TDataSetProvider должно быть установлено значение </p>
<p>poAliowCommandText := True; </p>
<p>Новое значение свойства CommandText отправляется на сервер только после открытия клиентского набора данных или выполнения метода </p>
<p>procedure Execute; virtual; </p>
<p>Для запросов или хранимых процедур можно задавать параметры, которые сохраняются в свойстве </p>
<p>property Params: TParams; </p>
<p>До выполнения запроса присваиваются значения входным параметрам. После выполнения хранимой процедуры в выходных параметрах размещаются полученные от сервера значения. </p>
<p>Обратите внимание, что при выполнении запросов или хранимых процедур может измениться порядок следования параметров. Поэтому обращаться к параметрам желательно по их именам. Например, так: </p>
<p>Editl.Text := ClientDataSet.Params .ParamByName('OutputParam') .AsString; </p>
<p>Для того чтобы получить текущие значения параметров компонента набора данных на сервере, достаточно использовать метод </p>
<p>procedure FetchParams; </p>
<p>Перед и после получения параметров от провайдера, клиентский набор данных вызывает методы-обработчики событий: </p>
<p>property BeforeGetParams: TRemoteEvent;&nbsp; </p>
<p>property AfterGetParams: TRemoteEvent; </p>
<p>Использование индексов </p>
<p>Обычно использование индексов &#8212; прерогатива сервера БД. Из компонентов Delphi только табличные компоненты могут в какой-то степени управлять использованием индексов. Очевидно, что удаленное соединение не способствует эффективному управлению индексами набора данных на сервере. Поэтому компонент TclientDataSet предоставляет разработчику возможность создавать и использовать локальные индексы. </p>
<p>Правильно созданные и используемые локальные индексы могут существенно ускорить выполнение операций с набором данных. В то же время их невозможно сохранить вместе с набором данных локально, их необходимо перестраивать при каждом новом открытии набора данных и его обновлении с сервера. </p>
<p>Для создания локального индекса используется метод </p>
<p>procedure Addlndex(const Name, Fields: string;&nbsp; Options: TIndexOptions; </p>
<p>const DescFields: string = '';&nbsp; </p>
<p>const CaselnsFields: string = ''; </p>
<p>const GroupingLevel: Integer = 0); </p>
<p>Параметр Name определяет имя нового индекса. Параметр Fields должен содержать имена полей, которые разработчик хочет включить в индекс. Имена полей должны разделяться точкой с запятой. Параметр options позволяет задать тип индекса: </p>
<p>TIndexOption = (ixPrimary, ixUnique, ixDescending, ixCaselnsensitive, ixExpression, ixNonMaintained); </p>
<p>TIndexOptions = set of TIndexOption; </p>
<p>ixPrimary &#8212; первичный индекс; </p>
<p>ixUnique &#8212; значения индекса уникальны;&nbsp; </p>
<p>ixDescending &#8212; индекс сортирует записи в обратном порядке; </p>
<p>ixCaselnsensitive &#8212; индекс сортирует записи без учета регистра символов; </p>
<p>ixExpression &#8212; в индексе используется выражение (для индексов dBASE); </p>
<p>ixNonMaintained &#8212; индекс не обновляется при открытии таблицы. </p>
<p>При этом можно задать поля, порядок сортировки которых будет обратным. Для этого их необходимо перечислить через точку с запятой в параметре DescFields. Параметр CaselnsFields аналогичным образом позволяет задать поля, на сортировку которых не влияет регистр символов. </p>
<p>Параметры DescFields и CaselnsFields используются вместо параметра Options. </p>
<p>Параметр GroupingLevel задает уровень группировки полей индекса. Подробнее об этом см. ниже в разд. "Агрегаты" этой главы. </p>
<p>Основные свойства компонента, обеспечивающие управление индексами, совпадают с аналогичными свойствами табличных компонентов (подробнее об этом см. гл. 12). Поэтому лишь кратко перечислим их. </p>
<p>При работе с компонентом разработчик имеет возможность управлять индексами. </p>
<p>Созданный индекс подключается к набору данных свойством </p>
<p>property IndexName: String; </p>
<p>которое должно включать имя индекса или использовать свойство </p>
<p>property IndexFieldNames: String; </p>
<p>в котором можно задать произвольное сочетание имен индексированных полей таблицы. Имена полей разделяются точкой с запятой. Свойства IndexName и IndexFieldNames нельзя использовать одновременно. </p>
<p>Число полей, используемых в текущем индексе табличного компонента, возвращает свойство </p>
<p>property IndexFieldCount: Integer; </p>
<p> свойство </p>
<p>property IndexFields: [Index: Integer]: TField; </p>
<p>представляет собой индексированный список полей, входящих в текущий индекс. </p>
<p>Параметры созданных индексов доступны в свойстве </p>
<p>property IndexDefs: TIndexDefs; </p>
<p>Класс TIndexDefs подробно рассматривается в гл. 12. </p>
<p>После создания и подключения индекса записи набора данных "переупорядочиваются" в соответствии со значениями индексированных долей. </p>
<p>Удаление локального индекса обеспечивает метод </p>
<p>procedure Deletelndex(const Name: string); </p>
<p>После удаления текущего индекса или его отмены (обнуления свойства IndexName) записи набора данных "переупорядочиваются" в исходном порядке, соответствующем порядку записей набора данных на сервере. </p>
<p>Имена всех существующих в наборе данных индексов можно загрузить в список при помощи метода </p>
<p>procedure GetlndexNames(List: TStrings); </p>
<p>Например: </p>
<p>Memol.Lines.Clear; </p>
<p>ClientDataSet.GetlndexNames(Memol.Lines); </p>
<p>Сохранение набора данных в файлах </p>
<p>Клиентское приложение может использовать одну очень удобную функцию компонента TClientDataSet. Представим, что соединение между сервером и клиентом обладает малой пропускной способностью и к тому же часто обрывается. Что в этом случае делать пользователю, который внес много изменений и не может сохранить их на сервере? </p>
<p>В этом случае можно сохранить набор данных клиента в файле на локальном диске, а при удобной возможности &#8212; загрузить обратно и переслать на сервер. </p>
<p>Для сохранения данных (по существу это буфер Data) в файле используется метод </p>
<p>procedure SaveToFile(const FileName: string = ''; Format: TDataPacketFormat=dfBinary); </p>
<p>Причем, если параметр FileName пуст, имя файла берется из свойства </p>
<p>property FileName: string; </p>
<p>Также можно передать данные в поток: </p>
<p>procedure SaveToStream(Stream: TStream; Format: TDataPacketFormat=dfBinary); </p>
<p>Формат, в котором данные будут сохранены, определяется параметром </p>
<p>Format! </p>
<p>type TDataPacketFormat = (dfBinary, dfXML, dfXMLUTFS); </p>
<p>где dfBinary &#8212; бинарный вид, dfXML &#8212; формат XML, dfXMLUTFS &#8212; формат XML в кодировке UTF8. </p>
<p>Обратная загрузка данных, соответственно, выполняется методами: </p>
<p>procedure LoadFromFile(const FileName: string = ''); </p>
<p>и </p>
<p>procedure LoadFromStreamfStream: TStream); </p>
<p>После загрузки набор данных полностью готов к работе: </p>
<p>if LoadFileDialog.Execute then  </p>
<p>  begin </p>
<p> &nbsp;&nbsp; ClientDataSet.LoadFromFile(LoadFileDialog.FileName); </p>
<p> &nbsp;&nbsp; ClientDataSet.Open;&nbsp; </p>
<p>  end; </p>
<p>
<p>Работа с данными типа BLOB </p>
<p>Если набор данных сервера содержит большие поля (например, изображения), передача данных по медленному каналу займет очень много времени, </p>
<p>что, несомненно, снизит эффективность приложения. Простейшее решение проблемы &#8212; передача клиенту данных типа BLOB только в том случае, когда это ему действительно необходимо &#8212; т. е. исключительно по его запросу. </p>
<p>В компоненте TCHentDataSet процессом передачи полей типа BLOB можно управлять, используя свойство </p>
<p>property FetchOnDemand: Boolean; </p>
<p>По умолчанию оно равно значению True и клиентский набор данных "выкачивает" данные BLOB по мере необходимости автоматически. Это означает, что приложение будет останавливаться и заново получать данные при любом просмотре данных, прокрутке и т. д. Если свойство имеет значение False, для получения данных клиент должен явно вызвать метод </p>
<p>procedure FetchBlobs; </p>
<p>Но, кроме этого, в свойстве options компонента-провайдера TDataSetProvider обязательно должно быть установлено значение: </p>
<p>poFetchBlobsOnDemand := True; </p>
<p>Представление данных в формате XML </p>
<p>Набор данных клиента легко можно представить в формате XML. Для этого достаточно использовать свойство </p>
<p>property XMLData: OleVariant; </p>
<p>которое возвращает данные, содержащиеся в буфере Data (см. выше) в бинарном виде, в формате XML. </p>
<p>Например, клиентский набор данных можно сохранить в файле формата XML: </p>
<pre name="code" class="delphi">
if SaveDialog.Execute then 
  with TFileStream.Create(SaveDialog.FileName, fmCreate) do  
    try 
      Write(Pointer(ClientDataSet.XMLData)^, Length(ClientDataSet.XMLData)); 
    finally 
      Free ;  
    end; 
</pre>

<p>Агрегаты </p>
<p>Наличие локального буфера данных позволяет компоненту TClientDataSet реализовать ряд дополнительных функций, основанных на использовании агрегатных функций применительно к полям всего набора данных, загруженного в локальный буфер. </p>
<p>К агрегатным функциям относятся: </p>
<p>AVG &#8212; вычисляет среднее значение; </p>
<p>COUNT &#8212; возвращает число записей; </p>
<p>MIN &#8212; вычисляет минимальное значение; </p>
<p>МАХ &#8212; вычисляет максимальное значение; </p>
<p>SUM &#8212; вычисляет сумму. </p>
<p>Для их применения в компоненте TClientDataSet предусмотрены: </p>
<p> индексированный список объектов, инкапсулирующих агрегатные выражения &#8212; агрегаты; </p>
<p> агрегатные поля, обеспечивающие получение новых значений подобно вычисляемым полям, но с группированием записей на основе использования агрегатных функций. </p>
<p>
<p>Объекты-агрегаты </p>
<p>Для вычисления агрегатных выражений для всех записей набора данных используются объекты класса TAggregate. Индексированный список этих объектов содержится в свойстве </p>
<p>property Aggregates: TAggregates; </p>
<p>компонента TClientDataSet. Прямым предком класса TAggregates является класс TCollection, поэтому для него можно использовать все основные приемы работы с коллекциями. </p>
<p>Для создания нового агрегата необходимо щелкнуть на кнопке свойства в Инспекторе объектов и, в появившемся Редакторе агрегатов, выбрать пункт Add во всплывающем меню или щелкнуть на кнопке Add New. </p>
<p>Новый агрегат может быть добавлен и динамически: </p>
<p>var NewAgg: TAggregate; </p>
<p>NewAgg := ClientDataSet.Aggregates.Add; </p>
<p>Рассмотрим свойства класса TAggregate. </p>
<p>Имя агрегата содержится в свойстве </p>
<p>property AggregateName: string; </p>
<p>которое может быть использовано при отображении агрегата в визуальных компонентах. </p>
<p>Вычисляемое выражение с применением агрегатных функций должно находиться в свойстве </p>
<p>property Expression: String; </p>
<p>Например, для таблицы COUNTRY.DB из демонстрационной базы данных Delphi можно вычислять общую площадь государств Северной и Южной Америки (площадь государства содержится в поле Area): </p>
<p>ClientDataSet.Aggregates[Somelndex].Expression := 'SUM(Area)'; </p>
<p>Вычислением агрегата управляет свойство </p>
<p>property Active: Boolean; </p>
<p>а вычисленное значение возвращает функция </p>
<p>function Value: Variant; </p>
<p>Если пользователь редактирует набор данных, то для всех включенных агрегатов (Active = True) возвращаемое значение автоматически пересчитывается. </p>
<p>Например, после сохранения изменений в наборе данных можно визуализировать новое значение агрегата: </p>
<p>SomeLabel.Caption := ClientDataSet.Aggregates[0].AggregateName;&nbsp; </p>
<p>SomeEdit.Text := ClientDataSet.Aggregates[0].Value; </p>
<p>Для проверки активности агрегата, помимо проверки значения свойства Active, можно также использовать свойство </p>
<p>property InUse: Boolean; </p>
<p>Если оно возвращает значение True &#8212; вычисляемое выражение агрегата рассчитывается. </p>
<p>Видимость агрегата в визуальных компонентах управляется свойством </p>
<p>property Visible: Boolean; </p>
<p>Для того чтобы снизить вычислительную нагрузку на набор данных, можно отключить все агрегаты одновременно. Для этого свойству&nbsp; </p>
<p>property AggregatesActive: Boolean;&nbsp; </p>
<p>необходимо присвоить значение False. </p>
<p>Если же AggregatesActive = True, вычисляются только активные агрегаты, для которых свойство Active имеет значение True. </p>
<p>Если вам необходимо использовать все активные агрегаты, то вместо их последовательного перебора с проверкой свойства Active можно использовать свойство </p>
<p>property ActiveAggs[Index: Integer] : TList; </p>
<p>компонента TClientDataSet, которое представляет собой список активных агрегатов. </p>
<p>Агрегатные поля </p>
<p>Агрегатные поля не входят в структуру полей набора данных, т. к. агрегатные функции подразумевают объединение записей таблицы для получения результата. Следовательно, значение агрегатного поля нельзя связать с какой-то одной записью, оно относится ко всем или группе записей. </p>
<p>Агрегатные поля не отображаются вместе со всеми полями в компонентах TDBGrid, в Редакторе полей они расположены в отдельном списке. Для представления значения агрегатного поля можно воспользоваться одним из компонентов отображения данных, который визуализирует значение одного поля (например, TDBText или TDBEdit) или свойствами самого поля: </p>
<p>LabelI.Caption := MyDataSetAGGRFIELDl.AsString; </p>
<p>Подробно вопросы создания агрегатных полей рассмотрены в гл. 13. </p>
<p>Класс TAggregateField предназначен для инкапсуляции свойств и методов агрегатных полей. </p>
<p>Его свойство </p>
<p>property Expression: string; </p>
<p>задает вычисляемое выражение. </p>
<p>Вычисление значения проводится только для тех агрегатных полей, свойство </p>
<p>property Active: Boolean; </p>
<p>которых имеет значение True. </p>
<p>Вычисление включенных свойством Active агрегатных полей выполняется только в том случае, если булевское свойство AggregatesActive клиентского компонента набора данных имеет значение True. </p>
<p>По умолчанию экземпляр класса TAggregateField создается со свойством Visible = False</p>
<p>Группировка и использование индексов </p>
<p>Каждый агрегат (объект или поле) имеет свойство </p>
<p>property GroupingLevel: Integer; </p>
<p>которое задает уровень группировки полей набора данных при вычислении. При значении 0 расчет проводится для всех записей набора данных. При значении 1 записи группируются по первому полю набора данных и расчет осуществляется для каждой группы. При значении 2 записи разбиваются на группы по первому и второму полям и т. д. </p>
<p>Однако группировка по уровням выше нулевого возможна, только если в наборе данных используется индекс по группирующим полям. Например, если свойство GroupingLevel = 2 и набор данных начинается с полей CustNo и OrderNo, в свойстве IndexName компонента TClientDataSet и свойств property IndexName: String; агрегата (объекта или поля) должно быть имя индекса, включающего оба эти поля. </p>
<p>Вложенные наборы данных </p>
<p>При организации между таблицами отношения "один-ко-многим", когда через одинаковое значение поля внешнего ключа одна запись главной таблицы связывается с несколькими записями подчиненной таблицы. Этот широко распространенный в практике программирования приложений БД механизм реализован и в компоненте TClientDataSet. </p>
<p>Для этого используется класс поля TDataSetField. </p>
<p>На стороне клиента для создания отношения "один-ко-многим" необходимо использовать как минимум два компонента TClientDataSet, главный из которых инкапсулирует основной набор данных, а подчиненный &#8212; вложенный набор данных. </p>
<p>Итак, на стороне сервера есть два табличных компонента, связанных отношением "один-ко-многим" при помощи свойств MasterSource и MasterFields (см. гл. 14). Также это могут быть и два компонента запросов SQL, связанные параметрами подчиненного запроса с одноименными полями главного запроса и свойством DataSource. </p>
<p>Теперь на стороне клиента необходимо при помощи компонента-провайдера связать компонент TClientDataSet с главным серверным компонентом отношения "один-ко-многим" и создать для него статические объекты для всех полей. Для этого достаточно дважды щелкнуть на компоненте и в окне Редактора полей (см. рис. 22.3) из всплывающего меню выбрать пункт Add Field. В результате в окне Редактора полей появятся имена объектов для </p>
<p>всех полей серверного набора данных, а также еще одно дополнительное поле объектного типа TDataSetFieid. Его имя совпадает с именем подчиненного серверного компонента отношения "один-ко-многим". </p>
<p>Это поле связано с подчиненным компонентом на сервере. Чтобы убедиться в этом, достаточно просмотреть значение его свойства только для чтения </p>
<p>property NestedDataSet: TDataSet; </p>
<p>Индексированный список всех полей, передаваемых из серверного подчиненного компонента, содержится в свойстве только для чтения </p>
<p>property Fields: TFields; </p>
<p>В дальнейшем связь между компонентами на клиенте настраивается именно через это поле. В подчиненном компоненте TClientDataSet в Инспекторе объектов необходимо выбрать свойство </p>
<p>property DataSetField: TDataSetFieid; </p>
<p>В списке этого свойства вы увидите имя только что созданного поля объектного типа TDataSetField. Выберите его и отношение "один-ко-многим" для клиентских наборов данных готово. При этом в компоненте вложенного набора данных автоматически очищаются свойства RemoteServer и FroviderName, т. к. их значения утрачивают значение и компонент оказывается связан только с главным компонентом отношения "один-ко-многим". </p>
<p>Теперь при навигации по записям основного набора данных во вложенном наборе данных автоматически будут появляться связанные записи. Также вы можете использовать все возможности, предоставляемые компонентом TClientDataSet как для основного, так и для вложенного набора данных. </p>
<p>Дополнительные свойства полей клиентского набора данных </p>
<p>Как известно, все классы полей имеют одного общего предка &#8212; класс TField. Остановимся лишь на нескольких дополнительных свойствах полей, которые работают только в режиме кэширования в обычных компонентах, инкапсулирующих набор данных, и в компоненте TClientDataSet. Причем в компоненте TClientDataSet реализация этих свойств обеспечена локальным кэшем. </p>
<p>Итак, для разработчика могут быть полезны свойства объектов полей, содержащие не только текущее, но и предыдущее значение поля. </p>
<p>Свойство </p>
<p>property CurValue: Variant; </p>
<p>возвращает текущее значение поля. </p>
<p>Свойство </p>
<p>property OldValue: Variant; </p>
<p>содержит значение поле, которое было до начала редактирования. Свойство </p>
<p>property NewValue: Variant; </p>
<p>содержит новое значение, которое может быть присвоено при обработке ошибки сервера методом-обработчиком onReconclieError (см. ниже). </p>
<p>Обработка ошибок </p>
<p>Особенности использования компонента TClientDataSet распространяются также и на обработку ошибок. Ведь клиентский набор данных должен реагировать не только на ошибки, возникшие локально, но и на ошибки сохранения изменений на сервере. </p>
<p>В первом случае разработчик может применить стандартные способы. Это использование блоков try..except или методов обработчиков, унаследованных от класса TDataSet: </p>
<p> property OnDeleteError: TDataSetErrorEvent; &#8212; вызывается при ошибках удаления записей; </p>
<p> property OnEditError: TDataSetErrorEvent; &#8212; вызывается при ошибках редактирования записей; </p>
<p> property OnPostError: TDataSetErrorEvent; &#8212; вызывается при ошибках локального сохранения записей. </p>
<p> Все они используют процедурный тип </p>
<p>type </p>
<p>  TDataSetErrorEvent = procedure(DataSet: TDataSet;&nbsp; E: EDatabaseError; var Action: TDataAction) of object; </p>
<p>Здесь, помимо параметров DataSet и Е, определяющих соответственно набор данных и тип ошибки, параметром Action можно задать вариант реакции на ошибку: </p>
<p>type TDataAction = (daFail, daAbort, daRetry); </p>
<p>daFail &#8212; прервать операцию и показать сообщение об ошибке;&nbsp; </p>
<p>daAbort &#8212; прервать операцию без сообщения об ошибке; </p>
<p>daRetry &#8212; повторить операцию </p>
<p>Например, при возникновении ошибки редактирования набора данных код обработчика может выглядеть следующим образом: </p>
<pre name="code" class="delphi">
procedure TForml.ClientDataSetEditError(DataSet: TDataSet; E: EDatabaseError; var Action: TDataAction); 
begin 
  if Not (DataSet.State in [dsEdit, dslnsert]) then 
    begin 
      DataSet.Edit; Action := daRetry; 
    end 
  else 
    Action := daAbort; 
end;
</pre>

<p>Здесь, если набор данных не находится в состоянии редактирования, это упущение исправляется и операция повторяется. </p>
<p>Итак, с локальными ошибками все обстоит достаточно просто. А как клиентский набор данных "узнает" об ошибке на удаленном сервере? Очевидно, при помощи своего компонента-провайдера. Действительно, компонент TDataSetProvider не только возвращает клиенту несохраненные изменения в пакете Delta (см. выше), но и обеспечивает генерацию события, реакцией на которое является метод-обработчик </p>
<p>type </p>
<p>TReconcileErrorEvent = procedure(DataSet: TCustomClientDataSet; E:EReconcileError; UpdateKind: TUpdateKind; var Action: TReconcileAction) of object;&nbsp; </p>
<p>property OnReconcileError: TReconcileErrorEvent; </p>
<p>Обратите внимание, что все параметры похожи на соответствующие параметры локальных обработчиков, но имеют собственные типы. Рассмотрим их. </p>
<p>Параметр UpdateKind содержит указание на тип операции, вызвавшей ошибку на сервере: </p>
<p>type TUpdateKind = (ukModify, uklnsert, ukDelete); </p>
<p>ukModify &#8212; изменение данных; </p>
<p>uklnsert &#8212; добавление записей;&nbsp; </p>
<p>ukDelete &#8212; удаление записей. </p>
<p>Параметр Action позволяет разработчику предусмотреть реакцию клиентского набора данных на ошибку: </p>
<p>type TReconcileAction = (raSkip, raAbort, raMerge, raCorrect, raCancel, raRefresh); </p>
<p>raSkip &#8212; отменить операцию для записей, вызвавших ошибку, с их сохранением в буфере; </p>
<p>raAbort &#8212; отменить все изменения для операции, вызвавшей ошибку; </p>
<p>raMerge &#8212; совместить измененные записи с аналогичными записями сервера; </p>
<p>racorrect &#8212; сохранить изменения, сделанные в данном методе-обработчике; </p>
<p>racancel &#8212; отменить изменения, вызвавшие ошибку, заменив их исходными локальными значениями клиентского набора данных; </p>
<p>raRefresh &#8212; отменить изменения, вызвавшие ошибку, заменив их исходными значениями серверного набора данных. </p>
<p>Как видите, выбор возможных реакций на ошибку сервера несколько шире, чем на локальные ошибки. </p>
<p>Тип ошибки возвращается параметром Е, для которого предусмотрен специальный класс EReconcileError, имеющий несколько полезных свойств. </p>
<p>Свойство </p>
<p>property ErrorCode: DBResult; </p>
<p>возвращает код ошибки. Используемые коды ошибок можно найти в файле \Source\Vcl\DSIntf.pas. Код предыдущей ошибки возвращается свойством property PreviousError: DBResult; </p>
<p>Используя представленную здесь информацию, вы можете самостоятельно управлять обработкой ошибок сервера на клиенте. Но можно поступить и более просто &#8212; использовать стандартный диалог обработки удаленных ошибок (рис. 22.4). Этот диалог можно подключить к вашему проекту (он содержится в модуле \ObjRepos\RecError.pas) и вызвать при помощи процедуры: </p>
<p>function HandleReconcileError(DataSet: TDataSet; UpdateKind: TUpdateKind; ReconcileError: EReconcileError): TReconcileAction; </p>
<p>В параметры этой функции подставляются параметры метода-обработчика OnReconciieError, а возвращает данная функция действие, выбранное пользователем в диалоге (см. рис. 22.4). Таким образом, ее использование очень просто: </p>
<p>procedure TForml.ClientDataSetReconcileError(DataSet: TCustomClientDataSet; </p>
<p>E: EReconcileError; UpdateKind: TUpdateKind; var Action: TReconcileAction);&nbsp; </p>
<p>begin </p>
<p>  Action := HandleReconcileError(DataSet, UpdateKind, E) ; </p>
<p>end; </p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
