<!DOCTYPE html>
<html>
<head>
  <title>Процессы, потоки и функции ShellExecute и WinExec</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Процессы, потоки и функции ShellExecute и WinExec</h1>
<div id="date">01.01.2010</div>

<p>Устройство Windows. Процессы, потоки и функции ShellExecute и WinExec. Часть 1.</p>
<p> &nbsp;&nbsp;&nbsp; По просьбам общественности и была написана эта статья.</p>
<p>Действительно невозможно профессионально разрабатывать многопоточные программы,</p>
<p> не зная, что такое процессы, потоки, нити и синхронизация (надеюсь посвятить этому одну из следующих статей) и, </p>
<p>не представляя, как они работают. В статье за основу взята операционная система Windows 2000.</p>
<p> Так же в этой статье будут подробно рассмотрены различные методы запуска новых процессов (программ).</p>
<p> &nbsp;&nbsp;&nbsp; Главным обстоятельством является то, что почти все современные ОС многозадачны.</p>
<p> ОС Windows 2000 не является исключением, в ней может работать одновременно несколько программ. </p>
<p>Любая программы имеет, по крайней мере, одним программным потоком, </p>
<p>который в свою очередь может создавать еще несколько потоков и т.д.</p>
<p> Но, не смотря на то, что ОС, называется "многозадачной" в конкретный момент времени</p>
<p>выполняется только один поток. что вы не замечаете, как ОС переключается между потоками.</p>
<p> Не стоит забывать, что, распределяя процессорное время, операционная система Windows,</p>
<p> имеет дело именно с потоками, а не с процессами, которым эти потоки принадлежат.</p>
<p> &nbsp;&nbsp;&nbsp; Запуская программу в Windows, вы создаете процесс.</p>
<p> И в этом нет ничего удивительного, потому что в других операционных системах происходит почти то же самое.</p>
<p> Однако все же процесс в Windows, например, отличается от процесса в Unix.</p>
<p> А все дело в том, что в Windows процесс владеет открытыми файлами, оперативной памятью и другими ресурсами. </p>
<p>Для каждого процесса (программы) Windows выделяет виртуальное адресное пространство объемом 2 Гб.</p>
<p> Для адресации этого пространства используются обычные 32-битные указатели,</p>
<p> которые представляют собой числа от 0 до 2 Г. Но процесс в Windows не исполняется.</p>
<p> Исполняется программный поток. Поток - это последовательность машинных команд, которые Windows</p>
<p> воспринимает, как единое целое (набор регистров процессора).</p>
<p> Поток обладает указателем на команду, которая в данный момент выполняется,</p>
<p> и указателем на стек где хранятся локальные переменные потока.</p>
<p> Так в чем же разница спросите вы, между процессом и потоком, если запущенная программа имеет только один, </p>
<p>программный поток то разницы практически никакой. Однако поток может создавать другие потоки.</p>
<p> А те потоки могут создавать еще потоки. Два процесса ни могут иметь общие ресурсы,</p>
<p> если не используют специальные механизмы межпроцессорного взаимодействия.</p>
<p> В противоположность этому все потоки, которые принадлежат одному процессу,</p>
<p> имею доступ ко всем ресурсам этого процесса.</p>
<p> &nbsp;&nbsp;&nbsp; Зачем процессу несколько потоков? Потоки могут выполнять какие-то действия параллельно </p>
<p>основной программе (в фоновом режиме). Потоки удобно применять, если нежелательна</p>
<p> блокировка основной программы определенной функцией. Например, в то время, как поток</p>
<p> осуществляет сложные математические вычисления, в главной программе происходит подготовка </p>
<p>следующего задания и ввод параметров.</p>
<p> &nbsp;&nbsp;&nbsp; Если вам нужно запустить новую программу, вам нужно создать новый процесс.</p>
<p> Для этой цели служит системный вызов CreateProcess.</p>
<p> Однако использование этого вызова не очень удобно, потому что приходится задавать множество аргументов,</p>
<p> однако в некоторых случаях без него не обойтись. </p>
<p>Если же вам надо просто запустить программу или открыть файл, </p>
<p>то для этого подходят мене сложные вызовы.</p>
<p> &nbsp;&nbsp;&nbsp; Легче всего использовать WinExec. Однако Microsoft не рекомендует его использование, </p>
<p>а предлагает пользоваться CreateProcess.</p>
<p> Но для выполнения тех или иных задач он вполне подходит. </p>
<p>Почему же нежелателен вызов WinExec дело все в том, что фактически он содержит обращение</p>
<p> к еще одному устаревшему системному вызову LoadModule, который обращается к CreateProcess </p>
<p>со значениями аргументов по умолчанию. При обращении к WinExec необходимо задать полный путь </p>
<p>к программе или имя EXE файла, расположенного в пути поиска, а также способ</p>
<p> отображения программы (константы SW_HIDE, SW_SHOW и т.д. см. Таблица 2). </p>
<p> &nbsp;&nbsp;&nbsp; Если вызов функции произошел успешно, то WinExec вернет дескриптор новой</p>
<p> программы (который не может быть меньше 32, т.е. если WinExec возвращает число меньше 32, </p>
<p>то вызов привел к ошибке, коды ошибок см. Таблица 1). </p>
<p>Таблица 1.</p>
<p>0 Системе не хватает ресурсов. </p>
<p>ERROR_BAD_FORMAT Некорректный EXE файл (не Win32 EXE файл или EXE файл поврежден). </p>
<p>ERROR_FILE_NOT_FOUND Указанный файл не найден. </p>
<p>ERROR_PATH_NOT_FOUND Указанный путь не найден. </p>
<p> &nbsp;&nbsp;&nbsp; Еще один простой вызов это - ShellExecute. Этот вызов во многом напоминает WinExec,</p>
<p>однако он поддерживает обработку типов файлов, зарегистрированных в Windows. </p>
<p>Например, если вы с помощью ShellExecute вы попробуете запустить файл с расширением .BMP,</p>
<p> то буде запущена программа Paint или любая другая, которая использует для просмотра графических файлов.</p>
<p> В качестве аргументов ShellExecute принимает дескриптор окна (если есть необходимость в сообщениях об ошибках), </p>
<p>строку, такую как open (открыть), print (напечатать) и explore (исследовать), можно в качестве этой строки передать NULL, </p>
<p>тогда файл указанный вами будет открыт (open). Так же ShellExecute необходимо сообщить имя файла и любые параметры</p>
<p> командной строки (чаще всего NULL), и оставшиеся два аргумента это текущий каталог и константа функции</p>
<p> ShowWindow (как и в WinExec см. Таблица 2). </p>
<p>Таблица 2.</p>
<p>SW_HIDE Окно в скрытом режиме. </p>
<p>SW_MAXIMIZE Окно максимального размера </p>
<p>SW_MINIMIZE Окно находится в свернутом виде, активируется следующее верхнее окно в Z последовательности. </p>
<p>SW_RESTORE Активирует и показывает окно. Если окно свернуто или развернуто, Windows восстанавливает его</p>
<p> к первоначальному размеру и позиции. Приложение должно определить этот флаг при восстановлении свернутого окна. </p>
<p>SW_SHOW Активирует окно и выводит его в текущих размерах и позиции. </p>
<p>SW_SHOWMAXIMIZED Активирует и показывает окно в развернутом виде. </p>
<p>SW_SHOWMINIMIZED Активирует и показывает окно в свернутом виде. </p>
<p>SW_SHOWMINNOACTIVE Отображает окно в свернутом виде. Активное окно остается активным. </p>
<p>SW_SHOWNA Отображает окно в текущем состоянии. Активное окно остается активным. </p>
<p>SW_SHOWNORMAL Активирует и показывает окно. Если окно свернуто или развернуто,</p>
<p> Windows восстанавливает его к первоначальному размеру и позиции.</p>
<p> Приложение должно определить этот флаг при показе окна в первый раз. </p>
<p> &nbsp;&nbsp;&nbsp; Значение, которое возвращает ShellExecute такое же, как и у WinExec. Функцию ShellExecute можно использовать,</p>
<p> например, для открытия корневого каталога диска С:</p>
<p>ShellExecute(hWnd, 'open', 'c:\', nil, nil, SW_SHOWNORMAL);</p>
<p> &nbsp;&nbsp;&nbsp; Вы можете заменить строку "open" на "explore" и в качестве третьего параметра указать любой каталог,</p>
<p> в этом случае указанная вами папка откроется в Проводнике (Explorer).</p>
<p> &nbsp;&nbsp;&nbsp; Так же существует системный вызов ShellExecuteEx, который фактически является полным аналогом</p>
<p> ShellExecute, однако в качестве аргумента он принимает указатель на структуру, поля которой во многом</p>
<p> совпадают с аргументами ShellExecute. Кроме этого после завершения своей работы ShellExecuteEx помещает</p>
<p> в одно из полей этой структуры дескриптор запущенной программы.</p>
<p> &nbsp;&nbsp;&nbsp; Применение этих вызовов довольно просто. Пример программы использующей WinExec и ShellExecute </p>
<p>приведен в листинге 1. </p>
<p>Листинг 1.</p>
<pre name="code" class="delphi">
uses ShellAPI;
…
var
  h: hwnd;
begin
// Используем ShellExecute
  if ShellExecute(h, 'open', 'readme.txt', nil, nil, SW_SHOW) &lt; 32 then
    begin
      ShowMessage('Немогу выполнить ShellExecute !')
    end;
// Используем WinExec
  if WinExec('Notepad c:\config.sys', SW_SHOW) &lt; 32 then
    begin
      ShowMessage('Немогу выполнить WinExec !')
    end;
end;
</pre>

<p>Взято с сайта <a href="http://blackman.wp-club.net/" target="_blank">http://blackman.wp-club.net/</a></p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
