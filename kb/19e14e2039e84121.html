<!DOCTYPE html>
<html>
<head>
  <title>Технология DataSnap (статья)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Технология DataSnap (статья)</h1>
<div id="date">01.01.2010</div>

<p>Технология DataSnap. Механизмы удаленного доступа </p>
<p>Как быть, если необходимо создать приложение, которое может с одинаковым успехом работать как в локальной сети, так и на удаленном компьютере. </p>
<p>Очевидно, что в этом случае модель доступа к данным должна быть расширена, т. к. наличие большого числа удаленных клиентов делает традиционные схемы создания приложений БД малоэффективными. </p>
<p>В этой главе мы рассмотрим модель распределенного приложения БД, которая называется многозвенной (multitiered), и, в частности, ее наиболее простой вариант &#8212; трехзвенное распределенное приложение. Тремя частями такого приложения являются: </p>
<p> собственно сервер базы данных; </p>
<p> сервер приложений (серверная часть приложения); </p>
<p> клиентская часть приложения. </p>
<p>Все они объединены в единое целое единым механизмом взаимодействия (транспортный уровень) и обработки данных (уровень бизнес-логики). </p>
<p>Компоненты и объекты Delphi, обеспечивающие разработку многозвенных приложений, объединены общим названием DataSnap. </p>
<p id="note">Примечание </p>
<p>В предыдущих версиях Delphi (Delphi 4 и 5) эти компоненты объединялись под названием MIDAS (Multi-tier Distributed Applications Services&#8212; сервисы многозвенных распределенных приложений). </p>
<p>Палитра компонентов Delphi содержит специальную страницу DataSnap, на которой доступно большинство рассматриваемых в главах этой части компонентов. Однако при разработке многозвенных приложений нам понадобятся и многие другие компоненты, которым также уделено достаточное внимание. </p>
<p>Структура многозвенного приложения в Delphi </p>
<p>Многозвенная архитектура приложений баз данных вызвана к жизни необходимостью обрабатывать на стороне сервера запросы от большого числа удаленных клиентов. Казалось бы, с этой задачей вполне могут справиться и приложения клиент/сервер, основные элементы которых представлены в части III. </p>
<p>Однако в этом случае при большом числе клиентов вся вычислительная нагрузка ложится на сервер БД, который обладает довольно скудным набором средств для реализации сложной бизнес-логики (хранимые процедуры, триггеры, просмотры и т. д.). И разработчики вынуждены существенно усложнять программный код клиентского ПО, а это крайне нежелательно при наличии большого Числа удаленных клиентских компьютеров. Ведь с усложнением клиентского ПО возрастает вероятность ошибок и усложняется его обслуживание. </p>
<p>Многозвенная архитектура приложений БД призвана исправить перечисленные недостатки. </p>
<p>Итак, в рамках этой архитектуры "тонкие" клиенты представляют собой простейшие приложения, обеспечивающие лишь передачу данных, их локальное кэширование, представление средствами пользовательского интерфейса, редактирование и простейшую обработку. </p>
<p>Клиентские приложения обращаются не к серверу БД напрямую, а к специализированному ПО промежуточного слоя. Это может быть и одно звено (простейшая трехзвенная модель) и более сложная структура. </p>
<p>ПО промежуточного слоя называется сервером приложений, принимает запросы клиентов, обрабатывает их в соответствии с запрограммированными правилами бизнес-логики, при необходимости преобразует в форму, удобную для сервера БД и отправляет серверу. </p>
<p>Сервер БД выполняет полученные запросы и отправляет результаты серверу приложений, который адресует данные клиентам. </p>
<p>Таким образом, многозвенное приложение БД состоит из "тонких" клиентских приложений, обеспечивающих лишь передачу, представление, редактирование и простейшую обработку данных;&nbsp; одного или нескольких звеньев ПО промежуточного слоя (сервер приложений), которые могут функционировать как на одном компьютере, так и распределенно &#8212; в локальной сети;  сервера БД (Oralce, Sybase, MS SQL, InterBase и т. д.), поддерживающего функционирование базы данных и обрабатывающего запросы. </p>
<p>Более простая трехзвенная модель содержит следующие элементы:&nbsp; </p>
<p> "тонкие" клиенты;&nbsp; </p>
<p> сервер приложений; </p>
<p> сервер БД. </p>
<p>Далее мы будем рассматривать именно трехзвенную модель. В среде разработки Delphi имеется набор инструментов и компонентов для создания клиентского ПО и ПО промежуточного слоя. </p>
<p>Сервер приложений взаимодействует с сервером БД, используя одну из технологий доступа к данным, реализованным в Delphi . Это технологии ADO, BDE, InterBase Express и dbExpress. Разработчик может выбрать наиболее подходящую, исходя из поставленной задачи и параметров сервера БД. </p>
<p>Удаленные клиентские приложения создаются с использованием специального набора компонентов, объединенных общим названием DataSnap. Эти компоненты инкапсулируют стандартные транспорты (DCOM, HTTP, сокеты) и обеспечивают соединение удаленного клиентского приложения с сервером приложения. Также компоненты DataSnap обеспечивают доступ клиента к функциям сервера приложений за счет использования интерфейса AppServer </p>
<p>Важную роль при разработке клиентских приложений играет компонент, инкапсулирующий клиентский набор данных. Его реализации также зависят от технологий доступа к данным . </p>
<p>Наряду с перечисленными выше преимуществами, наличие дополнительного звена &#8212; сервера приложений &#8212; дает некоторые дополнительные бонусы, которые могут быть весьма существенным подспорьем с точки зрения повышения надежности и эффективности системы. </p>
<p>Так как зачастую клиентские компьютеры &#8212; это достаточно слабые машины, реализация сложной бизнес-логики на сторону сервера позволяет существенно повысить быстродействие системы в целом. И не только за счет более мощной техники, но и за счет оптимизации выполнения однородных запросов пользователей. </p>
<p>Например, при чрезмерной загрузке сервера, сервер приложений может самостоятельно обрабатывать запросы пользователей (ставить их в очередь или отменять) без дополнительной загрузки сервера БД. </p>
<p>Наличие сервера приложений повышает безопасность системы, т. к. вы можете организовать здесь авторизацию пользователей, да и любые другие функции безопасности без прямого доступа к данным. </p>
<p>Кроме того, вы легко сможете использовать защищенные каналы передачи данных, например HTTPS. </p>
<p>Трехзвенное приложение в Delphi </p>
<p>Теперь рассмотрим составные части трехзвенного распределенного приложения в Delphi. Как говорилось выше, в Delphi целесообразно разрабатывать клиентскую часть трехзвенного приложения и ПО промежуточного слоя &#8212; сервер приложений. </p>
<p>Части трехзвенных приложений разрабатываются с использованием компонентов DataSnap, а также некоторых других специализированных компонентов, в основном обеспечивающих функционирование клиента. Для доступа к данным применяется одна из четырех технологий, реализованных в Delphi. </p>
<p> Примечание&nbsp; </p>
<p>Разработку трехзвенных приложений целесообразно вести, используя в среде разработки группу проектов вместо одиночных проектов. Для этого используется утилита Project Manager (меню View | Project Manager). </p>
<p>Для передачи данных между сервером приложений и клиентами используется интерфейс AppServer, предоставляемый удаленным модулем данных сервера приложений. Этот интерфейс используют компоненты-провайдеры TDataSetProvider на стороне сервера и компоненты TClientDataSet на стороне клиента. </p>
<p>Сервер приложений </p>
<p>Сервер приложений инкапсулирует большую часть бизнес-логики распределенного приложения и обеспечивает доступ клиентов к базе данных. </p>
<p>Основной частью сервера приложений является удаленный модуль данных. </p>
<p>Во-первых, подобно обычному модулю данных он является платформой для размещения невизуальных компонентов доступа к данным и компонентов-провайдеров. Размещенные на нем компоненты соединений, транзакций и компоненты, инкапсулирующие наборы данных, обеспечивают трехзвенное приложение связью с сервером БД. Это могут быть наборы компонентов для технологий ADO, BDE, InterBase Express, dbExpress. </p>
<p>Во вторых, удаленный модуль данных реализует основные функции сервера приложений на основе предоставления клиентам интерфейса IAppServer или его потомка. Для этого удаленный модуль данных должен содержать необходимое число компонентов-провайдеров TDataSetProvider. Эти компоненты передают пакеты данных клиентскому приложению, а точнее компонентам TdientDataSet, а также обеспечивают доступ к методам интерфейса. </p>
<p>В состав Delphi входят удаленные модули данных. Для их создания используйте страницы Multitier, WebSnap и WebServices Репозитория Delphi . </p>
<p> Remote Data Module &#8212; удаленный модуль данных, инкапсулирующий сервер Автоматизации. Используется для организации соединений через DCOM, HTTP, сокеты (см. гл. 21). </p>
<p> Transactioiial Data Module &#8212; удаленный модуль данных, инкапсулирующий сервер MTS (Microsoft Transaction Server). </p>
<p> SOAP Server Data Module &#8212; удаленный модуль данных, инкапсулирующий сервер SOAP (Simple Object Access Protocol). </p>
<p> WebSnap Data Module &#8212; удаленный модуль данных, использующий Web-службы и Web-браузер в качестве сервера. </p>
<p>Помимо удаленного модуля данных неотъемлемой частью сервера приложений являются компоненты-провайдеры TDataSetProvider. С каждым компонентом, инкапсулирующим набор данных, предназначенным для передачи клиенту, в модуле данных должен быть связан компонент-провайдер. </p>
<p>Клиентское приложение </p>
<p>Клиентское приложение в трехзвенной модели должно обладать лишь минимально необходимым набором функций, делегируя большинство операций по обработке данных серверу приложений. </p>
<p>В первую очередь удаленное клиентское приложение должно обеспечить соединение с сервером приложений. Для этого используются компоненты соединений DataSnap: </p>
<p> TDCOMConnection &#8212; использует DCOM; </p>
<p> TSocketconnection &#8212; использует сокеты Windows; </p>
<p> TWebConnection &#8212; использует HTTP. </p>
<p>Компоненты соединения DataSnap предоставляют интерфейс IAppServer, используемый компонентами-провайдерами на стороне сервера и компонентами TClientDataSet на стороне клиента для передачи пакетов данных. </p>
<p>Для работы с наборами данных используются компоненты TClientDataSet, работающие в режиме кэширования данных. </p>
<p>Для представления данных и создания пользовательского интерфейса в клиентском ПО применяются стандартные компоненты со страницы Data Controls Палитры компонентов. </p>
<p>Механизм удаленного доступа к данным DataSnap </p>
<p>Для передачи пакетов данных между компонентом-провайдером и клиентским набором данных (между клиентом и сервером) должен существовать некий транспортный канал, обеспечивающий физическую передачу данных. Для этого могут использоваться разнообразные транспортные протоколы, поддерживаемые операционной системой. </p>
<p>Различные типы соединений, позволяющие настроить транспорт и начать передачу и прием данных, инкапсулированы в нескольких компонентах DataSnap. Для создания соединения с тем или иным транспортным протоколом разработчику достаточно перенести соответствующий компонент на форму и правильно настроить несколько свойств. Ниже рассматриваются варианты настройки транспортных протоколов для компонентов, использующих DCOM, сокеты TCP/IP, http. </p>
<p>Компонент TDCOMConnection </p>
<p>Компонент TDCOMConnection предоставляет транспорт на основе технологии Distributed COM и применяется в основном для организации транспорта в рамках локальной сети. </p>
<p>Для настройки соединения DCOM в первую очередь необходимо задать имя компьютера, на котором функционирует сервер приложений. Для компонента TDCOMConnection это должен быть зарегистрированный сервер Автоматизации. Имя компьютера задается свойством </p>
<p>property ComputerName: string; </p>
<p>Если оно задано правильно, в списке свойства </p>
<p>property ServerName: string; </p>
<p>в Инспекторе объектов можно выбрать один из доступных серверов. При выборе сервера также автоматически заполняется свойство </p>
<p>property ServerGUID: string; </p>
<p>Причем для успешного соединения клиента с сервером приложений оба свойства должны быть заданы в обязательном порядке. Только имя сервера или только его GUID не обеспечат правильный доступ к удаленному объекту СОМ. </p>
<p>Открытие и закрытие соединения осуществляется свойством </p>
<p>property Connected: Boolean; </p>
<p>или методами </p>
<p>procedure Open/procedure Close; </p>
<p>соответственно. </p>
<p>Для организации передачи данных между клиентом и сервером компонент TDCOMConnection предоставляет интерфейс IAppServer </p>
<p>property AppServer: Variant; </p>
<p>который также может быть получен методом </p>
<p>function GetServer: lAppServer; override; </p>
<p>Свойство </p>
<p>property ObjectBroker: TCustomObjectBroker; </p>
<p>позволяет использовать экземпляр компонента TsimpleObjectBroker для получения списка доступных серверов по время выполнения (см. ниже). </p>
<p>Методы-обработчики компонента TDCOMConnection представлены в табл. 20.1.&nbsp; </p>
<p>property AfterConnect: TNotifyEvent; Вызывается после установления соединения </p>
<p>property AfterDisconnect: TNotifyEvent; Вызывается после разрыва соединения </p>
<p>property BeforeConnect: TNotifyEvent; Вызывается перед установлением соединения </p>
<p>property BeforeDisconnect: TNotifyEvent; Вызывается перед разрывом соединения </p>
<p>type TGetUsernameEvent = procedure ( Sender : TOb j ect ; var Username: string) of object; </p>
<p>property OnGetUsername : TGetUsernameEvent; Вызывается непосредственно перед появлением диалога удаленной авторизации пользователя. Для этого свойство LoginPrompt должно иметь значение True. Параметр Username может содержать имя пользователя по умолчанию, которое появится в диалоге </p>
<p>type TLoginEvent = procedure ( Sender: TOb j ect; Username, Password: string) of object; </p>
<p>property OnLogin: TLoginEvent; Вызывается после открытия соединения, если свойство LoginPrompt имеет значение True. Параметры Username и Password содержат имя пользователя и пароль, введенные при авторизации </p>
<p>Компонент TSocketConnection </p>
<p>Компонент TSocketConnection обеспечивает соединение клиента с сервером приложений за счет использования сокетов TCP/IP. Для успешного открытия соединения на стороне сервера должен работать сокет-сервер (приложение ScktSrvr.exe, рис. 20.4). </p>
<p>Для успешного соединения свойство </p>
<p>property Host: String; должно содержать имя компьютера сервера. </p>
<p>Дополнительно, свойство </p>
<p>property Address: String; должно содержать IP-адрес сервера. </p>
<p>Для открытия соединения должны быть заданы оба этих свойства. </p>
<p>Свойство </p>
<p>property Port: Integer; </p>
<p>устанавливает номер используемого порта. По умолчанию это порт 211, но разработчик волен изменить порт, например, для использования различными категориями пользователей или для создания защищенного канала. </p>
<p>После правильного выбора компьютера в списке свойства </p>
<p>property ServerName: string; </p>
<p>в Инспекторе объектов появляется перечень доступных серверов Автоматизации. И после выбора сервера свойство </p>
<p>property ServerGUID: string; </p>
<p>которое содержит имя компьютера GUID зарегистрированного сервера, задается автоматически, хотя его можно задать и вручную. </p>
<p>Метод </p>
<p>function GetServerList: OleVariant; virtual; </p>
<p>возвращает список зарегистрированных серверов Автоматизации. Открытие и закрытие соединения осуществляется свойством </p>
<p>property Connected: Boolean;&nbsp; </p>
<p>или методами </p>
<p>procedure Open; </p>
<p>procedure Close; </p>
<p>соответственно. </p>
<p>Канал сокета TCP/IP может быть зашифрован. Для этого используется свойство </p>
<p>property InterceptName: string; </p>
<p>содержащее программный идентификатор объекта СОМ, обеспечивающего шифрование/дешифрование данных в канале, и свойство </p>
<p>property InterceptGUID: string; </p>
<p>содержащее имя компьютера GUID этого объекта. </p>
<p>Этот объект СОМ перехватывает данные в канале и осуществляет их обработку, предусмотренную собственным программным кодом. Это может быть шифрование, сжатие, обработка шумов и т. д. </p>
<p> Примечание </p>
<p>Создание объекта СОМ, обеспечивающего дополнительную обработку данных в канале, ложится на плечи разработчика. Объект-перехватчик должен поддерживать стандартный интерфейс IDataintercept. </p>
<p>Естественно, на стороне сервера должен быть зарегистрирован объект СОМ, выполняющий обратную операцию. Для этого также используется сокет-сервер. Строка Interceptor на странице должна содержать имя компьютера GUID объекта-перехватчика СОМ. </p>
<p>function GetlnterceptorList: OleVariant; virtual; </p>
<p>возвращает список зарегистрированных на сервере объектов-перехватчиков. </p>
<p>Для организации передачи данных между клиентом и сервером компонент TSocketConnection предоставляет интерфейс IAppServer&nbsp; </p>
<p>property AppServer: Variant; </p>
<p>который также может быть получен методом </p>
<p>function GetServer: lAppServer; override; </p>
<p>Свойство </p>
<p>property ObjectBroker: TCustomObjectBroker; </p>
<p>позволяет использовать экземпляр компонента TSimpieObjectBroker для получения списка доступных серверов во время выполнения (см. ниже). </p>
<p>Методы-обработчики событий компонента TSocketConnection полностью совпадают с методами-обработчиками компонента TDCOMConnection </p>
<p>  Компонент TWebConnection </p>
<p>Компонент TWebConnection предоставляет клиенту соединение на основе транспорта HTTP. Для работы компонента на клиентском компьютере должна быть зарегистрирована библиотека wininet.dll. Обычно это не требует специальных усилий, т. к. этот файл уже имеется в системной папке Windows, если на компьютере установлен Internet Explorer. </p>
<p>На компьютере сервера должен быть инсталлирован Internet Information Server версии не ниже 4.0 или Netscape Enterprise версии не ниже 3.6. Перечисленное ПО обеспечивает доступ компонента TWebConnection к динамической библиотеке HTTPsrvr.dll, которая также должна находиться на сервере. </p>
<p>Например, если файл HTTPsrvr.dll расположен в папке Scripts US 4.0 на Web-сервере www.someserver.com, то свойство </p>
<p>property URL: string; </p>
<p>должно содержать следующее значение: </p>
<p>  http://someserver.com/scripts/httpsrvr.dll </p>
<p>Если URL задан верно и сервер настроен правильно, то в списке свойства </p>
<p>property ServerName: string; </p>
<p>в Инспекторе объектов появляется перечень зарегистрированных серверов </p>
<p>Приложений. Имя одного из них должно содержаться в свойстве ServerName. </p>
<p>После выбора имени сервера в свойстве </p>
<p>property ServerGUID: string; </p>
<p>автоматически появляется GUID сервера. Свойства </p>
<p>property UserName: string; </p>
<p>И </p>
<p>property Password: string; </p>
<p>при необходимости могут содержать имя и пароль пользователя, которые будут использованы при авторизации. </p>
<p>Свойство </p>
<p>property Proxy: string; </p>
<p>содержит имя используемого прокси-сервера. </p>
<p>В заголовок сообщений HTTP можно поместить имя приложения. Для этого используется свойство </p>
<p>property Agent: string; </p>
<p>Соединение открывается и закрывается при помощи свойства </p>
<p>property Connected: Boolean; </p>
<p>Аналогичные операции выполняют методы </p>
<p>procedure Open; </p>
<p>procedure Close; </p>
<p>Доступ к интерфейсу IAppServer предоставляет свойство </p>
<p>property AppServer: Variant; </p>
<p>или метод </p>
<p>function GetServer: IAppServer; override; </p>
<p>Список доступных соединению серверов приложений возвращает метод </p>
<p>function GetServerList: OleVariant; virtual;&nbsp; </p>
<p>Свойство </p>
<p>property ObjectBroker: TCustomObjectBroker; </p>
<p>позволяет использовать экземпляр компонента TSimpieObjectBroker для получения списка доступных серверов во время выполнения (см. ниже). </p>
<p>Методы-обработчики событий компонента TWebConnection полностью совпадают с методами-обработчиками компонента TDCOMConnection. </p>
<p>Провайдеры данных </p>
<p>Компонент-провайдер TDataSetProvider представляет собой мост между набором данных сервера приложений и клиентским набором данных. Он обеспечивает формирование и передачу пакетов данных клиентскому приложению и прием от него сделанных изменений. </p>
<p>Все необходимые операции компонент выполняет автоматически. Разработчику необходимо лишь разместить компонент TDataSetProvider и связать его с набором данных сервера приложений. Для этого предназначено свойство </p>
<p>property DataSet: TDataSet; </p>
<p>Если соединение в клиентском приложении настроено правильно (см. выше), ТО В списке выбора свойства ProviderName компонента TClientDataSet в Инспекторе объектов появляются имена всех компонентов-провайдеров сервера приложений. Если связать клиентский набор данных с компонентом-провайдером, а затем открыть его, в клиентский набор данных будут переданы записи из набора данных сервера приложений, указанного в свойстве DataSet компонента-провайдера TDataSetProvider. </p>
<p>Компонент также содержит свойства, помогающие настроить процесс обмена данными. </p>
<p>property ResolveToDataSet: Boolean; управляет передачей данных от клиента серверу БД. Если оно имеет значение True, все изменения передаются в набор данных сервера приложений, заданный свойством DataSet. Иначе изменения направляются напрямую серверу БД. Если сервер приложений не должен отображать сделанные клиентом изменения, то свойству ResolveToDataSet можно присвоить значение False, что ускорит работу приложения. </p>
<p>property Constraints: Boolean; управляет передачей ограничений серверного набора данных клиентскому. Если свойство имеет значение True, ограничения передаются. </p>
<p>property Exported: Boolean; позволяет использовать в клиентском наборе данных интерфейс IAppServer. Для этого свойство должно иметь значение True. </p>
<p>Параметры компонента-провайдера задаются свойством </p>
<p>type </p>
<p>TProviderOption = (poFetchBlobsOnDemand, poFetchDetailsOnDemand, </p>
<p>poIncFieldProps, poCascadeDeletes, poCascadeUpdates, poReadOnly, poAllowMultiRecordUpdates, poDisablelnserts, poDisableEdits, poDisableDeletes, poNoReset, poAutoRefresh, poPropogateChanges, poAllowCoinmandText, poRetainServerOrder); </p>
<p>TProviderOptions = set of TProviderOption; </p>
<p>Набор параметров свойства задается присвоением элементам значения True. </p>
<p>property Options: TProviderOptions; </p>
<p>poFetchBlobsOnDemand &#8212; включает передачу в клиентский набор данных значений полей типа BLOB. По умолчанию эта возможность, отключена для ускорения работы; </p>
<p>poFetchDetailsOnDemand &#8212; включает передачу в клиентский набор данных подчиненных записей для отношения "один-ко-многим". По умолчанию эта возможность отключена для ускорения работы; </p>
<p>poIncFieldProps &#8212; включает передачу в клиентский набор данных нескольких свойств для объектов полей: Alignment, DisplayLabel, DisplayWidth, Visible, DisplayFormat, EditFormat, MaxValue, MinValue, Currency, EditMask, DisplayValues; </p>
<p>poCascadeDeletes &#8212; включает автоматическое удаление подчиненных записей в отношении "один-ко-многим" на стороне сервера, если главная запись была удалена в клиентском наборе данных; </p>
<p>poCascadeUpdates &#8212; включает автоматическое обновление подчиненных записей в отношении "один-ко-многим" на стороне сервера, если главная запись была изменена в клиентском наборе данных; </p>
<p>poReadOnly &#8212; включает режим "только для чтения" для набора данных сервера; </p>
<p>poAllowMultiRecordUpdates &#8212; включает режим внесения изменений сразу в несколько записей одновременно. Иначе все записи изменяются последовательно, одна за одной; </p>
<p>poDisablelnserts &#8212; запрещает клиенту вносить в набор данных сервера новые записи; </p>
<p>poDisableEdits &#8212; запрещает клиенту вносить в набор данных сервера изменения; </p>
<p>poDisableDeletes &#8212; запрещает клиенту удалять записи в наборе данных сервера; </p>
<p>poNoReset &#8212; запрещает обновление набора данных сервера перед передачей записей клиенту (перед вызовом метода AS_GetReccrds интерфейса IAppServer); </p>
<p>poAutoRefresh &#8212; включает автоматическое обновление записей клиентского набора данных. По умолчанию эта возможность отключена для ускорения работы; </p>
<p>poPropogateChanges &#8212; если В методах-обработчиках BeforeUpdateRecord или AfterUpdateRecord клиентского набора данных были сделаны дополнительные изменения, то после их записи в наборе данных сервера, изменения снова направляются клиенту для обновления записи. Во включенном состоянии эта возможность позволяет полностью контролировать сохранение изменений на сервере; </p>
<p>poAllowCommandText &#8212; позволяет изменять текст запроса SQL, имена хранимых процедур или таблиц в компоненте набора данных на сервере приложений; </p>
<p>poRetainServerOrder &#8212; включает запрет на изменение порядка сортировки записей клиентом. Если этот параметр отключить, возможны ошибки отображения набора данных, проявляющиеся в появлении двойных записей. </p>
<p>Методы-обработчики компонента-провайдера данных представлены в табл. 20.2. </p>
<p>Методы-обработчики событий компонента TDataSetProvider </p>
<p>property Af terApplyUpdates: TRemoteEvent; Вызывается после сохранения изменений, переданных от клиента, в наборе данных сервера </p>
<p>property AfterExecute: TRemoteEvent; Вызывается после выполнения запроса SQL или хранимой процедуры на сервере </p>
<p>property AfterGetParams: TRemoteEvent; Вызывается после того, как компонент-провайдер сформировал набор параметров набора данных сервера для их передачи клиенту </p>
<p>property AfterGetRecords: TRemoteEvent; Вызывается после того, как компонент-провайдер сформировал пакет данных для передачи набора данных сервера клиенту </p>
<p>property AfterRowRequest: TRemoteEvent; Вызывается после обновления текущей записи клиента компонентом-провайдером </p>
<p>property AfterUpdateRecord: TAf terUpdateRecordEvent; Вызывается сразу после обновления единичной записи на сервере </p>
<p>property Bef oreApplyUpdates: TRemoteEvent; Вызывается перед сохранением изменений, переданных от клиента, в наборе данных сервера </p>
<p>property BeforeExecute: TRemoteEvent; Вызывается перед выполнением запроса SQL или хранимой процедуры на сервере </p>
<p>property BeforeGetParams: TRemoteEvent; Вызывается перед тем, как компонент-провайдер сформировал набор параметров набора данных сервера для их передачи клиенту </p>
<p>property BeforeGetRecords: TRemoteEvent; Вызывается перед тем, как компонент-провайдер сформировал пакет данных для передачи набора данных сервера клиенту </p>
<p>property BeforeRowRequest: TRemoteEvent; Вызывается перед обновлением текущей записи клиента компонентом-провайдером </p>
<p>property BeforeUpdateRecord: TBeforeUpdateRecordEvent; Вызывается непосредственно перед обновлением единичной записи на сервере </p>
<p>property OnDataRequest: TDataRequestEvent; Вызывается при обработке запроса на получение данных клиентом </p>
<p>property OnGetData: TProviderDataEvent; Вызывается после получения данных от набора данных сервера, но перед их отправкой клиенту </p>
<p>property OnGetDataSetProperties: TGetDSProps; Вызывается при создании структуры параметров набора данных сервера для их передачи клиенту </p>
<p>property OnGetTableName: TGetTableNameEvent; Вызывается при получении компонентом-провайдером имени таблицы, подлежащей обновлению </p>
<p>property OnUpdateData: TProviderDataEvent; Вызывается при сохранении изменений в наборе данных сервера </p>
<p>property OnUpdateError: TResolverErrorEvent; Вызывается при возникновении ошибки сохранения изменений в наборе данных сервера </p>
<p>Вспомогательные компоненты &#8212; брокеры соединений </p>
<p>В состав компонентов DataSnap входит ряд дополнительных компонентов, облегчающих работу с соединениями удаленных клиентов с сервером приложений. Рассмотрим их. </p>
<p>Компонент TSimpleObjectBroker </p>
<p>Компонент TSimpleObjectBroker инкапсулирует список серверов, доступных для клиентов данного многозвенного распределенного приложения. Список серверов создается на этапе разработки. При необходимости (отключение сервера, его перегрузка и т. д.) компонент соединения клиентского ПО может использовать один из запасных серверов из списка компонента TsimpleobjectBroker непосредственно во время выполнения. </p>
<p>Для этого необходимо заполнить список серверов компонента TSimpleobjectBroker и указать ссылку на него в свойстве objectBroker компонента соединения (см. выше). И тогда при "переоткрытии" соединения имя сервера будет запрашиваться из списка компонента TsimpleobjectBroker. </p>
<p>Список серверов задается свойством </p>
<p>property Servers: TServerCollection; </p>
<p>На этапе разработки список серверов заполняется специализированным редактором, который вызывается при щелчке на кнопке свойства в Инспекторе объектов. </p>
<p>Свойство servers представляет собой коллекцию объектов класса TServeritem. Этот класс имеет несколько свойств, позволяющих описать основные параметры сервера. При использовании в соединении значения этих свойств подставляются в соответствующие свойства компонента соединения. </p>
<p>Свойства класса TServeritem </p>
<p>property ComputerName: string; Имя компьютера, на котором функционирует сервер </p>
<p>property DisplayName: String; Содержит имя сервера для представления в списке серверов </p>
<p>property Enabled: Boolean; Управляет доступностью записи о сервере для выбора при подключении. При значении True компоненты соединений могут использовать данную запись списка для подключения </p>
<p>property HasFailed: Boolean; После неудачной попытки использовать данную запись списка при подключении свойству присваивается значение True и в дальнейшем эта запись не используется </p>
<p>property Port: Integer; Содержит номер порта, используемого при подключении к серверу </p>
<p>Помимо списка серверов компонент имеет лишь несколько вспомогательных свойств и методов. </p>
<p>function GetComputerForGUID(GUID: TGUID): string; override; возвращает имя компьютера, на котором зарегистрирован сервер с GUID, заданным параметром. </p>
<p>function GetComputerForProgID(const ProgID): string; override; возвращает имя компьютера, на котором зарегистрирован сервер с именем, заданным параметром Progio. </p>
<p>property LoadBalanced: Boolean; управляет выбором сервера из списка. При значении True запись о сервере выбирается случайным образом, иначе для соединения предлагается первая доступная запись о сервере. </p>
<p>Компонент TLocalConnection </p>
<p>Компонент TLocalConnection используется локально для получения доступа к существующим компонентам-провайдерам. </p>
<p>property Providers[const ProviderName: string]: TCustomProvider; содержит ссылки на все компоненты-провайдеры, размещенные с компонентом TLocalConnection на одной форме. Индексация в списке осуществляется по имени компонента-провайдера. </p>
<p>Общее число компонентов-провайдеров в списке возвращает свойство </p>
<p>property ProviderCount: Integer; Кроме этого, при помощи компонента TLocalConnection можно получить доступ к интерфейсу IAppServer локально. Для этого используется свойство </p>
<p>property AppServer: IAppServer; </p>
<p>или метод </p>
<p>function GetServer: IAppServer; override; </p>
<p>Компонент TSharedConnection </p>
<p>Если интерфейс IAppServer удаленного модуля данных имеет метод, возвращающий ссылку на аналогичный интерфейс другого удаленного модуля данных, то первый модуль называется главным, а второй &#8212; дочерним. Компонент TSharedConnection используется для соединения клиентского приложения с дочерним удаленным модулем данных сервера приложений. </p>
<p>Свойство </p>
<p>property ParentConnection: TDispatchConnection; должно содержать ссылку на компонент соединения с главным удаленным модулем данных сервера приложений. Дочерний удаленный модуль данных определяется свойством </p>
<p>property ChildName: string; которое должно содержать его имя. Если интерфейс главного удаленного модуля данных настроен правильно, то в списке выбора свойства в Инспекторе объектов появляются имена всех дочерних удаленных модулей данных. </p>
<p>Интерфейс IAppServer дочернего удаленного модуля данных возвращает свойство </p>
<p>property AppServer: Variant; </p>
<p>или метод </p>
<p>function GetServer: lAppServer; override; </p>
<p>Методы-обработчики компонента TSharedConnection унаследованы от класса предка TCustomConnection</p>
<p>Компонент TConnectionBroker </p>
<p>Компонент TConnectionBroker обеспечивает централизованное управление соединением клиентских наборов данных с сервером приложений. Для этого свойство connectionBroker клиентских наборов данных должно ссылаться на экземпляр компонента TConnectionBroker. Тогда для изменения соединения (например, при переходе с транспорта HTTP на сокеты TCP/IP) нет необходимости изменять значение свойства RemoteServer всех компонентов TClientDataSet, а достаточно изменить свойство </p>
<p>property Connection: TCustomRemoteServer; </p>
<p>компонента TConnectionBroker. </p>
<p>Доступ к интерфейсу IAppServer обеспечивает свойство </p>
<p>property AppServer: Variant; </p>
<p>или метод </p>
<p>function GetServer: lAppServer; override; </p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
