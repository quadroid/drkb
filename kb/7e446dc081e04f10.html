<!DOCTYPE html>
<html>
<head>
  <title>Лексический анализ</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Лексический анализ</h1>
<div id="date">01.01.2010</div>

<p>7. Лексический анализ</p>
ВВЕДЕНИЕ </p>
В последней главе я оставил вас с компилятором который должен почти работать, за исключением того, что мы все еще ограничены одно-символьными токенами. Цель этого урока состоит в том, чтобы избавиться от этого ограничения раз и навсегда. Это означает, что мы должны иметь дело с концепцией лексического анализатора (сканера). </p>
Возможно я должен упомянуть, почему нам вообще нужен лексический анализатор... в конце концов до настоящего времени мы были способны хорошо справляться и без него даже когда мы предусмотрели много символьные токены. </p>
Единственная причина, на самом деле, имеет отношение к ключевым словам. Это факт компьютерной жизни, что синтаксис ключевого слова имеет ту же самую форму, что и синтаксис любого другого идентификатора. Мы не можем сказать пока не получим полное слово действительно ли это ключевое слово. К примеру переменная IFILE и ключевое слово IF выглядят просто одинаковыми до тех пор, пока вы не получите третий символ. В примерах до настоящего времени мы были всегда способны принять решение, основанное на первом символе токена, но это больше невозможно когда присутствуют ключевые слова. Нам необходимо знать, что данная строка является ключевым словом до того, как мы начнем ее обрабатывать. И именно поэтому нам нужен сканер. </p>
На последнем уроке я также пообещал, что мы могли бы предусмотреть нормальные токены без глобальных изменений того, что мы уже сделали. Я не солгал... мы можем, как вы увидите позднее. Но каждый раз, когда я намеревался встроить эти элементы в синтаксический анализатор, который мы уже построили, у меня возникали плохие чувства в отношении их. Все это слишком походило на временную меру. В конце концов я выяснил причину проблемы: я установил программу лексического анализа не объяснив вам вначале все о лексическом анализе, и какие есть альтернативы. До настоящего времени я старательно избегал давать вам много теории и, конечно, альтернативные варианты. Я обычно не воспринимаю хорошо учебники которые дают двадцать пять различных способов сделать что-то, но никаких сведений о том, какой способ лучше всего вам подходит. Я попытался избежать этой ловушки, просто показав вам один способ, который работает. </p>
Но это важная область. Хотя лексический анализатор едва ли является наиболее захватывающей частью компилятора он часто имеет наиболее глубокое влияние на общее восприятие языка так как эта часть наиболее близка пользователю. Я придумал специфическую структуру сканера, который будет использоваться с KISS. Она соответствует восприятию, которое я хочу от этого языка. Но она может совсем не работать для языка, который придумаете вы, поэтому в этом единственном случае я чувствую, что вам важно знать ваши возможности. </p>
Поэтому я собираюсь снова отклониться от своего обычного распорядка. На этом уроке мы заберемся гораздо глубже, чем обычно, в базовую теорию языков и грамматик. Я также буду говорить о других областях кроме компиляторов в которых лексических анализ играет важную роль. В заключение я покажу вам некоторые альтернативы для структуры лексического анализатора. Тогда и только тогда мы возвратимся к нашему синтаксическому анализатору из последней главы. Потерпите... я думаю вы найдете, что это стоит ожидания. Фактически, так как сканеры имеют множество применений вне компиляторов, вы сможете легко убедиться, что это будет наиболее полезный для вас урок. </p>
ЛЕКСИЧЕСКИЙ АНАЛИЗ </p>
Лексический анализ - это процесс сканирования потока входных символов и разделения его на строки, называемые лексемами. Большинство книг по компиляторам начинаются с этого и посвящают несколько глав обсуждению различных методов построения сканеров. Такой подход имеет свое место, но, как вы уже видели, существуют множество вещей, которые вы можете сделать даже никогда не обращавшись к этому вопросу, и, фактически, сканер, который мы здесь закончим, не очень будет напоминать то, что эти тексты описывают. Причина? Теория компиляторов и, следовательно, программы, следующие из нее, должны работать с большинством общих правил синтаксического анализа. Мы же не делаем этого. В реальном мире возможно определить синтаксис языка таким образом, что будет достаточно довольно простого сканера. И как всегда  KISS - наш девиз. </p>
Как правило, лексический анализатор создается как отдельная часть компилятора, так что синтаксический анализатор по существу видит только поток входных лексем. Теоретически нет необходимости отделять эту функцию от остальной части синтаксического анализатора. Имеется только один набор синтаксических уравнений, который определяет весь язык, поэтому теоретически мы могли бы написать весь анализатор в одном модуле. </p>
Зачем необходимо разделение? Ответ имеет и теоретическую и практическую основы. </p>
В 1956 Ноам Хомский определил "Иерархию Хомского" для грамматик. Вот они: </p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Тип 0. Неограниченные (например Английский язык) </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Тип 1. Контекстно-зависимые </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Тип 2. Контекстно-свободные </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Тип 3. Регулярные. </td></tr></table></div>Некоторые характеристики типичных языков программирования (особенно старых, таких как Фортран) относят их к Типу 1, но большая часть всех современных языков программирования может быть описана с использованием только двух последних типов и с ними мы и будем здесь работать. </p>
Хорошая сторона этих двух типов в том, что существуют очень специфические пути для их анализа. Было показано, что любая регулярная грамматика может быть анализирована с использованием частной формы абстрактной машины, называемой конечным автоматом. Мы уже реализовывали конечные автоматы в некоторых их наших распознающих программ. </p>
Аналогично грамматики Типа 2 (контекстно-свободные) всегда могут быть анализированы с использованием магазинного автомата (конечный автомат, дополненный стеком). Мы также реализовывали эти машины. Вместо реализации явного стека для выполнения работы мы положились на встроенный стек связанный с рекурсивным кодированием и это фактически является предпочтительным способом для нисходящего синтаксического анализа. </p>
Случается что в реальных, практических грамматиках части, которые квалифицируются как регулярные выражения, имеют склонность быть низкоуровневыми частями, как определение идентификатора: </p>
     &lt;ident&gt; ::= &lt;letter&gt; [ &lt;letter&gt; | &lt;digit&gt; ]* </p>
Так как требуется различные виды абстрактных машин для анализа этих двух типов грамматик, есть смысл отделить эти низкоуровневые функции в отдельный модуль, лексический анализатор, который строится на идее конечного автомата. Идея состоит в том, чтобы использовать самый простой метод синтаксического анализа, необходимый для работы. </p>
Имеется другая, более практическая причина для отделения сканера от синтаксического анализатора. Мы хотим думать о входном исходном файле как потоке символов, которые мы обрабатываем справа налево без возвратов. На практике это невозможно. Почти каждый язык имеет некоторые ключевые слова типа IF, WHILE и END. Как я упомянул ранее, в действительности мы не можем знать является ли данная строка ключевым словом до тех пор пока мы не достигнем ее конца, что определено пробелом или другим разделителем. Так что мы должны хранить строку достаточно долго для того, чтобы выяснить имеем мы ключевое слово или нет. Это ограниченная форма перебора с возвратом. </p>
Поэтому структура стандартного компилятора включает разбиение функций низкоуровневого и высокоуровневого синтаксического анализа. Лексический анализатор работает на символьном уровне собирая символы в строки и т.п., и передавая их синтаксическому анализатору как неделимые лексемы. Также считается нормальным позволить сканеру выполнять работу по идентификации ключевых слов. </p>
КОНЕЧНЫЕ АВТОМАТЫ И АЛЬТЕРНАТИВЫ </p>
Я упомянул, что регулярные выражения могут анализироваться с использованием конечного автомата. В большинстве книг по компиляторам а также в большинстве компиляторов, вы обнаружите, что это применяется буквально. Обычно они имеют настоящую реализацию конечного автомата с целыми числами, используемыми для определения текущего состояния и таблицей действий, выполняемых для каждой комбинации текущего состояния и входного символа. Если вы пишите "front end" для компилятора, используя популярные Unix инструменты LEX и YACC, это то, что вы получите. Выход LEX - конечный автомат, реализованный на C плюс таблица действий, соответствующая входной грамматике данной LEX. Вывод YACC аналогичен... искусственный таблично управляемый синтаксический анализатор плюс таблица, соответствующая синтаксису языка. </p>
Однако это не единственный вариант. В наших предыдущих главах вы много раз видели, что возможно реализовать синтаксические анализаторы специально не имея дела с таблицами, стеками и переменными состояния. Фактически в пятой главе я предупредил вас, что если вы считает себя нуждающимся в этих вещах, возможно вы делаете что-то неправильно и не используете возможности Паскаля. Существует в основном два способа определить состояние конечного автомата: явно, с номером или кодом состояния и неявно, просто на основании того факта, что я нахожусь в каком-то определенном месте кода (если сегодня вторник, то это должно быть Бельгия). Ранее мы полагались в основном на неявные методы, и я думаю вы согласитесь, что они работают здесь хорошо. </p>
На практике может быть даже не обязательно иметь четко определенный лексический анализатор. Это не первый наш опыт работы с много символьными токенами. В третьей главе мы расширили наш синтаксический анализатор для их поддержки и нам даже не был нужен лексический анализатор. Причиной было то, что в узком контексте мы всегда могли сказать просто рассматривая единственный предсказывающий символ, имеем ли мы дело с цифрой, переменной или оператором. В действительности мы построили распределенный лексический анализатор, используя процедуры GetName и GetNum. </p>
Имея ключевые слов мы не можем больше знать с чем мы имеем дело до тех пор, пока весь токен не будет прочитан. Это ведет нас к более локализованному сканеру, хотя, как вы увидите, идея распределенного сканера все же имеет свои достоинства. </p>
ЭКСПЕРИМЕНТЫ ПО СКАНИРОВАНИЮ </p>
Прежде чем возвратиться к нашему компилятору, было бы полезно немного поэкспериментировать с общими понятиями. </p>
Давайте начнем с двух определений, наиболее часто встречающихся в настоящих языках программирования: </p>
     &lt;ident&gt; ::= &lt;letter&gt; [ &lt;letter&gt; | &lt;digit&gt; ]* </p>
     &lt;number ::= [&lt;digit&gt;]+ </p>
 (Не забудьте, что "*" указывает на ноль или более повторений условия в квадратных скобках, а "+" на одно и более.) </p>
Мы уже работали с подобными элементами в третьей главе. Давайте начнем (как обычно) с пустого Cradle. Не удивительно, что нам понадобится новая процедура распознавания: </p>
&nbsp;</p>
{ Recognize an Alphanumeric Character } </p>
function IsAlNum(c: char): boolean; <br>
begin <br>
   IsAlNum := IsAlpha(c) or IsDigit(c); <br>
<p>end; </p>
&nbsp;</p>
Используя ее, давайте напишем следующие две подпрограммы, которые очень похожи на те, которые мы использовали раньше: </p>
<pre name="code" class="delphi">
{ Get an Identifier } 
function GetName: string; 
var x: string[8]; 
begin 
   x := ''; 
   if not IsAlpha(Look) then Expected('Name'); 
   while IsAlNum(Look) do begin 
     x := x + UpCase(Look); 
     GetChar; 
   end; 
   GetName := x; 
end; 
 
{ Get a Number } 
function GetNum: string; 
var x: string[16]; 
begin 
   x := ''; 
   if not IsDigit(Look) then Expected('Integer'); 
   while IsDigit(Look) do begin 
     x := x + Look; 
     GetChar; 
   end; 
   GetNum := x; 
end;  
</pre>
&nbsp;</p>
&nbsp;</p>
(Заметьте, что эта версия GetNum возвращает строку, а не целое число, как прежде). </p>
Вы можете легко проверить что эти подпрограммы работают, вызвав их из основной программы: </p>
     WriteLn(GetName); </p>
Эта программа выведет любое допустимое набранное имя (максимум восемь знаков, потому что мы так сказали GetName). Она отвергнет что-либо другое. </p>
Аналогично проверьте другую подпрограмму. </p>
ПРОБЕЛ </p>
Раньше мы также работали с вложенными пробелами, используя две подпрограммы  IsWhite  и  SkipWhite. Удостоверьтесь, что эти подпрограммы есть в вашей текущей версии Cradle и добавьте строку: </p>
     SkipWhite; </p>
в конец GetName и GetNum. </p>
Теперь давайте определим новую процедуру: </p>
<pre name="code" class="delphi">
{ Lexical Scanner } 
Function Scan: string; 
begin 
   if IsAlpha(Look) then 
      Scan := GetName 
   else if IsDigit(Look) then 
      Scan := GetNum 
   else begin 
      Scan := Look; 
      GetChar; 
   end; 
   SkipWhite; 
end;
</pre>
&nbsp;</p>
Мы можем вызвать ее из новой основной программы: </p>
<pre name="code" class="delphi">
{ Main Program } 
begin 
   Init; 
   repeat 
      Token := Scan; 
      writeln(Token); 
   until Token = CR; 
end.
</pre>
&nbsp;</p>
 (Вы должны добавить описание строки Token в начало программы. Сделайте ее любой удобной длины, скажем 16 символов). </p>
Теперь запустите программу. Заметьте, что входная строка действительно разделяется на отдельные токены. </p>
КОНЕЧНЫЕ АВТОМАТЫ </p>
Подпрограмма анализа типа GetName действительно реализует конечный автомат. Состояние неявно в текущей позиции в коде. Очень полезным приемом для визуализации того, что происходит, является синтаксическая диаграмма или "railroad-track" диаграмма. Немного трудно нарисовать их в этой среде, поэтому я буду использовать их очень экономно, но фигура ниже должна дать вам идею: </p>
<img src="pic/embim1700.png" width="479" height="149" vspace="1" hspace="1" border="0" alt=""></p>
Как вы можете видеть, эта  диаграмма показывает логические потоки по мере чтения символов. Начинается все, конечно, с состояния "start" и заканчивается когда найден символ, отличный от алфавитно-цифрового. Если первый символ не буква, происходит ошибка. Иначе автомат продолжит выполнение цикла до тех пор, пока не будет найден конечный разделитель. </p>
Заметьте, что в любой точке потока наша позиция полностью зависит от предыдущей истории входных символов. В этой точке предпринимаемые действия зависят только от текущего состояния плюс текущий входной символ. Это и есть то, что образует конечный автомат. </p>
Из-за сложностей представления "railroad-track" диаграмм в этой среде я буду продолжать придерживаться с этого времени синтаксических уравнений. Но я настоятельно рекомендую вам диаграммы для всего, что включает синтаксический анализ. После небольшой практики вы можете начать видеть, как написать синтаксический анализатор непосредственно из диаграммы. Параллельные пути кодируются в контролирующие действия (с помощью операторов IF или CASE),  последовательные пути - в последовательные вызовы.  Это почти как работа по схеме. </p>
Мы даже не обсудили SkipWhite, которая была представлена раньше, но это также простой конечный автомат, как и GetNum. Так же как и их родительская процедура Scan. Маленькие автоматы образуют большие автоматы. </p>
Интересная вещь, на которую я хотел бы чтобы вы обратили внимание это то, как безболезненно такой неявный подход создает эти конечные автоматы. Я лично предпочитаю его таблично управляемому методу. Он также получает маленькие, компактные и быстрые сканеры. </p>
НОВЫЕ СТРОКИ </p>
Продвигаясь прямо вперед, давайте модифицируем наш сканер для поддержки более чем одной строки. Как я упомянул последний раз, наиболее простой способ сделать это - просто обработать символы новой строки, возврат каретки и перевод строки, как незаполненное пространство. Фактически это способ, используемый подпрограммой iswhite из стандартной библиотеки C. Прежде мы не этого делали. Я хотел бы сделать это теперь, чтобы вы могли почувствовать результат. </p>
Чтобы сделать это просто измените единственную выполнимую строку в IsWhite: </p>
     IsWhite := c in [' ', TAB, CR, LF]; </p>
Мы должны дать основной программы новое условие останова, так как она никогда не увидит CR. Давайте просто используем: </p>
     until Token = '.'; </p>
ОК, откомпилируйте эту программу и запустите ее. Попробуйте пару строк, завершаемых точкой. Я использовал: </p>
     now is the time</p>
     for all good men. </p>
Эй, что случилось? Когда я набрал это, я не получил последний токен, точку. Программа не остановилась. Более того, когда я нажал клавишу 'enter' несколько раз, я все равно не получил точку. </p>
Если вы все еще не можете выбраться из вашей программы, вы обнаружите, что набор точки в новой строке прервет ее. </p>
Что здесь происходит? Ответ в том, что мы зависаем в SkipWhite. Короткий осмотр этой подпрограммы покажет, что пока мы печатаем пустые строки, мы просто продолжаем выполнение цикла. После того, как SkipWhite встречает LF, он пытается выполнить GetChar. Но так как входной буфер теперь пуст, оператор чтения в GetChar настаивает на наличии другой строки. Процедура Scan получает завершающую точку, все правильно, но она вызывает SkipWhite и SkipWhite не возвращается до тех пор, пока не получит непустую строку. </p>
Такое поведение не настолько плохое, как кажется. В настоящем компиляторе мы читали бы символы из входного файла вместо консоли и пока мы имеем какую-то процедуру для работы с концом файла, все получится ОК. Но для чтения данных с консоли такое поведение слишком причудливое. Суть в том, что соглашение C/Unix  просто не совместимо со структурой нашего анализатора, который запрашивает предсказывающий символ. Код, который мастера из Bell реализовали, не использует это соглашение, поэтому они нуждаются в  'ungetc'. </p>
ОК, давайте исправим проблему. Чтобы сделать это, мы должны возвратиться к старому определению IsWhite (удалите символы CR и LF) и используйте процедуру Fin, которую я представил в последний раз. Если ее нет в вашей текущей версии Cradle, поместите ее там. </p>
Также измените основную программу следующим образом: </p>
<pre name="code" class="delphi">
{ Main Program } 
begin 
   Init; 
   repeat 
      Token := Scan; 
      writeln(Token); 
      if Token = CR then Fin; 
   until Token = '.'; 
end. 
</pre>
&nbsp;</p>
Обратите внимание на "охраняющую" проверку, предшествующую вызову Fin. Это то, что заставляет все это работать, и проверяет, то мы не пытаемся прочитать строку дальше. </p>
Сейчас испытайте этот код. Я думаю он понравится вам больше. </p>
Если вы обратитесь к коду, который мы написали в последней главе, вы обнаружите, что я расставил вызовы Fin по всему коду, где прерывание строки было бы уместным. Это одна из тех областей, которые действительно влияют на восприятие, о котором я упомянул. В этой точке я должен убедить вас поэкспериментировать с различными способами организациями и посмотреть, как вам это понравится. Если вы хотите, чтобы ваш язык был по настоящему свободного стиля, тогда новые строки должны быть прозрачны. В этом случае наилучшим подходом было бы поместить следующие строки в начале Scan: </p>
     while Look = CR do </p>
        Fin; </p>
Если, с другой стороны, вам нужен строчно-ориентированный язык подобный Ассемблеру, BASIC или FORTRAN (или даже Ada... заметьте, что он имеет комментарии, завершаемые новой строкой), тогда вам необходимо, чтобы Scan возвращал CR как токены. Он также должен съедать завершающие LF. Лучший способ сделать - использовать эту строку в самом начале Scan: </p>
     if Look = LF then Fin; </p>
Для других соглашений вы будете должны использовать другие способы организации. В моем примере на последнем уроке я разрешил новые строки только в определенных местах, поэтому я занял какое-то промежуточное положение. В остальных частях этих занятий я буду выбирать такие способы обработки новых строк какие мне понравятся, но я хочу, чтобы вы знали, как выбрать для себя другой путь. </p>
ОПЕРАТОРЫ </p>
Мы могли бы сейчас остановиться и иметь в своем распоряжении довольно полезный сканер. В тех фрагментах KISS, которые мы построили, единственными токенами, состоящими из нескольких символов, являются идентификаторы и числа. Все операторы были одно-символьными. Единственное исключение, которое я могу придумать - это операторы отношений "&lt;=", "&gt;="  и  "&lt;&gt;", но они могут быть обработаны как особые случаи. </p>
Однако другие языки имеют много символьные операторы такие как ":=" в Паскале или "++" и "&gt;&gt;" в C. Хотя пока нам и не нужны много символьные операторы, было бы хорошо знать как получить их в случае необходимости. </p>
Само собой разумеется, что мы можем обрабатывать операторы точно таким же способом, что и другие токены. Давайте начнем с подпрограммы распознавания: </p>
<pre name="code" class="delphi">
{ Recognize Any Operator } 
function IsOp(c: char): boolean; 
begin 
   IsOp := c in ['+', '-', '*', '/', '&lt;', '&gt;', ':', '=']; 
end; 
</pre>
 Важно заметить, что мы не должны включать в этот список каждый возможный оператор. К примеру круглые скобки не включены, так же как и завершающая точка. Текущая версия Scan и так хорошо поддерживает одно-символьные операторы. Список выше включает только те символы, которые могут появиться в много символьных операторах. (Для конкретных языков список конечно всегда может быть отредактирован). </p>
Теперь давайте изменим Scan следующим образом: </p>
<pre name="code" class="delphi">
{ Lexical Scanner } 
Function Scan: string; 
begin 
   while Look = CR do 
      Fin; 
   if IsAlpha(Look) then 
      Scan := GetName 
   else if IsDigit(Look) then 
      Scan := GetNum 
   else if IsOp(Look) then 
      Scan := GetOp 
   else begin 
      Scan := Look; 
      GetChar; 
   end; 
   SkipWhite; 
end;
</pre>
&nbsp;<br>
<p>&nbsp;</p>
Теперь испытайте программу. Вы убедитесь, что любые фрагменты кода, которые вы  захотите бросить в нее будут аккуратно разложены на индивидуальные токены. </p>
СПИСКИ, ЗАПЯТЫЕ И КОМАНДНЫЕ СТРОКИ. </p>
Прежде чем возвратиться к основной цели нашего обучения, я хотел бы немного выступить. </p>
Сколько раз вы работали с программой или операционной системой, которая имела жесткие правила того, как вы должны разделять элементы в списке? (Попробую, последний раз вы использовали MS DOS!). Некоторые программы требуют пробелов как разделителей, некоторые требуют запятые. Хуже всего, что некоторые требуют и того и другого в разных местах. Большинство довольно неумолимы к нарушениям их правил. </p>
Я думаю, это непростительно. Слишком просто написать синтаксически анализатор, который поддерживает и пробелы и запятые гибким способом. Рассмотрите следующую процедуру: </p>
<pre name="code" class="delphi">
{ Skip Over a Comma } 
procedure SkipComma; 
begin 
   SkipWhite; 
   if Look = ',' then begin 
      GetChar; 
      SkipWhite; 
   end; 
end; 
</pre>
&nbsp;</p>
&nbsp;</p>
&nbsp;</p>
Эта процедура из восьми строк пропустит разделитель, состоящий из любого числа (включая ноль) пробелов, с нулем или одной запятой, вложенной в строку. </p>
Временно измените вызов SkipWhite в Scan на вызов SkipComma и попробуйте ввести какие-нибудь списки. Хорошо работает, да? Разве вы не хотите, чтобы больше создателей программ знало о SkipComma? </p>
К слову сказать, я обнаружил, что добавление эквивалента SkipComma в мою программу на ассемблере для Z80 заняло всего шесть дополнительных байт кода. Даже на 64K машинах это не слишком большая цена за дружелюбие к пользователю. </p>
Я думаю вы  можете видеть к чему я клоню. Даже если вы в своей жизни не написали ни одной строчки кода для компилятора, в каждой программе существуют места, где вы можете использовать понятие синтаксического анализа. Любая программа, которая обрабатывает командные строки, нуждается в нем. Фактически, если вы подумаете немного об этом, вы придете к заключению, что всякий раз, когда вы пишете программу, обрабатывающую ввод пользователя, вы определяете язык. Люди общаются с помощью языков и неявный синтаксис в вашей программе определяет этот язык. Настоящий вопрос: вы собираетесь определять его преднамеренно и явно, или просто позволите существовать независимо от того, как программа завершает синтаксический анализ? </p>
Я утверждаю, что у вас будет лучший, более дружественный интерфейс если вы потратите время на то, чтобы определить синтаксис явно. Запишите синтаксические уравнения или нарисуйте "railroad-track"  диаграммы и закодируйте синтаксический анализатор используя методы, которые я показал вам здесь. Вы получите более хорошую программу и ее будет проще писать, в придачу. </p>
СТАНОВИТСЯ ИНТЕРЕСНЕЙ </p>
Хорошо, сейчас мы имеем довольно хороший лексический анализатор, который разбивает входной поток на лексемы. Мы могли бы использовать его как есть и иметь полезный компилятор. Но есть некоторые другие аспекты лексического анализа, которые мы должны охватить. </p>
Особенно следует рассмотреть (вздрогните) эффективность. Помните, когда мы работали с одно-символьными токенами, каждой проверкой было сравнение одного символа Look с байтовой константой. Мы также использовали в основном оператор Case. </p>
С много символьными лексемами, возвращаемыми Scan, все эти проверки становятся сравнением строк. Гораздо медленнее. И не только медленнее но и неудобней, так как в Паскале не существует строкового эквивалента оператора Case. Особенно расточительным кажется проверять то что состоит из одного символа... "=",  "+" и другие операторы... используя сравнение строк. </p>
Сравнение строк не является невозможным. Рон Кейн использовал этот подход при написании Small C. Так как мы придерживаемся принципа KISS мы были бы оправданы согласившись с этим подходом. Но тогда я не смог бы рассказать вам об одном из ключевых методов, используемых в "настоящих" компиляторах. </p>
Вы должны запомнить: лексический анализатор будет вызываться часто! Фактически один раз для каждой лексемы во всей исходной программе. Эксперименты показали, что средний компилятор тратит где-то от 20 до 40 процентов своего времени на подпрограммах лексического анализа. Если существовало когда-либо место, где эффективность заслуживает пристального рассмотрения, то это оно. </p>
По этой причине большинство создателей компиляторов заставляют лексический анализатор выполнять немного больше работы, "токенизируя" входной поток. Идея состоит в том, чтобы сравнивать каждую лексему со списком допустимых ключевых слов и операторов и возвращать уникальный код для каждой распознанной. В случае обычного имени переменной или числа мы просто возвращаем код, который говорит, к какому типу лексем они относятся и сохраняем где-нибудь текущую строку. </p>
Первое, что нам нужно - это способ идентификации ключевых слов. Мы всегда можем сделать это с помощью последовательных проверок IF, но несомненно было бы хорошо, если бы мы имели универсальную подпрограмму, которая могла бы сравнивать данную строку с таблицей ключевых слов. (Между прочим, позднее нам понадобится такая же подпрограмма для работы с таблицей идентификаторов). Это обычно выявляет проблему Паскаля, потому что стандартный Паскаль не имеет массивов переменной длины. Это настоящая головная боль - объявлять различные подпрограммы поиска для каждой таблицы. Стандартный Паскаль также не позволяет инициализировать массивы, поэтому вам придется видеть код типа: </p>
     Table[1] := 'IF'; <br>
     Table[2] := 'ELSE'; <br>
     . <br>
<p>     . </p>
     Table[n] := 'END'; </p>
что может получиться довольно длинным если есть много ключевых слов. </p>
К счастью Turbo Pascal 4.0 имеет расширения, которые устраняют обе эти проблемы. Массивы-константы могут быть объявлены с использованием средства TP "типизированные константы" а переменные размерности могут быть поддержаны с помощью Си-подобных расширений для указателей. </p>
Сначала, измените ваши объявления подобным образом: </p>
<pre name="code" class="delphi">
{ Type Declarations  } 
type Symbol = string[8]; 
     SymTab = array[1..1000] of Symbol; 
     TabPtr = ^SymTab; 
</pre>
&nbsp;</p>
&nbsp;</p>
&nbsp;</p>
(Размерность, использованная в SymTab не настоящая... память не распределяется непосредственно этим объявлением,  а размерность должна быть только "достаточно большой") </p>
Затем, сразу после этих объявлений, добавьте следующее: </p>
<pre name="code" class="delphi">
{ Definition of Keywords and Token Types } 
const KWlist: array [1..4] of Symbol = 
               ('IF', 'ELSE', 'ENDIF', 'END'); 
</pre>
&nbsp;</p>
Затем, вставьте следующую новую функцию: </p>
<pre name="code" class="delphi">
{ Table Lookup } 
{ If the input string matches a table entry, return the entry 
   index.  If not, return a zero.  } 
function Lookup(T: TabPtr; s: string; n: integer): integer; 
var i: integer; 
    found: boolean; 
begin 
   found := false; 
   i := n; 
   while (i &gt; 0) and not found do 
      if s = T^[i] then 
         found := true 
      else 
         dec(i); 
   Lookup := i; 
end; 
</pre>
&nbsp;</p>
Чтобы проверить ее вы можете временно изменить основную программу следующим образом: </p>
<pre name="code" class="delphi">
{ Main Program } 
begin 
   ReadLn(Token); 
   WriteLn(Lookup(Addr(KWList), Token, 4)); 
end.
</pre>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;</p>
Обратите внимание как вызывается Lookup: функция Addr устанавливает указатель на KWList, который передается в Lookup. </p>
ОК, испытайте ее. Так как здесь мы пропускаем Scan, для получения соответствия вы должны набирать ключевые слова в верхнем регистре. </p>
Теперь, когда мы можем распознавать ключевые слова, далее необходимо договориться о возвращаемых для них кодах. </p>
Итак, какие кода мы должны возвращать? В действительности есть только два приемлемых варианта. Это похоже на идеальное применения перечисляемого типа Паскаля. К примеру, вы можете определить что-то типа </p>
     SymType = (IfSym, ElseSym, EndifSym, EndSym, Ident, Number, Operator); </p>
и договориться возвращать переменную этого типа. Давайте попробуем это. Вставьте строку выше в описание типов. </p>
Теперь добавьте два описания переменных: </p>
     Token: Symtype;          { Current Token  } </p>
     Value: String[16];       { String Token of Look } </p>
Измените сканер так: </p>
<pre name="code" class="delphi">
{ Lexical Scanner } 
procedure Scan; 
var k: integer; 
begin 
   while Look = CR do 
      Fin; 
   if IsAlpha(Look) then begin 
      Value := GetName; 
      k := Lookup(Addr(KWlist), Value, 4); 
      if k = 0 then 
         Token := Ident 
      else 
         Token := SymType(k - 1); 
      end 
   else if IsDigit(Look) then begin 
      Value := GetNum; 
      Token := Number; 
      end 
   else if IsOp(Look) then begin 
      Value := GetOp; 
     Token := Operator; 
      end 
   else begin 
      Value := Look; 
      Token := Operator; 
      GetChar; 
   end; 
   SkipWhite; 
end;
</pre>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;</p>
(Заметьте, что Scan сейчас стала процедурой а не функцией). </p>
<pre name="code" class="delphi">
{ Main Program } 
begin 
   Init; 
   repeat 
      Scan; 
      case Token of 
        Ident: write('Ident '); 
        Number: Write('Number '); 
        Operator: Write('Operator '); 
        IfSym, ElseSym, EndifSym, EndSym: Write('Keyword '); 
      end; 
      Writeln(Value); 
   until Token = EndSym; 
end.
</pre>
Наконец, измените основную программу: </p>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;</p>
Мы заменили строку Token, используемую раньше, на перечислимый тип. Scan возвращает тип в переменной Token и возвращает саму строку в новой переменной Value. </p>
ОК, откомпилируйте программу и погоняйте ее. Если все работает, вы должны увидеть, что теперь мы распознаем ключевые слова. </p>
Теперь у нас все работает правильно, и было легко сгенерировать это из того, что мы имели раньше. Однако, она все равно кажется мне немного "перегруженной". Мы можем ее немного упростить, позволив GetName, GetNum, GetOp и Scan работать с глобальными переменными Token и Value, вследствие этого удаляя их локальные копии. Кажется немного умней было бы переместить просмотр таблицы в GetName. Тогда новая форма для этих четырех процедур будет такой: </p>
<pre name="code" class="delphi">
{ Get an Identifier } 
procedure GetName; 
var k: integer; 
begin 
   Value := ''; 
   if not IsAlpha(Look) then Expected('Name'); 
   while IsAlNum(Look) do begin 
     Value := Value + UpCase(Look); 
     GetChar; 
   end; 
   k := Lookup(Addr(KWlist), Value, 4); 
   if k = 0 then 
      Token := Ident 
   else 
      Token := SymType(k-1); 
end; 
 
{ Get a Number } 
procedure GetNum; 
begin 
   Value := ''; 
   if not IsDigit(Look) then Expected('Integer'); 
   while IsDigit(Look) do begin 
     Value := Value + Look; 
     GetChar; 
   end; 
   Token := Number; 
end; 
 
{ Get an Operator } 
procedure GetOp; 
begin 
   Value := ''; 
   if not IsOp(Look) then Expected('Operator'); 
   while IsOp(Look) do begin 
     Value := Value + Look; 
     GetChar; 
   end; 
   Token := Operator; 
end; 
 
{ Lexical Scanner } 
procedure Scan; 
var k: integer; 
begin 
   while Look = CR do 
      Fin; 
   if IsAlpha(Look) then 
      GetName 
   else if IsDigit(Look) then 
      GetNum 
   else if IsOp(Look) then 
      GetOp 
   else begin 
      Value := Look; 
      Token := Operator; 
      GetChar; 
   end; 
   SkipWhite; 
end; 
</pre>
&nbsp;</p>
&nbsp;</p>
&nbsp;<br>
<p>  </p>
ВОЗВРАЩЕНИЕ СИМВОЛА </p>
По существу, все сканеры, которые я когда-либо видел, и которые написаны на Паскале, использовали механизм перечислимых типов, который я только что описал. Это конечно работающий механизм, но он не кажется мне самым простым подходом. </p>
Прежде всего, список возможных типов символов может получиться довольно длинным. Здесь я использовал только один символ "Operator" для обозначения всех операторов, но я видел другие проекты, в которых фактически возвращаются различные кода для каждого. </p>
Существует, конечно, другой простой тип, который может быть возвращен как код: символ. Вместо возвращения значения "Operator" для знака "+", что неправильного в том, чтобы просто возвращать сам символ? Символ - такая же хорошая переменная для кодирования различных типов лексем, она легко может быть использована в операторах Case, и это гораздо проще набрать. Что может быть проще? </p>
Кроме того, мы уже имели опыт с идеей кодировать ключевые слова как одиночные символы. Наши предыдущие программы уже написаны таким способом, так что использование этого метода минимизирует изменения того, что мы уже сделали. </p>
Некоторые из вас могут почувствовать, что идея с возвращение символьных кодов слишком детская. Я должен допустить, что она становится немного неуклюжей для операторов типа "&lt;=". Если вы хотите остаться с перечислимыми типами, хорошо. Для остальных я хотел бы показать как изменить то, что мы сделали выше, для поддержки такого подхода. </p>
Во-первых, сейчас вы можете удалить объявление типа SymType... он нам больше не понадобится. И вы можете изменить тип Token в char. </p>
Затем, чтобы заменить SymType, добавьте следующую константу: </p>
     const KWcode: string[5] = 'xilee'; </p>
(Я буду кодировать все идентификаторы одиночным символом 'x'). </p>
Наконец измените Scan и его родственников следующим образом: </p>
<pre name="code" class="delphi">
{ Get an Identifier } 
procedure GetName; 
begin 
   Value := ''; 
   if not IsAlpha(Look) then Expected('Name'); 
   while IsAlNum(Look) do begin 
     Value := Value + UpCase(Look); 
     GetChar; 
   end; 
   Token := KWcode[Lookup(Addr(KWlist), Value, 4) + 1]; 
end; 
 
{ Get a Number } 
procedure GetNum; 
begin 
   Value := ''; 
   if not IsDigit(Look) then Expected('Integer'); 
   while IsDigit(Look) do begin 
     Value := Value + Look; 
     GetChar; 
   end; 
   Token := '#'; 
end; 
 
{ Get an Operator } 
procedure GetOp; 
begin 
   Value := ''; 
   if not IsOp(Look) then Expected('Operator'); 
   while IsOp(Look) do begin 
     Value := Value + Look; 
     GetChar; 
   end; 
   if Length(Value) = 1 then 
      Token := Value[1] 
   else 
      Token := '?'; 
end; 
 
{ Lexical Scanner } 
procedure Scan; 
var k: integer; 
begin 
   while Look = CR do 
      Fin; 
   if IsAlpha(Look) then 
      GetName 
   else if IsDigit(Look) then 
      GetNum 
   else if IsOp(Look) then begin 
      GetOp 
   else begin 
      Value := Look; 
      Token := '?'; 
      GetChar; 
   end; 
   SkipWhite; 
end; 
 
{ Main Program } 
begin 
   Init; 
   repeat 
      Scan; 
      case Token of 
        'x': write('Ident '); 
        '#': Write('Number '); 
        'i', 'l', 'e': Write('Keyword '); 
       else Write('Operator '); 
      end; 
      Writeln(Value); 
   until Value = 'END'; 
end. 
</pre>
&nbsp;</p>
&nbsp;</p>
&nbsp;</p>
Эта программа должна работать также как и предыдущая версия. Небольшое различие в структуре, может быть, но она кажется мне более простой. </p>
РАСПРЕДЕЛЕННЫЕ СКАНЕРЫ ПРОТИВ ЦЕНТРАЛИЗОВАННЫХ </p>
Структура лексического анализатора, которую я только что вам показал, весьма стандартна и примерно 99% всех компиляторов используют что-то очень близкое к ней. Это, однако, не единственно возможная структура, или даже не всегда самая лучшая. </p>
Проблема со стандартным подходом состоит в том, что сканер не имеет никаких сведений о контексте. Например, он не может различить оператор присваивания "=" и оператор отношения "=" (возможно именно поэтому и C и Паскаль используют для них различные строки). Все, что сканер может сделать, это передать оператор синтаксическому анализатору, который может точно сказать исходя из контекста, какой это оператор. Точно так же, ключевое слово "IF" не может быть посредине арифметического выражения, но если ему случится оказаться там, сканер не увидит в этом никакой проблемы и возвратит его синтаксическому анализатору, правильно закодировав как "IF". </p>
С таким подходом, мы в действительности не используем всю информацию, имеющуюся в нашем распоряжении. В середине выражения, например синтаксический анализатор "знает", что нет нужды искать ключевое слово, но он не имеет никакой возможности сказать это сканеру. Так что сканер продолжает делать это. Это, конечно, замедляет компиляцию. </p>
В настоящих компиляторах проектировщики часто принимают меры для передачи подробной информации между сканером и парсером, только чтобы избежать такого рода  проблем. Но это может быть неуклюже и, конечно, уничтожит часть модульности в структуре компилятора. </p>
Альтернативой является поиск какого-то способа для использования контекстной информации, которая исходит из знания того, где мы находимся в синтаксическом анализаторе. Это возвращает нас обратно к понятию распределенного сканера, в котором различные части сканера вызываются в зависимости от контекста. </p>
В языке KISS, как и большинстве языков, ключевые слова появляются только в начале утверждения. В таких местах, как выражения они запрещены. Также, с одним небольшим исключением (много символьные операторы отношений), которое легко обрабатывается, все операторы одно-символьны, что означает, что нам совсем не нужен GetOp. </p>
Так что, оказывается, даже с много символьными токенами мы все еще можем всегда точно определить вид лексемы исходя из текущего предсказывающего символа, исключая самое начало утверждения. </p>
Даже в этой точке, единственным видом лексемы, который мы можем принять, является идентификатор. Нам необходимо только определить, является ли этот идентификатор ключевым словом или левой частью оператора присваивания. </p>
Тогда мы заканчиваем все еще нуждаясь только в GetName и GetNum, которые используются так же, как мы использовали их в ранних главах. </p>
Сначала вам может показаться, что это шаг назад и довольно примитивный способ. Фактически же, это усовершенствование классического сканера, так как мы используем подпрограммы сканирования только там, где они действительно нужны. В тех местах, где ключевые слова не разрешены, мы не замедляем компиляцию, ища их. </p>
ОБЪЕДИНЕНИЕ СКАНЕРА И ПАРСЕРА </p>
Теперь, когда мы охватили всю теорию и общие аспекты лексического анализа, я наконец готов подкрепит свое заявление о том, что мы можем приспособить много символьные токены с минимальными изменениями в нашей предыдущей работе. Для краткости и простоты я ограничу сам себя подмножеством того, что мы сделали ранее: я разрешу только одну управляющую конструкцию (IF) и никаких булевых выражений. Этого достаточно для демонстрации синтаксического анализа и ключевых слов и выражений. Расширение до полного набора конструкций должно быть довольно очевидно из того, что мы уже сделали. </p>
Все элементы программы для синтаксического анализа этого подмножества с использованием одно-символьных токенов уже существуют в наших предыдущих программах. Я построил ее осторожно скопировав эти файлы, но я не посмею попробовать провести вас через этот процесс. Вместо этого, во избежание беспорядка, вся программа показана ниже: </p>
<pre name="code" class="delphi">
program KISS; 
 
{ Constant Declarations } 
const TAB = ^I; 
       CR  = ^M; 
       LF  = ^J; 
 
{ Type Declarations  } 
type Symbol = string[8]; 
      SymTab = array[1..1000] of Symbol; 
      TabPtr = ^SymTab; 
 
{ Variable Declarations } 
var Look  : char;              { Lookahead Character } 
     Lcount: integer;           { Label Counter       } 
 
{ Read New Character From Input Stream } 
procedure GetChar; 
begin 
    Read(Look); 
end; 
 
{ Report an Error } 
procedure Error(s: string); 
begin 
    WriteLn; 
    WriteLn(^G, 'Error: ', s, '.'); 
end; 
 
{ Report Error and Halt } 
procedure Abort(s: string); 
begin 
    Error(s); 
    Halt; 
end; 
 
{ Report What Was Expected } 
procedure Expected(s: string); 
begin 
    Abort(s + ' Expected'); 
end; 
 
{ Recognize an Alpha Character } 
function IsAlpha(c: char): boolean; 
begin 
    IsAlpha := UpCase(c) in ['A'..'Z']; 
end; 
 
{ Recognize a Decimal Digit } 
function IsDigit(c: char): boolean; 
begin 
    IsDigit := c in ['0'..'9']; 
end; 
 
{ Recognize an AlphaNumeric Character } 
function IsAlNum(c: char): boolean; 
begin 
    IsAlNum := IsAlpha(c) or IsDigit(c); 
end; 
 
{ Recognize an Addop } 
function IsAddop(c: char): boolean; 
begin 
    IsAddop := c in ['+', '-']; 
end; 
 
{ Recognize a Mulop } 
function IsMulop(c: char): boolean; 
begin 
    IsMulop := c in ['*', '/']; 
end; 
 
{ Recognize White Space } 
function IsWhite(c: char): boolean; 
begin 
    IsWhite := c in [' ', TAB]; 
end; 
 
{ Skip Over Leading White Space } 
procedure SkipWhite; 
begin 
    while IsWhite(Look) do 
       GetChar; 
end; 
 
{ Match a Specific Input Character } 
procedure Match(x: char); 
begin 
    if Look &lt;&gt; x then Expected('''' + x + ''''); 
    GetChar; 
    SkipWhite; 
end; 
 
{ Skip a CRLF } 
procedure Fin; 
begin 
    if Look = CR then GetChar; 
    if Look = LF then GetChar; 
    SkipWhite; 
end; 
 
{ Get an Identifier } 
function GetName: char; 
begin 
    while Look = CR do 
       Fin; 
    if not IsAlpha(Look) then Expected('Name'); 
    Getname := UpCase(Look); 
    GetChar; 
    SkipWhite; 
end; 
 
{ Get a Number } 
function GetNum: char; 
begin 
    if not IsDigit(Look) then Expected('Integer'); 
    GetNum := Look; 
    GetChar; 
    SkipWhite; 
end; 
 
{ Generate a Unique Label } 
function NewLabel: string; 
var S: string; 
begin 
    Str(LCount, S); 
    NewLabel := 'L' + S; 
    Inc(LCount); 
end; 
 
{ Post a Label To Output } 
procedure PostLabel(L: string); 
begin 
    WriteLn(L, ':'); 
end; 
 
{ Output a String with Tab } 
procedure Emit(s: string); 
begin 
    Write(TAB, s); 
end; 
 
{ Output a String with Tab and CRLF } 
procedure EmitLn(s: string); 
begin 
    Emit(s); 
    WriteLn; 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate an Identifier } 
procedure Ident; 
var Name: char; 
begin 
    Name := GetName; 
    if Look = '(' then begin 
       Match('('); 
       Match(')'); 
       EmitLn('BSR ' + Name); 
       end 
    else 
       EmitLn('MOVE ' + Name + '(PC),D0'); 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate a Math Factor } 
procedure Expression; Forward; 
procedure Factor; 
begin 
    if Look = '(' then begin 
       Match('('); 
       Expression; 
       Match(')'); 
       end 
    else if IsAlpha(Look) then 
       Ident 
    else 
       EmitLn('MOVE #' + GetNum + ',D0'); 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate the First Math Factor } 
procedure SignedFactor; 
var s: boolean; 
begin 
    s := Look = '-'; 
    if IsAddop(Look) then begin 
       GetChar; 
       SkipWhite; 
    end; 
    Factor; 
    if s then 
       EmitLn('NEG D0'); 
end; 
 
{ Recognize and Translate a Multiply } 
procedure Multiply; 
begin 
    Match('*'); 
    Factor; 
    EmitLn('MULS (SP)+,D0'); 
end; 
{-------------------------------------------------------------} 
{ Recognize and Translate a Divide } 
procedure Divide; 
begin 
    Match('/'); 
    Factor; 
    EmitLn('MOVE (SP)+,D1'); 
    EmitLn('EXS.L D0'); 
    EmitLn('DIVS D1,D0'); 
end; 
{---------------------------------------------------------------} 
{ Completion of Term Processing  (called by Term and FirstTerm } 
 procedure Term1; 
 begin 
    while IsMulop(Look) do begin 
       EmitLn('MOVE D0,-(SP)'); 
       case Look of 
        '*': Multiply; 
        '/': Divide; 
       end; 
    end; 
 end; 
{---------------------------------------------------------------} 
{ Parse and Translate a Math Term } 
procedure Term; 
begin 
    Factor; 
    Term1; 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate a Math Term with Possible Leading Sign } 
procedure FirstTerm; 
begin 
    SignedFactor; 
    Term1; 
end; 
{---------------------------------------------------------------} 
{ Recognize and Translate an Add } 
procedure Add; 
begin 
    Match('+'); 
    Term; 
    EmitLn('ADD (SP)+,D0'); 
end; 
{---------------------------------------------------------------} 
{ Recognize and Translate a Subtract } 
procedure Subtract; 
begin 
    Match('-'); 
    Term; 
    EmitLn('SUB (SP)+,D0'); 
    EmitLn('NEG D0'); 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate an Expression } 
procedure Expression; 
begin 
    FirstTerm; 
    while IsAddop(Look) do begin 
       EmitLn('MOVE D0,-(SP)'); 
       case Look of 
        '+': Add; 
        '-': Subtract; 
       end; 
    end; 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate a Boolean Condition } 
{ This version is a dummy } 
 Procedure Condition; 
 begin 
    EmitLn('Condition'); 
 end; 
{---------------------------------------------------------------} 
{ Recognize and Translate an IF Construct } 
procedure Block; 
 Forward; 
procedure DoIf; 
var L1, L2: string; 
begin 
    Match('i'); 
    Condition; 
    L1 := NewLabel; 
    L2 := L1; 
    EmitLn('BEQ ' + L1); 
    Block; 
    if Look = 'l' then begin 
       Match('l'); 
       L2 := NewLabel; 
       EmitLn('BRA ' + L2); 
       PostLabel(L1); 
       Block; 
    end; 
    PostLabel(L2); 
    Match('e'); 
end; 
 
{ Parse and Translate an Assignment Statement } 
procedure Assignment; 
var Name: char; 
begin 
    Name := GetName; 
    Match('='); 
    Expression; 
    EmitLn('LEA ' + Name + '(PC),A0'); 
    EmitLn('MOVE D0,(A0)'); 
end; 
 
{ Recognize and Translate a Statement Block } 
procedure Block; 
begin 
    while not(Look in ['e', 'l']) do begin 
       case Look of 
        'i': DoIf; 
        CR: while Look = CR do 
               Fin; 
        else Assignment; 
       end; 
    end; 
end; 
 
{ Parse and Translate a Program } 
procedure DoProgram; 
begin 
    Block; 
    if Look &lt;&gt; 'e' then Expected('END'); 
    EmitLn('END') 
end; 
 
{ Initialize } 
procedure Init; 
begin 
    LCount := 0; 
    GetChar; 
end; 
 
{ Main Program } 
begin 
    Init; 
    DoProgram; 
end.
</pre>
&nbsp;<br>
<p>&nbsp;</p>
&nbsp;<br>
<p>  </p>
   Пара комментариев: </p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Форма синтаксического анализатора выражений, использующего FirstTerm и т.п., немного отличается от того, что вы видели ранее. Это еще одна вариация на ту же самую тему. Не позволяйте им вертеть вами... изменения необязательны для того, что будет дальше. </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Заметьте, что как обычно я добавил вызовы Fin в стратегических местах для поддержки множественных строк. </td></tr></table></div>Прежде чем приступить к добавлению сканера, сначала скопируйте этот файл и проверьте, что он действительно корректно выполняет анализ. Не забудьте "кода": "i" для IF, "l" для ELSE и "e" для ELSE или ENDIF. </p>
Если программа работает, тогда давайте поспешим. При добавлении модулей сканера в программу поможет систематический план. Во всех синтаксических анализаторах, которые мы написали до этого времени, мы придерживались соглашения, что текущий предсказывающий символ должен всегда быть непустым символом. Мы предварительно загружали предсказывающий символ в Init и после этого оставляли "помпу запущенной". Чтобы позволить программе работать правильно с новыми строками мы должны ее немного модифицировать и обрабатывать символ новой строки как допустимый токен. </p>
В много символьной версии правило аналогично: текущий предсказывающий символ должен всегда оставаться на начале следующей лексемы или на новой строке. </p>
Много символьная версия показана ниже. Чтобы получить ее я сделал следующие изменения: </p>
<div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Добавлены переменные Token и Value и определения типов, необходимые для Lookup. </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Добавлено определение KWList и KWcode. </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Добавлен Lookup. </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>GetName и GetNum заменены их много символьными версиями. (Обратите внимание, что вызов Lookup был перемещен из GetName, так что он не будет выполняться внутри выражений). </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Создана новая, рудиментарная Scan, которая вызывает GetName затем сканирует ключевые слова. </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Создана новая процедура MatchString, которая ищет конкретное ключевое слово. Заметьте, что в отличие от Match, MatchString не считывает следующее ключевое слово. </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Изменен Block для вызова Scan. </td></tr></table></div><div style="text-align: justify; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 8px 24px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="24">&#183;</td><td>Немного изменены вызовы Fin. Fin теперь вызывается из GetName. </td></tr></table></div>Программа полностью: </p>
<pre name="code" class="delphi">
program KISS; 
 
{ Constant Declarations } 
const TAB = ^I; 
      CR  = ^M; 
      LF  = ^J; 
 
{ Type Declarations  } 
type Symbol = string[8]; 
     SymTab = array[1..1000] of Symbol; 
     TabPtr = ^SymTab; 
 
{ Variable Declarations } 
var Look  : char;              { Lookahead Character } 
    Token : char;              { Encoded Token       } 
    Value : string[16];        { Unencoded Token     } 
    Lcount: integer;           { Label Counter       } 
 
{ Definition of Keywords and Token Types } 
const KWlist: array [1..4] of Symbol = 
              ('IF', 'ELSE', 'ENDIF', 'END'); 
const KWcode: string[5] = 'xilee'; 
 
{ Read New Character From Input Stream } 
procedure GetChar; 
begin 
   Read(Look); 
end; 
 
{ Report an Error } 
procedure Error(s: string); 
begin 
   WriteLn; 
   WriteLn(^G, 'Error: ', s, '.'); 
end; 
 
{ Report Error and Halt } 
procedure Abort(s: string); 
begin 
   Error(s); 
   Halt; 
end; 
 
{ Report What Was Expected } 
procedure Expected(s: string); 
begin 
   Abort(s + ' Expected'); 
end; 
 
{ Recognize an Alpha Character } 
function IsAlpha(c: char): boolean; 
begin 
   IsAlpha := UpCase(c) in ['A'..'Z']; 
end; 
 
{ Recognize a Decimal Digit } 
function IsDigit(c: char): boolean; 
begin 
   IsDigit := c in ['0'..'9']; 
end; 
 
{ Recognize an AlphaNumeric Character } 
function IsAlNum(c: char): boolean; 
begin 
   IsAlNum := IsAlpha(c) or IsDigit(c); 
end; 
 
{ Recognize an Addop } 
function IsAddop(c: char): boolean; 
begin 
   IsAddop := c in ['+', '-']; 
end; 
 
{ Recognize a Mulop } 
function IsMulop(c: char): boolean; 
begin 
   IsMulop := c in ['*', '/']; 
end; 
 
{ Recognize White Space } 
function IsWhite(c: char): boolean; 
begin 
   IsWhite := c in [' ', TAB]; 
end; 
 
{ Skip Over Leading White Space } 
procedure SkipWhite; 
begin 
   while IsWhite(Look) do 
      GetChar; 
end; 
 
{ Match a Specific Input Character } 
procedure Match(x: char); 
begin 
   if Look &lt;&gt; x then Expected('''' + x + ''''); 
   GetChar; 
   SkipWhite; 
end; 
 
{ Skip a CRLF } 
procedure Fin; 
begin 
   if Look = CR then GetChar; 
   if Look = LF then GetChar; 
   SkipWhite; 
end; 
 
{ Table Lookup } 
function Lookup(T: TabPtr; s: string; n: integer): integer; 
var i: integer; 
    found: boolean; 
begin 
   found := false; 
   i := n; 
   while (i &gt; 0) and not found do 
      if s = T^[i] then 
         found := true 
      else 
         dec(i); 
   Lookup := i; 
end; 
 
{ Get an Identifier } 
procedure GetName; 
begin 
   while Look = CR do 
      Fin; 
   if not IsAlpha(Look) then Expected('Name'); 
   Value := ''; 
   while IsAlNum(Look) do begin 
     Value := Value + UpCase(Look); 
     GetChar; 
   end; 
   SkipWhite; 
end; 
 
{ Get a Number } 
procedure GetNum; 
begin 
   if not IsDigit(Look) then Expected('Integer'); 
   Value := ''; 
   while IsDigit(Look) do begin 
     Value := Value + Look; 
     GetChar; 
   end; 
   Token := '#'; 
   SkipWhite; 
end; 
 
{ Get an Identifier and Scan it for Keywords } 
procedure Scan; 
begin 
   GetName; 
   Token := KWcode[Lookup(Addr(KWlist), Value, 4) + 1]; 
end; 
 
{ Match a Specific Input String } 
procedure MatchString(x: string); 
begin 
   if Value &lt;&gt; x then Expected('''' + x + ''''); 
end; 
 
{ Generate a Unique Label } 
function NewLabel: string; 
var S: string; 
begin 
   Str(LCount, S); 
   NewLabel := 'L' + S; 
   Inc(LCount); 
end; 
 
{ Post a Label To Output } 
procedure PostLabel(L: string); 
begin 
   WriteLn(L, ':'); 
end; 
 
{ Output a String with Tab } 
procedure Emit(s: string); 
begin 
   Write(TAB, s); 
end; 
 
{ Output a String with Tab and CRLF } 
procedure EmitLn(s: string); 
begin 
   Emit(s); 
   WriteLn; 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate an Identifier } 
procedure Ident; 
begin 
   GetName; 
   if Look = '(' then begin 
      Match('('); 
      Match(')'); 
      EmitLn('BSR ' + Value); 
      end 
   else 
      EmitLn('MOVE ' + Value + '(PC),D0'); 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate a Math Factor } 
procedure Expression; Forward; 
procedure Factor; 
begin 
   if Look = '(' then begin 
      Match('('); 
      Expression; 
      Match(')'); 
      end 
   else if IsAlpha(Look) then 
      Ident 
   else begin 
      GetNum; 
      EmitLn('MOVE #' + Value + ',D0'); 
   end; 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate the First Math Factor } 
procedure SignedFactor; 
var s: boolean; 
begin 
   s := Look = '-'; 
   if IsAddop(Look) then begin 
      GetChar; 
      SkipWhite; 
   end; 
   Factor; 
   if s then 
      EmitLn('NEG D0'); 
end; 
 
{ Recognize and Translate a Multiply } 
procedure Multiply; 
begin 
   Match('*'); 
   Factor; 
   EmitLn('MULS (SP)+,D0'); 
end; 
{-------------------------------------------------------------} 
{ Recognize and Translate a Divide } 
procedure Divide; 
begin 
   Match('/'); 
   Factor; 
   EmitLn('MOVE (SP)+,D1'); 
   EmitLn('EXS.L D0'); 
   EmitLn('DIVS D1,D0'); 
end; 
{---------------------------------------------------------------} 
{ Completion of Term Processing  (called by Term and FirstTerm } 
procedure Term1; 
begin 
   while IsMulop(Look) do begin 
      EmitLn('MOVE D0,-(SP)'); 
      case Look of 
       '*': Multiply; 
       '/': Divide; 
      end; 
   end; 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate a Math Term } 
procedure Term; 
begin 
   Factor; 
   Term1; 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate a Math Term with Possible Leading Sign } 
procedure FirstTerm; 
begin 
   SignedFactor; 
   Term1; 
end; 
{---------------------------------------------------------------} 
{ Recognize and Translate an Add } 
procedure Add; 
begin 
   Match('+'); 
   Term; 
   EmitLn('ADD (SP)+,D0'); 
end; 
{---------------------------------------------------------------} 
{ Recognize and Translate a Subtract } 
procedure Subtract; 
begin 
   Match('-'); 
   Term; 
   EmitLn('SUB (SP)+,D0'); 
   EmitLn('NEG D0'); 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate an Expression } 
procedure Expression; 
begin 
   FirstTerm; 
   while IsAddop(Look) do begin 
      EmitLn('MOVE D0,-(SP)'); 
      case Look of 
       '+': Add; 
       '-': Subtract; 
      end; 
   end; 
end; 
{---------------------------------------------------------------} 
{ Parse and Translate a Boolean Condition } 
{ This version is a dummy } 
Procedure Condition; 
begin 
   EmitLn('Condition'); 
end; 
{---------------------------------------------------------------} 
{ Recognize and Translate an IF Construct } 
procedure Block; Forward; 
procedure DoIf; 
var L1, L2: string; 
begin 
   Condition; 
   L1 := NewLabel; 
   L2 := L1; 
   EmitLn('BEQ ' + L1); 
   Block; 
   if Token = 'l' then begin 
      L2 := NewLabel; 
      EmitLn('BRA ' + L2); 
      PostLabel(L1); 
      Block; 
   end; 
   PostLabel(L2); 
   MatchString('ENDIF'); 
end; 
 
{ Parse and Translate an Assignment Statement } 
procedure Assignment; 
var Name: string; 
begin 
   Name := Value; 
   Match('='); 
   Expression; 
   EmitLn('LEA ' + Name + '(PC),A0'); 
   EmitLn('MOVE D0,(A0)'); 
end; 
 
{ Recognize and Translate a Statement Block } 
procedure Block; 
begin 
   Scan; 
   while not (Token in ['e', 'l']) do begin 
      case Token of 
       'i': DoIf; 
       else Assignment; 
      end; 
      Scan; 
   end; 
end; 
 
{ Parse and Translate a Program } 
procedure DoProgram; 
begin 
   Block; 
   MatchString('END'); 
   EmitLn('END') 
end; 
 
{ Initialize } 
procedure Init; 
begin 
   LCount := 0; 
   GetChar; 
end; 
 
{ Main Program } 
begin 
   Init; 
   DoProgram; 
end. 
</pre>
&nbsp;</p>
&nbsp;</p>
&nbsp;</p>
Сравните эту программу с ее одно-символьным вариантом. Я думаю вы согласитесь, что различия минимальны. </p>
ЗАКЛЮЧЕНИЕ </p>
К этому времени вы узнали как анализировать и генерировать код для выражений, булевых выражений и управляющих структур. Теперь вы изучили, как разрабатывать лексические анализаторы и как встроить их элементы в транслятор. Вы все еще не видели всех элементов, объединенных в одну программу, но на основе того, что мы сделали ранее вы должны прийти к заключению, что легко расширить наши ранние программы для включения лексических анализаторов. </p>
Мы очень близки к получению всех элементов, необходимых для построения настоящего, функционального компилятора. Есть еще несколько отсутствующих вещей, особенно вызовы процедур и определения типов. Мы будем работать с ними на следующих нескольких уроках. Прежде чем сделать это, однако, я подумал что было бы забавно превратить транслятор в настоящий компилятор. Это то, чем мы займемся в следующей главе. </p>
До настоящего времени мы применяли предпочтительно восходящий метод синтаксического анализа, начиная с низкоуровневых конструкций и продвигаясь вверх. В следующей главе я также взгляну сверху вниз, и мы обсудим, как изменяется структура транслятора при изменении определения языка. </p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
