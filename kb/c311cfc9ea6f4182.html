<!DOCTYPE html>
<html>
<head>
  <title>Алгоритм 2. Пузырьковая сортировка</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Алгоритм 2. Пузырьковая сортировка</h1>
<div id="date">01.01.2010</div>
<p>Алгоритм 2. Пузырьковая сортировка. </p>
<p>Реализация данного метода не требует дополнительной памяти. Метод очень прост и состоит в следующем: берется пара рядом стоящих элементов, и если элемент с меньшим индексом оказывается больше элемента с большим индексом, то мы меняем их местами. Эти действия продолжаем, пока есть такие пары. Легко понять, что когда таких пар не останется, то данные будут отсортированными. Для упрощения поиска таких пар данные просматриваются по порядку от начала до конца. Из этого следует, что за такой просмотр находится максимум, который помещается в конец массива, а потому следующий раз достаточно просматривать уже меньшее количество элементов. Максимальный элемент как бы всплывает вверх, отсюда и название алгоритма&nbsp; Так как каждый раз на свое место становится по крайней мере один элемент, то не потребуется более N проходов, где&nbsp; N &#8212; количество элементов. Вот как это можно реализовать:</p>
<pre name="code" class="delphi">
Program BubbleSort;
Var A    : array[1..1000] of integer;
    N,i,j,p : integer;       
Begin
 {Определение размера массива A (N) и его заполнение}
 …
 {сортировка данных}
 for i:=1 to n do
  for j:=1 to n-i do
  if A[j]&gt;A[j+1] then
   begin  {Обмен элементов}
    p:=A[j];
    A[j]:=A[j+1];
    A[j+1]:=P;
   end;
 {Вывод отсортированного массива A}
 …
End.
</pre>

</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
