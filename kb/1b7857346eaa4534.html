<!DOCTYPE html>
<html>
<head>
  <title>Определение правил и умолчаний для данных</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link type="text/css" href="css/css.css" rel="stylesheet"/>
  <link type="text/css" href="css/sh.css" rel="stylesheet"/>
  <script language="javascript" src="js/shInit.js"></script>
  <script language="javascript" src="js/shCore.js"></script>
  <script language="javascript" src="js/shBrushDelphi.js"></script>
  <script language="javascript" src="js/shBrushSql.js"></script>
</head>
<body>
<div id="layout">
<div id="header">
  <a title="DRKB Library" href="../splash.html"><div id="logo"></div></a>
</div>
<div id="content">
<div id="explorer">DRKB Explorer</div>
  <h1 id="title">Определение правил и умолчаний для данных</h1>
<div id="date">01.01.2010</div>

<p>Определение правил и умолчаний для данных</p>
&nbsp;</p>
Значения по умолчанию определяются для столбцов таблицы или для определенных пользователем типов данных для того, чтобы это значение записывалось в таблицу автоматически в том случае, если явно не указано никакого&nbsp; другого значения. Пользователь может также присоединить правило к полю таблицы или к типу данных для того, чтобы ограничить данные, которые могут быть использованы в этом поле или типе. </p>
В этой главе рассматриваются следующие вопросы:</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 113px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="13">&#183;</td><td>Общий обзор правил и умолчаний;</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 113px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="13">&#183;</td><td>Как создавать и удалять умолчания;</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 113px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="13">&#183;</td><td>Как использовать по умолчанию неопределенные значения; </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 113px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="13">&#183;</td><td>Как создавать и удалять правила;</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 113px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="13">&#183;</td><td>Как получить информацию о правилах и умолчаниях.</td></tr></table></div>&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 21px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Что такое правила и умолчания?</td></tr></table></div>&nbsp;</p>
Значение по умолчанию - это значение, которое SQL Сервер вставляет в некоторое поле, если пользователь не указал явно никакого значения для этого поля. В системах управления базами данных правило указывает, какого вида данные допускаются для столбца таблицы или типа данных определенного пользователем. Правила и умолчания используются для достижения целостности данных в базе. </p>
В системах управления реляционными базами данных каждый элемент базы, например, определенный столбец в определенной строке, должен иметь какое-либо значение, даже если это неопределенное значение NULL. Как уже говорилось в главе 7 “ Создание баз данных и таблиц”, в некоторые столбцы нельзя записывать неопределенное значение. В такие столбцы пользователь должен ввести определенное значение, либо по умолчанию это должен сделать&nbsp; SQL Сервер.</p>
Значения по умолчанию, определенные пользователем, позволяют SQL Серверу автоматически записывать в поле некоторое значение, если для этого поля явно не было указано никакого значения, независимо от того допускает ли это поле неопределенные значения или нет. Например, можно определить по умолчанию значение “???” или значение “заполнить позже”.</p>
Правила обеспечивают поддержку целостности данных в том отношении, в каком ее нельзя обеспечить простым разделением данных на типы. Правила могут быть связаны с определенным столбцом таблицы, или с группой столбцов, или с типом данных пользователя.</p>
Каждый раз, когда пользователь записывает в столбец таблицы данные с помощью операторов insert и update, SQL сервер проверяет, соответствуют ли они правилу, которое связано с этим столбцом.  Данные, которые были записаны в табличный столбец до введения и присоединения к нему правила, не проверяются на соответствие этому правилу.</p>
&nbsp;</p>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Замечание: Можно присоединить к столбцу данных числового типа правило для данных символьного типа, хотя это и не имеет смысла. Правила проверяются во время исполнения операторов insert и update, а не во время их создания.</p>
&nbsp;</p>
В данной главе объясняется, как создавать правила и умолчания с помощью команд create default (создать умолчание) и create rule (создать правило), а также как связывать правила и умолчания к столбцу или к типу данных пользователя с помощью системных процедур sp_bindefault (присоединить умолчание), sp_bindrule (присоединить правило), sp_unbindefault (отсоединить умолчание), sp_unbindrule (отсоединить правило). </p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 42px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td> Сравнение правил и умолчаний с условиями целостности</td></tr></table></div>&nbsp;</p>
Вместо создания правил и умолчаний, можно&nbsp; сразу в операторе создания таблицы create table указать конструкцию default (умолчание) и опцию check (проверка), которые выполняют аналогичную роль. Однако, эти&nbsp; правила и умолчания будут действовать только для одной таблицы и не могут быть связаны со столбцами других таблиц или типами данных пользователя. Подробная информация об условиях сохранения целостности данных в отдельной таблице содержится в главе 7 “Создание баз данных и таблиц”.</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 21px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Создание умолчаний</td></tr></table></div>&nbsp;</p>
Умолчания могут создаваться и удаляться в любой момент, до или после введения данных в таблицу. Значения по умолчанию создаются командой create default (создать умолчание), а удаляются с командой drop default (удалить умолчание). </p>
Умолчание может быть связано с определенным столбцом таблицы, с несколькими столбцами или со всеми столбцами таблиц базы данных, имеющими заданный пользователем тип данных. Для связывания умолчания со столбцом или типом данных используется системная процедура sp_bindefault (присоединить умолчание). Для отсоединения умолчания применяется процедура sp_unbindefault (отсоединить умолчание).</p>
Ниже приведены некоторые условия, которые нужно проверить при создании и присоединении умолчаний:</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">&#183;</td><td>Необходимо убедиться, что размер данных в столбце достаточен для значения, задаваемого по умолчанию. Например, в столбце типа char(2) не допускается хранение 17-байтовой строки “Nobody knows yet”;</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">&#183;</td><td>Нужно внимательно относиться к определению значений по умолчанию, заданных для всего типа данных, и их переопределению для отдельных столбцов этого типа. Если вначале со столбцом связывается тип данных, определенный пользователем и имеющий свое значение по умолчанию, а затем для этого столбца указывается другое значение по умолчанию, то последнее значение заменит первое только в указанном столбце. Первое значение будет действовать по умолчанию во&nbsp; всех других столбцах, имеющих этот тип. Однако, если для столбца было определено другое значение, отличное от типового, то изменение типового значения уже не будет влиять на этот столбец. Этот вопрос будет более подробно обсуждаться в данной главе;</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">&#183;</td><td>Следует избегать конфликтов между умолчаниями и правилами. Нужно убедиться, что значение по умолчанию соответствует правилу, в противном случае, умолчание будет исключаться;</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">&#183;</td><td>Например, рассмотрим ситуацию, когда правилом в данном столбце допускаются числа от 1 до 100, а значение по умолчанию для этого столбца равно 0. В этом случае правило будет каждый раз отклонять значение, вводимое по умолчанию, и будет получено сообщение об ошибке, если&nbsp; столбец не допускает неопределенного значения NULL. Если столбец или умолчание допускают неопределенное значение, то будет вводиться значение “NULL”. Таким образом, либо правило, либо умолчание нужно изменить.</td></tr></table></div>&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 42px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Синтаксис команды create default</td></tr></table></div>&nbsp;</p>
Синтаксис команды create default выглядит следующим образом:</p>
&nbsp;</p>
create default [имя_владельца.]название_умолчания </p>
 &nbsp; &nbsp; &nbsp; &nbsp;as константное_выражение</p>
&nbsp;</p>
Названия умолчаний должны соответствовать правилам, установленным для идентификаторов. Умолчания можно создавать только в текущей базе данных.</p>
Внутри одной базы данных названия умолчаний должны быть уникальными у каждого пользователя. Например, нельзя одному пользователю создать два умолчания с названием phonedflt. Однако, любой (пользователь) - “гость” может создать умолчание phonedflt, даже если умолчание с таким названием уже существует в этой базе данных, поскольку имена пользователей добавляются к названиям умолчаний, что и позволяет различать их.</p>
Здесь будет показано, как создать значение по умолчанию “Oakland”, которое использовалось в столбце city таблицы friends_etc  (создание этой таблицы рассматривалось в главе 7 “Создание баз данных и таблиц”) и которое возможно будет полезно для других столбцов или типов данных. Во время работы с этим примером можно использовать название любого другого города, которое имеет смысл для того контингента людей, сведения о которых планируется хранить в таблице. Для создания этого умолчания нужно выполнить команду:</p>
&nbsp;</p>
create default citydflt</p>
as “Oakland”</p>
&nbsp;</p>
После слова as можно задать любую константу. Символьные константы и даты должны быть заключены в кавычки; для денежных, целых и числовых констант с плавающей точкой кавычки не обязательны.&nbsp; Двоичным данным должен предшествовать символ 0х, а денежным данным - символ доллара ($). Значение по умолчанию должно соответствовать типу данных, установленному для столбца. Например, нельзя использовать в качестве значения по умолчанию строку “none” для столбца числового типа, а число 0 (ноль) можно.&nbsp;&nbsp; </p>
Если при создании столбца было указано на недопустимость в нем неопределенных значений (NOT NULL) и с этим столбцом не было связано никаких значений по умолчанию, то SQL Сервер будет выдавать сообщение об ошибке каждый раз, когда в этом столбце будут отсутствовать данные. </p>
Часто значения по умолчанию создаются при создании самой таблицы. Однако, если во время одного сеанса работы нужно ввести большое количество строк с одинаковыми значениями в одном или нескольких столбцах, то удобнее было бы создать умолчание, которое присоединяется на время одного сеанса работы.</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 42px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Присоединение умолчаний</td></tr></table></div>&nbsp;</p>
После того, как умолчание было создано, следует использовать системную процедуру sp_bindefault (присоединить умолчание) для присоединения этого умолчания к столбцу или типу данных, определенному пользователем.</p>
&nbsp;</p>
create default phonedflt as “UNKNOWN”</p>
&nbsp;</p>
Здесь определено значение по умолчанию. Теперь необходимо присоединить это значение к соответствующему столбцу или к типу данных пользователя с помощью системной процедуры sp_bindefault.</p>
&nbsp;</p>
sp_bindefault phonedflt, “authors.phone”</p>
&nbsp;</p>
Это значение по умолчанию будет записываться в таблицу authors  (авторы) только в том случае, если для столбца phone (телефон) не указано никакого значения. Таким образом, отсутствие данных в столбце не обязательно приводит к появлению в нем неопределенного значения.</p>
&nbsp;</p>
Замечание: Чтобы в столбец по умолчанию записалось определенное значение необходимо выполнить команду insert или update со списком столбцов, в котором нет этого столбца.</p>
&nbsp;</p>
Умолчание действует только для новых строк. Оно не оказывает обратного действия на уже существующие строки. Конечно, умолчание вступает в силу только тогда, когда не было указано никакого другого значения. Если пользователь указал другое значение, в том числе и неопределенное значение NULL, то умолчание не будет действовать.</p>
Ниже показано, как присоединить умолчание citydflt  к столбцу city таблицы friends_etc:</p>
&nbsp;</p>
sp_bindefault citydflt, “friends_etc.city”</p>
&nbsp;</p>
Заметим, что название таблицы и столбца заключаются в кавычки, поскольку они разделены знаком пунктуации, которым в данном случае является точка. </p>
&nbsp;</p>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Замечание: Умолчания нельзя присоединить к системным типам данным, поскольку неясно какие значения потребуются различным пользователям. Также не допускается присоединение умолчаний к столбцам типа timestamp (моменты времени), поскольку SQL Сервер автоматически записывает значения в эти столбцы. Можно связывать умолчания со столбцами типа IDENTITY (счетчик) или с типами данных, определенными пользователем и имеющими свойство IDENTITY, но такие умолчания игнорируются. Каждый раз когда&nbsp; вводится новая строка без указания значения для счетчика, SQL Сервер записывает в этот столбец значение, которое на единицу больше предыдущего.</p>
&nbsp;</p>
Если создать специальный тип данных для всех столбцов city каждой таблицы базы данных, то можно присоединить умолчание citydflt &nbsp; к этому типу данных и быть уверенным в том, что значение по умолчанию “Oakland” будет заменять значения в тех столбцах, где это необходимо. Например, если пользовательский тип данных называется citytype, то присоединить к этому типу данных умолчание citydflt можно следующим образом: </p>
&nbsp;</p>
sp_bindefault citydflt, citytype</p>
&nbsp;</p>
Параметр futureonly (только в будущем) может быть использован при связывании умолчания с пользовательским типом данных. Этот параметр предотвращает изменение существующих значений в столбцах этого типа, записанных по умолчанию, на новое значение. Параметр futureonly никогда не используется при связывании умолчания со столбцом таблицы. В следующем примере показано, как создать и присоединить новое значение по умолчанию “Berkeley” к типу данных citytype таким образом, чтобы оно действовало только для вновь создаваемых столбцов. Предыдущее значение по умолчанию “Oakland” будет по-прежнему находиться в уже существующих столбцах типа citytype. </p>
&nbsp;</p>
create default newcitydflt as “Berkeley”</p>
sp_bindefault newcitydflt, citytype, futureonly</p>
&nbsp;</p>
Если большинство людей, чью имена находятся в таблице, живут в местности с одинаковым почтовым кодом, то можно ввести соответствующее значение по умолчанию, чтобы уменьшить время, необходимое для ввода данных. Ниже приведен соответствующий пример умолчания для жителей округа Oakland (Окленд) вместе с его присоединением:</p>
&nbsp;</p>
create default zipdflt as “94609”</p>
sp_bindefault zipdflt, “friends_etc.postalcode”</p>
&nbsp;</p>
Полный синтаксис вызова системной процедуры sp_bindefault имеет следующий вид:</p>
&nbsp;</p>
sp_bindefault название_умолчания, название_объекта&nbsp; [, futureonly]</p>
&nbsp;</p>
Название_умолчания это название умолчания, указанное при его создании процедурой create default. Название_объекта  это название столбца таблицы или пользовательского типа данных, с которым связывается данное умолчание. Если это название не имеет вида таблица.столбец, то оно воспринимается как название типа данных.</p>
Для всех столбцов, имеющих заданный пользовательский тип данных, будет действовать умолчание, связанное с этим типом, если не выполняется одно из следующих условий:</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">&#183;</td><td>Используется третий необязательный&nbsp; параметр futureonly, который предотвращает изменение значений в уже существующих столбцах этого типа; или </td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">&#183;</td><td>Изменено значение по умолчанию для конкретного столбца таблицы. В этом случае действует измененное умолчание.</td></tr></table></div>&nbsp;</p>
Умолчания, связанные со столбцами, всегда имеют преимущество перед умолчаниями, связанными с типами данных. Присоединение значения по умолчанию к столбцу заменяет действие значения по умолчанию, связанного с типом данных этого столбца, но присоединение умолчаний к типу данных не заменяет действие значения по умолчанию, связанного со столбцом, имеющим этот тип данных. В следующей таблице отражено относительное старшинство операций присоединения значений по умолчанию к табличным столбцам и типам данных пользователя:</p>
&nbsp;</p>
Таблица 12-1: Предшествование умолчаний</p>
&nbsp;</p>
<table cellspacing="0" cellpadding="4" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr>
<td>&nbsp;</p>
</td>
<td colspan="2" >Прежнее умолчание связано с:</p>
</td>
</tr>
<tr>
<td>Новое умолчание связано с:</p>
</td>
<td>Пользовательским типом</p>
</td>
<td>Табличным столбцом</p>
</td>
</tr>
<tr>
<td>Пользовательским типом</p>
</td>
<td>Новое значение заменяет прежнее.</p>
</td>
<td>Нет изменений. Действует прежнее.</p>
</td>
</tr>
<tr>
<td>Табличным столбцом</p>
</td>
<td>Новое значение заменяет прежнее.</p>
</td>
<td>Новое значение заменяет прежнее.
</td>
</tr>
</table>
&nbsp;</p>
Существующие столбцы пользовательского типа наследуют новые умолчания для этого типа, если для них специально не было определено другого значения по умолчанию или не был указан третий параметр futureonly. Новые столбцы, имеющие этот тип данных, всегда наследуют значение по умолчанию для этого типа.&nbsp; </p>
Например, предположим, что пользователь создал таблицу foes со столбцом city, который имеет пользовательский тип citytype. Сначала тип citytype не имел значений по умолчанию. После создания умолчания citydflt,&nbsp; оно автоматически связывается со столбцом foes.city. Затем пользователь связывает другое умолчание newcitydflt  с типом citytype. Хотя foes.city является столбцом типа citytype, новое умолчание не будет с ним связано, поскольку значение по умолчание для этого столбца было предварительно изменено.</p>
&nbsp;</p>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Замечание: Значение по умолчанию нельзя связывать и использовать в одном и том же пакете. Процедура sp_bindefault не должна быть в том же пакете, где расположены операторы модификации данных, использующие по умолчанию это значение.</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 42px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Отсоединение умолчаний</td></tr></table></div>&nbsp;</p>
Отсоединение значения по умолчанию означает разрыв его связи с определенным столбцом или типом данных. Отсоединенное умолчание по-прежнему будет хранится в базе данных и может быть использовано в дальнейшем. Для удаления связи между умолчанием и столбцом или типом данных, используется системная процедура sp_unbindefault (отсоединить умолчание). </p>
В следующем примере показано, как отсоединить значение по умолчанию от столбца city таблицы friends_etc:</p>
&nbsp;</p>
execute sp_unbindefault “friends_etc.city”</p>
&nbsp;</p>
После выполнения этой процедуры умолчание все еще будет существовать, однако оно уже не будет действовать для столбца city, поскольку оно было отсоединено от этого столбца.</p>
Для отсоединения умолчания от пользовательского типа данных citytype нужно выполнить следующую команду:</p>
&nbsp;</p>
sp_unbindefault citytype</p>
&nbsp;</p>
Полный синтаксис вызова системной процедуры sp_unbindefault имееи следующий вид:</p>
&nbsp;</p>
sp_unbindefault название_объекта [, futureonly] </p>
&nbsp;</p>
Если параметр название_объекта имеет вид отличный от таблица.столбец, то SQL Сервер интерпретирует его как название пользовательского типа данных. Если отсоединить умолчание от&nbsp; пользовательского типа данных, то оно будет действительно отсоединено от всех столбцов этого типа, за исключением следующих:</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">&#183;</td><td>Указан второй параметр futureonly (только в будущем), который предотвращает отсоединение умолчания от уже существующих столбцов этого типа, или</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">&#183;</td><td>Было указано новое значение по умолчанию для данного столбца.</td></tr></table></div>&nbsp;</p>
Ниже приведен пример, илюстрирующий описанные выше условия:</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">1.</td><td>Создан пользовательский тип nm;</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">2.</td><td>Тип nm указан в операторах создания таблиц friends_etc (друзья) и enemies (враги), при определении столбцов friends_etc.pname, friends_etc.sname,&nbsp; и enemies.nickname;</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">3.</td><td>Создано умолчание nmdflt  и присоединено к типу nm;</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">4.</td><td>Создано новое умолчание nastydflt и связано со столбцом enemies.nickname;</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">5.</td><td>Если теперь отсоединить умолчание nmdflt  от пользовательского типа nm, то отсоединенными будут только столбцы friends.pname и friends.sname. Поскольку исходное умолчание для столбца enemies.nickname было изменено, то отсоединение на него не повлияет, несмотря на то, что этот столбец имеет тип nm.</td></tr></table></div>&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 21px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Удаление умолчаний</td></tr></table></div>&nbsp;</p>
Для удаления умолчаний из базы данных используется команда drop default (удалить умолчание). Перед удалением умолчание должно быть отсоединено от всех столбцов и пользовательских типов данных. Если попытаться удалить умолчание, которое не отсоединено, то SQL Сервер выдаст сообщение об ошибке и команда drop default не будет выполнена. Однако для того, чтобы присоединить новое умолчание, не обязательно удалять прежнее умолчание из базы. Достаточно просто присоединить новое умолчание на его место.</p>
В следующем примере показано, как удалить умолчание citydflt из базы:</p>
&nbsp;</p>
drop default citydflt</p>
&nbsp;</p>
Полный синтаксис команды drop default выглядит следующим образом:</p>
&nbsp;</p>
drop default [владелец.]название _умолчания</p>
 &nbsp; &nbsp; &nbsp; &nbsp;[, [владелец.]название_умолчания]...</p>
&nbsp;</p>
Умолчание может быть удалено только его владельцем.</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 21px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Воздействие умолчаний на значение NULL</td></tr></table></div>&nbsp;</p>
Если при создании столбца была указана опция NOT NULL и с ним не было связано никаких значений по умолчанию, то при попытке оставить это поле пустым SQL Сервер выдаст сообщение об ошибке. </p>
Если удалено умолчание для столбца, в котором можно использовать значение NULL, то SQL Сервер вставляет в этот столбец неопределенное значение всякий раз, когда добавляется строка с неуказанным значением для этого поля. Если же умолчание удалено из столбца, в котором нельзя использовать значение NULL, то при добавлении новых строк, с явно неуказанным для этого поля значением, будет выдано сообщение об ошибке.</p>
Следующая таблица показывает соотношение между существованием умолчания и определением столбца с опциями NULL или NOT NULL. Результаты указаны в таблице:</p>
&nbsp;</p>
Таблица 12-2: Умолчания и неопределенные значения</p>
&nbsp;</p>
<table cellspacing="0" cellpadding="4" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr>
<td><p>Определение столбца</p>
</td>
<td><p>Нет данных и умолчания</p>
</td>
<td><p>Нет данных, но есть умолчание</p>
</td>
<td><p>Введено NULL и нет умолчания</p>
</td>
<td><p>Введено NULL и есть умолчание</p>
</td>
</tr>
<tr>
<td><p>NULL</p>
</td>
<td><p>Null</p>
</td>
<td><p>Значение по умолчанию</p>
</td>
<td><p>Null</p>
</td>
<td><p>Null</p>
</td>
</tr>
<tr>
<td><p>NOT NULL</p>
</td>
<td><p>Ошибка</p>
</td>
<td><p>Значение по умолчанию</p>
</td>
<td><p>Ошибка</p>
</td>
<td><p>Ошибка
</td>
</tr>
</table>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 21px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Создание правил</td></tr></table></div>&nbsp;</p>
Правила создаются с помощью команды create rule (создать правило), а затем присоединяются к столбцу или пользовательскому типу данных с помощью системной процедуры sp_binderule (присоединить правило). Отсоединение правила от столбца или пользовательских типа данных проводится с помощью системной процедуры sp_unbindrule (отсоединить правило) или путем присоединения нового правила к столбцу или пользовательскому типу. </p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 42px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Синтаксис команды create rule</td></tr></table></div>&nbsp;</p>
Синтаксис команды create rule имеет следующий вид:</p>
&nbsp;</p>
create rule [владелец. ]название_правила</p>
 &nbsp; &nbsp; &nbsp; &nbsp;as условное_выражение</p>
&nbsp;</p>
Названия правил должны соответствовать правилам, установленным для идентификаторов. Правила можно создавать только в текущей базе данных.</p>
Названия правил должны быть уникальными для каждого пользователя внутри одной базы данных. Например, один пользователь не может создать два правила с названием socsecrule. Однако, два различных пользователя могут создать правила с названием socsecrule, поскольку имена пользователей позволяют их различить. </p>
В следующем примере показано правило, которое допускает пять различных значений для столбца pub_id и любое четырехзначное число, начинающееся с двух девяток 99:</p>
&nbsp;</p>
create rule pub_idrule</p>
as @pub_id in (“1389”, “0736”, “0877”, “1622”, “1756”)</p>
or @pub_id like “99[0-9] [0-9]”</p>
&nbsp;</p>
Конструкция as содержит название аргумента правила, которому предшествует символ “@”, и непосредственно определение правила.&nbsp; Аргумент ссылается на значение в столбце, которое может изменяться операторами update и insert.</p>
В предыдущем примере аргумент называется @pub_id, чтобы подчеркнуть, что это правило будет связано со столбцом pub_id. Для аргумента можно использовать любое имя, но первым символом обязательно должен быть символ “@”. Использование в качестве названия аргумента названия столбца или пользовательского типа данных, к которому это правило присоединяется, позволяет легче запомнить, для чего оно предназначено.</p>
Определение правила может содержать любое выражение, которое допускается в конструкции where, и которое состоит из арифметических операций, операций сравнения like, in, between и т.д. Однако, в определении правила нельзя явно ссылаться на название столбца или другого объекта базы данных. Допускается также использование встроенных функций, которые не ссылаются непосредственно на объекты базы данных.</p>
В следующем примере показано, как создать правило, которое допускает только входные данные, удовлетворяющие определенной “схеме”. В этом примере каждое значение в столбце должно начинаться с цифр “415”, за которым должны следовать еще семь символов:</p>
&nbsp;</p>
create rule phonerule</p>
as @phone like &#8216;415_ _ _ _ _ _ _&#8217;</p>
&nbsp;</p>
Следующее правило устанавливает, что возраст друзей пользователя может изменяться от 1 до 120, но не равен 17:</p>
&nbsp;</p>
create rule agerule</p>
as @age between 1 and 120 and @age !=17&nbsp;&nbsp;    </p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 42px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Присоединение правил</td></tr></table></div>&nbsp;</p>
После создания правила его нужно присоединить к определенному столбцу или пользовательскому типу данных с помощью системной процедуры sp_bindrule (присоединить правило). </p>
Полный синтаксис процедуры sp_bindrule  выглядит так:</p>
&nbsp;</p>
sp_binderule название_правила, название_объекта [, futureonly]</p>
&nbsp;</p>
Параметр название_правила это название того правила, которое было создано с помощью процедуры create rule. Параметр название_объекта это название столбца или пользовательского типа, к которому это правило будет присоединено. Если этот параметр не имеет вида таблица.столбец, то он воспринимается как название пользовательского типа данных.</p>
Третий необязательный&nbsp; параметр futureonly имеет смысл только в том случае, если правило присоединяется к типу данных. Правило связывается со всеми существующими столбцами, имеющими указанный тип, если не указан параметр futureonly, который предотвращает наследование этого правила. Если правило, связанное с определенным пользовательским типом, было предварительно изменено, то измененное правило будет действовать для существующих столбцов этого типа.</p>
&nbsp;</p>
Замечание: Не допускается присоединение правил к столбцам типа text, image, и timestamp.</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 16px 63px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Связывание правил с табличными столбцами</td></tr></table></div>&nbsp;</p>
Правило присоединяется к столбцу с помощью процедуры sp_binderule, которой в качестве параметров передается название правила, а также&nbsp; название таблицы и столбца, заключенные в кавычки. Ниже показано, как присоединить правило pub_idrule к столбцу publishers pub_id:</p>
&nbsp;</p>
sp_binderule pub_idrule, “publishers.pub_id”</p>
&nbsp;</p>
Другой пример показывает, как создать правило, которое допускает&nbsp; только почтовые коды, начинающиеся с цифр 946:</p>
&nbsp;</p>
create rule postalcoderule946</p>
as @postalcode like “946[0-9] [0-9]”</p>
&nbsp;</p>
Связывание этого правила со столбцом postalcode таблицы friends_etc  выглядит следующим образом:</p>
&nbsp;</p>
sp_binderule postalcoderule946, “friends_etc.postalcode”</p>
&nbsp;</p>
Правило нельзя связывать и использовать в одном пакете. Процедура sp_binderule не должны быть в одном пакете вместе с операторами вставки, которые используют это правило. </p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 16px 63px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Связывание правил с пользовательскими типами данных</td></tr></table></div>&nbsp;</p>
Правила нельзя связывать с системными типами данных, т.е. их можно присоединять только к пользовательским типам данных. Например, чтобы связать правило phonerule с пользовательским типу p#, омужно выполнить команду:</p>
&nbsp;</p>
sp_binderule, “p#”</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 16px 63px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Старшинство правил</td></tr></table></div>&nbsp;</p>
Правила, связанные со столбцами, всегда сильнее правил, связанных с типами данных. Присоединение правила к столбцу заменяет правило, которое связано с типом данных этого столбца, но присоединение правила к типу данных не заменяет правила, связанного со столбцом этого типа. </p>
Правило, связанное с типом данных, начинает действовать только при попытке обновить или вставить значения в столбец данных этого типа. Поскольку правила не проверяют значения переменных, то пользователь должен стараться не присваивать переменной пользовательского типа значения, которое не допускается правилом для этого типа данных.</p>
Следующая таблица иллюстрирует старшинство замещения правил при их связывании с табличными столбцами и типами данных, когда последние уже имеют связанные с ними правила. </p>
&nbsp;</p>
Таблица 12-3: Старшинство правил</p>
&nbsp;</p>
<table cellspacing="0" cellpadding="4" border="0" style="border: none border-spacing:0px; border-collapse: collapse;">
<tr>
<td><p>Новое правило связывается с:</p>
</td>
<td colspan="2" ><p>Прежнее правило связано с:</p>
</td>
</tr>
<tr>
<td>
</td>
<td><p>Пользовательским типом</p>
</td>
<td><p>Табличным столбцом</p>
</td>
</tr>
<tr>
<td><p>Пользовательским типом</p>
</td>
<td><p>Заменяет прежнее</p>
<p>правило.</p>
</td>
<td><p>Нет изменений. Действует прежнее.</p>
</td>
</tr>
<tr>
<td><p>Табличным столбцом</p>
</td>
<td><p>Заменяет прежнее</p>
<p>правило.</p>
</td>
<td><p>Заменяет прежнее</p>
<p>правило.
</td>
</tr>
</table>
&nbsp;</p>
При введении данных в табличные столбцы, которые требуют особых временных ограничений, можно сделать новое правило для проверки этих данных. Например, предположим, пользователю нужно добавить данные о величине долгов в столбец debt (долг) таблицы friends_etc. Ему известно, что все долги, которые нужно зафиксировать, находятся в пределах от $5 до $200. Чтобы избежать случайных ошибок и не допустить чисел, выходящих из этого диапазона, можно сделать следующее правило. (Это правило позволяет вводить нулевое значение $0.00, которая ранее было определено как значение по умолчанию для этого столбца.) </p>
&nbsp;</p>
create rule debtrule</p>
as @debt = $0.00 or @debt between $5.0 and $200.00</p>
&nbsp;</p>
Правило debtrule связывается со столбцом debt следующим образом:</p>
&nbsp;</p>
sp_bindrule debtrule, “friends_etc.debt”</p>
&nbsp;</p>
Замечание: После создания и присоединения правила нужно обязательно проверить его, записав в таблицу некоторые данные. Многие ошибки, связанные с созданием и присоединением правил, могут быть обнаружены только с помощью операторов insert и update. </p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 42px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Отсоединение правил</td></tr></table></div>&nbsp;</p>
Отсоединение правил означает разрыв их связи со столбцом или типом данных. Определение отсоединенного правила по-прежнему остается в базе данных и может быть использовано в дальнейшем.</p>
Существуют два способа отсоединить правило:</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">&#183;</td><td>С помощью системной процедуры sp_unbinderule (отсоединить правило) удалить связь между правилом и столбцом или типом данных;</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">&#183;</td><td>С помощью системной процедуры sp_bindrule присоединить новое правило к столбцу или типу данных. Прежнее правило при этом автоматически отсоединяется.</td></tr></table></div>&nbsp;</p>
Ниже показано, как отсоединить правило debtrule (или любое другое связанное правило) от столбца friends_etc.debt:&nbsp; </p>
&nbsp;</p>
sp_unbindrule “friends_etc.debt”</p>
&nbsp;</p>
После выполнения этой команды правило debtrule  по-прежнему остается в базе данных, но от столбца friends_etc.debt  оно уже отсоединено.</p>
Для отсоединения правила от пользовательского типа p# нужно выполнить следующую команду:</p>
&nbsp;</p>
sp_unbinderule “p#”</p>
&nbsp;</p>
Полный синтаксис вызова системной процедуры sp_unbinderule выглядит следующим образом:</p>
&nbsp;</p>
sp_unbindrule название_объекта [, futureonly]</p>
&nbsp;</p>
Если параметр название_объекта не имеет вида таблица.столбец, то он воспринимается как название пользовательского типа данных. Если правило отсоединяется от типа данных, то оно отсоединяется также от всех столбцов этого типа, если не выполняется одно из следующих условий:</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">&#183;</td><td>Указан второй необязательный параметр futureonly (только в будущем), который предотвращает отсоединение этого правила от существующих столбцов этого типа, или;</td></tr></table></div><div style="text-align: left; text-indent: 0px; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 114px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="28">&#183;</td><td>Было изменено правило для данного табличного столбца.</td></tr></table></div>&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 21px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Удаление правил</td></tr></table></div>&nbsp;</p>
Для удаления правил из базы данных используется команда drop rule (удалить правило). Перед удалением правило должно быть отсоединено от всех столбцов и типов данных. Если попытаться удалить связанное правило, то SQL Cервер выдаст сообщение об ошибке и команда drop rule не будет выполняться. Однако для того, чтобы присоединить новое правило, не обязательно отсоединять и удалять прежнее правило. Достаточно просто присоединить новое правило на место прежнего.</p>
Ниже показано, как удалить правило phonerule после его отсоединения:</p>
&nbsp;</p>
drop rule phonerule</p>
&nbsp;</p>
Полный синтаксис команды drop rule выглядит следующим образом:</p>
&nbsp;</p>
drop rule [владелец.]название_правила</p>
 &nbsp; &nbsp; &nbsp; &nbsp;[, [владелец.]название_правила] ...</p>
&nbsp;</p>
После удаления правила оно не будет оказывать воздействия на новые данные, которые вводятся в соответсвующий столбец таблицы. Уже существующие табличные данные никак не изменятся.</p>
Правило может быть удалено только ее владельцем.</p>
&nbsp;</p>
<div style="text-align: left; text-indent: 0px; border-color: #000000; border-style: solid; border-width: 1px; border-top: none; border-right: none; border-left: none; padding: 0px 0px 1px 0px; margin: 0px 0px 1px 21px;"><table border="0" cellpadding="0" cellspacing="0" style="line-height: normal;"><tr><td width="21"></td><td>Получение информации о правилах и умолчаниях</td></tr></table></div>&nbsp;</p>
Системная процедура sp_help, вызываемая вместе с названием таблицы, выдает список правил и умолчаний, связанных со столбцами этой таблицы. В следующем примере показано как получить информацию о таблице authors из базы данных pubs, включая сведения о правилах и умолчаниях:</p>
&nbsp;</p>
sp_help authors</p>
&nbsp;</p>
С помощью системной процедуры sp_help можно также получить информацию о правилах, связанных с пользовательскими типами данных. В следующем примере проверяется, имеет ли тип данных “p#”, связанные с ним&nbsp; правило:</p>
&nbsp;</p>
sp_help “p#”</p>
&nbsp;</p>
Процедура sp_helptext выдает текст определения (т.е. оператора create) правила или умолчания.</p>
&nbsp;</p>
</div>

<div id="footer">
<hr/>
<p>Материал из DRKB Library<br/>Разработка и поддержка &mdash; <a title="DRKB на GitHub" href="https://github.com/quadroid/drkb" target="_blank">Quadr0</a></p>
</div>
</div>
</body>
</html>
